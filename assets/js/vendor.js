/*! For license information please see vendor.js.LICENSE.txt */
(window.webpackJsonp = window.webpackJsonp || []).push([[3], {
    "6Y8T": function (t, e) {
        t.exports = function (t) {
            "string" == typeof t && (t = [t]);
            for (var e = [].slice.call(arguments, 1), n = [], i = 0; i < t.length - 1; i++) n.push(t[i], e[i] || "");
            return n.push(t[i]), n.join("")
        }
    },
    "9Pv3": function (t, e) {
        t.exports = function (t, {
            tagName: e = "span",
            split: n,
            setClassName: i = function (t) {
                return "char" + t
            }
        } = {}) {
            t.normalize();
            let r = 1;

            function s(t) {
                const s = t.parentNode,
                    o = t.nodeValue;
                (n ? n(o) : o.split("")).forEach((function (n) {
                    const o = document.createElement(e),
                        a = i(r++, n);
                    a && (o.className = a), o.appendChild(document.createTextNode(n)), o.setAttribute("aria-hidden", "true"), s.insertBefore(o, t)
                })), "" !== o.trim() && s.setAttribute("aria-label", o), s.removeChild(t)
            }! function t(e) {
                if (3 === e.nodeType) return s(e);
                const n = Array.prototype.slice.call(e.childNodes);
                if (1 === n.length && 3 === n[0].nodeType) return s(n[0]);
                n.forEach((function (e) {
                    t(e)
                }))
            }(t)
        }
    },
    C7UG: function (t, e, n) {
        "use strict";
        var i = n("wOJ8"),
            r = n.n(i);
        class s {
            constructor(t) {
                this.wrap = document.querySelector("[data-router-wrapper]"), this.properties = t, this.Transition = t.transition ? new t.transition.class(this.wrap, t.transition.name) : null
            }
            setup() {
                this.onEnter && this.onEnter(), this.onEnterCompleted && this.onEnterCompleted()
            }
            add() {
                this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML)
            }
            update() {
                document.title = this.properties.page.title
            }
            show(t) {
                return new Promise(async e => {
                    this.update(), this.onEnter && this.onEnter(), this.Transition && await this.Transition.show(t), this.onEnterCompleted && this.onEnterCompleted(), e()
                })
            }
            hide(t) {
                return new Promise(async e => {
                    this.onLeave && this.onLeave(), this.Transition && await this.Transition.hide(t), this.onLeaveCompleted && this.onLeaveCompleted(), e()
                })
            }
        }
        const o = new window.DOMParser;
        class a {
            constructor(t, e) {
                this.renderers = t, this.transitions = e
            }
            getOrigin(t) {
                const e = t.match(/(https?:\/\/[\w\-.]+)/);
                return e ? e[1].replace(/https?:\/\//, "") : null
            }
            getPathname(t) {
                const e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
                return e ? e[1] : "/"
            }
            getAnchor(t) {
                const e = t.match(/(#.*)$/);
                return e ? e[1] : null
            }
            getParams(t) {
                const e = t.match(/\?([\w_\-.=&]+)/);
                if (!e) return null;
                const n = e[1].split("&"),
                    i = {};
                for (let t = 0; t < n.length; t++) {
                    const e = n[t].split("="),
                        {
                            0: r
                        } = e,
                        {
                            1: s
                        } = e;
                    i[r] = s
                }
                return i
            }
            getDOM(t) {
                return "string" == typeof t ? o.parseFromString(t, "text/html") : t
            }
            getView(t) {
                return t.querySelector("[data-router-view]")
            }
            getSlug(t) {
                return t.getAttribute("data-router-view")
            }
            getRenderer(t) {
                if (!this.renderers) return Promise.resolve(s);
                if (t in this.renderers) {
                    const e = this.renderers[t];
                    return "function" != typeof e || s.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then(({
                        default: t
                    }) => t) : Promise.resolve(e) : Promise.resolve(e()).then(({
                        default: t
                    }) => t)
                }
                return Promise.resolve(s)
            }
            getTransition(t) {
                return this.transitions ? t in this.transitions ? {
                    class: this.transitions[t],
                    name: t
                } : "default" in this.transitions ? {
                    class: this.transitions.default,
                    name: "default"
                } : null : null
            }
            getProperties(t) {
                const e = this.getDOM(t),
                    n = this.getView(e),
                    i = this.getSlug(n);
                return {
                    page: e,
                    view: n,
                    slug: i,
                    renderer: this.getRenderer(i, this.renderers),
                    transition: this.getTransition(i, this.transitions)
                }
            }
            getLocation(t) {
                return {
                    href: t,
                    anchor: this.getAnchor(t),
                    origin: this.getOrigin(t),
                    params: this.getParams(t),
                    pathname: this.getPathname(t)
                }
            }
        }
        class c extends r.a {
            constructor({
                renderers: t,
                transitions: e
            } = {}) {
                super(), this.Helpers = new a(t, e), this.Transitions = e, this.Contextual = !1, this.location = this.Helpers.getLocation(window.location.href), this.properties = this.Helpers.getProperties(document.cloneNode(!0)), this.popping = !1, this.running = !1, this.trigger = null, this.cache = new Map, this.cache.set(this.location.href, this.properties), this.properties.renderer.then(t => {
                    this.From = new t(this.properties), this.From.setup()
                }), this._navigate = this.navigate.bind(this), window.addEventListener("popstate", this.popState.bind(this)), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links)
            }
            attach(t) {
                for (const e of t) e.addEventListener("click", this._navigate)
            }
            detach(t) {
                for (const e of t) e.removeEventListener("click", this._navigate)
            }
            navigate(t) {
                if (!t.metaKey && !t.ctrlKey) {
                    t.preventDefault();
                    const e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition;
                    this.redirect(t.currentTarget.href, e, t.currentTarget)
                }
            }
            redirect(t, e = !1, n = "script") {
                if (this.trigger = n, !this.running && t !== this.location.href) {
                    const n = this.Helpers.getLocation(t);
                    this.Contextual = !1, e && (this.Contextual = this.Transitions.contextual[e].prototype, this.Contextual.name = e), n.origin !== this.location.origin || n.anchor && n.pathname === this.location.pathname ? window.location.href = t : (this.location = n, this.beforeFetch())
                }
            }
            popState() {
                this.trigger = "popstate", this.Contextual = !1;
                const t = this.Helpers.getLocation(window.location.href);
                this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0, this.location = t, this.beforeFetch()) : this.location = t
            }
            pushState() {
                this.popping || window.history.pushState(this.location, "", this.location.href)
            }
            async fetch() {
                const t = await fetch(this.location.href, {
                    mode: "same-origin",
                    method: "GET",
                    headers: {
                        "X-Requested-With": "Highway"
                    },
                    credentials: "same-origin"
                });
                if (t.status >= 200 && t.status < 300) return t.text();
                window.location.href = this.location.href
            }
            async beforeFetch() {
                this.pushState(), this.running = !0, this.emit("NAVIGATE_OUT", {
                    from: {
                        page: this.From.properties.page,
                        view: this.From.properties.view
                    },
                    trigger: this.trigger,
                    location: this.location
                });
                const t = {
                    trigger: this.trigger,
                    contextual: this.Contextual
                };
                if (this.cache.has(this.location.href)) await this.From.hide(t), this.properties = this.cache.get(this.location.href);
                else {
                    const e = await Promise.all([this.fetch(), this.From.hide(t)]);
                    this.properties = this.Helpers.getProperties(e[0]), this.cache.set(this.location.href, this.properties)
                }
                this.afterFetch()
            }
            async afterFetch() {
                const t = await this.properties.renderer;
                this.To = new t(this.properties), this.To.add(), this.emit("NAVIGATE_IN", {
                    to: {
                        page: this.To.properties.page,
                        view: this.To.wrap.lastElementChild
                    },
                    trigger: this.trigger,
                    location: this.location
                }), await this.To.show({
                    trigger: this.trigger,
                    contextual: this.Contextual
                }), this.popping = !1, this.running = !1, this.detach(this.links), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links), this.emit("NAVIGATE_END", {
                    to: {
                        page: this.To.properties.page,
                        view: this.To.wrap.lastElementChild
                    },
                    from: {
                        page: this.From.properties.page,
                        view: this.From.properties.view
                    },
                    trigger: this.trigger,
                    location: this.location
                }), this.From = this.To, this.trigger = null
            }
        }
        e.a = {
            Core: c,
            Helpers: a,
            Renderer: s,
            Transition: class {
                constructor(t, e) {
                    this.wrap = t, this.name = e
                }
                show({
                    trigger: t,
                    contextual: e
                }) {
                    const n = this.wrap.lastElementChild,
                        i = this.wrap.firstElementChild;
                    return new Promise(r => {
                        e ? (n.setAttribute("data-transition-in", e.name), n.removeAttribute("data-transition-out", e.name), e.in && e.in({
                            to: n,
                            from: i,
                            trigger: t,
                            done: r
                        })) : (n.setAttribute("data-transition-in", this.name), n.removeAttribute("data-transition-out", this.name), this.in && this.in({
                            to: n,
                            from: i,
                            trigger: t,
                            done: r
                        }))
                    })
                }
                hide({
                    trigger: t,
                    contextual: e
                }) {
                    const n = this.wrap.firstElementChild;
                    return new Promise(i => {
                        e ? (n.setAttribute("data-transition-out", e.name), n.removeAttribute("data-transition-in", e.name), e.out && e.out({
                            from: n,
                            trigger: t,
                            done: i
                        })) : (n.setAttribute("data-transition-out", this.name), n.removeAttribute("data-transition-in", this.name), this.out && this.out({
                            from: n,
                            trigger: t,
                            done: i
                        }))
                    })
                }
            }
        }
    },
    G1Ma: function (t, e, n) {
        "use strict";
        n.d(e, "a", (function () {
            return a
        }));
        var i, r, s, o = n("Womt");

        function a() {
            this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        }
        Object.assign(a.prototype, {
            setSize: function () {},
            render: function () {}
        }), a.FullScreenQuad = (i = new o.g(-1, 1, 1, -1, 0, 1), r = new o.i(2, 2), s = function (t) {
            this._mesh = new o.e(r, t)
        }, Object.defineProperty(s.prototype, "material", {
            get: function () {
                return this._mesh.material
            },
            set: function (t) {
                this._mesh.material = t
            }
        }), Object.assign(s.prototype, {
            dispose: function () {
                this._mesh.geometry.dispose()
            },
            render: function (t) {
                t.render(this._mesh, i)
            }
        }), s)
    },
    MZFn: function (t, e, n) {
        var i;
        t.exports = ((i = function () {
            function t(t) {
                return r.appendChild(t.dom), t
            }

            function e(t) {
                for (var e = 0; e < r.children.length; e++) r.children[e].style.display = e === t ? "block" : "none";
                n = t
            }
            var n = 0,
                r = document.createElement("div");
            r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", (function (t) {
                t.preventDefault(), e(++n % r.children.length)
            }), !1);
            var s = (performance || Date).now(),
                o = s,
                a = 0,
                c = t(new i.Panel("FPS", "#0ff", "#002")),
                l = t(new i.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory) var h = t(new i.Panel("MB", "#f08", "#201"));
            return e(0), {
                REVISION: 16,
                dom: r,
                addPanel: t,
                showPanel: e,
                begin: function () {
                    s = (performance || Date).now()
                },
                end: function () {
                    a++;
                    var t = (performance || Date).now();
                    if (l.update(t - s, 200), t > o + 1e3 && (c.update(1e3 * a / (t - o), 100), o = t, a = 0, h)) {
                        var e = performance.memory;
                        h.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576)
                    }
                    return t
                },
                update: function () {
                    s = this.end()
                },
                domElement: r,
                setMode: e
            }
        }).Panel = function (t, e, n) {
            var i = 1 / 0,
                r = 0,
                s = Math.round,
                o = s(window.devicePixelRatio || 1),
                a = 80 * o,
                c = 48 * o,
                l = 3 * o,
                h = 2 * o,
                u = 3 * o,
                p = 15 * o,
                d = 74 * o,
                f = 30 * o,
                m = document.createElement("canvas");
            m.width = a, m.height = c, m.style.cssText = "width:80px;height:48px";
            var g = m.getContext("2d");
            return g.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, a, c), g.fillStyle = e, g.fillText(t, l, h), g.fillRect(u, p, d, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u, p, d, f), {
                dom: m,
                update: function (c, v) {
                    i = Math.min(i, c), r = Math.max(r, c), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, a, p), g.fillStyle = e, g.fillText(s(c) + " " + t + " (" + s(i) + "-" + s(r) + ")", l, h), g.drawImage(m, u + o, p, d - o, f, u, p, d - o, f), g.fillRect(u + d - o, p, o, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u + d - o, p, o, s((1 - c / v) * f))
                }
            }
        }, i)
    },
    "Mtn/": function (t, e, n) {
        "use strict";
        n.d(e, "a", (function () {
            return l
        }));
        var i = n("Womt"),
            r = {
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
            },
            s = n("Ng1w"),
            o = n("G1Ma"),
            a = function (t, e) {
                o.a.call(this), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
            };
        a.prototype = Object.assign(Object.create(o.a.prototype), {
            constructor: a,
            render: function (t, e, n) {
                var i, r, s = t.getContext(),
                    o = t.state;
                o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0), this.inverse ? (i = 0, r = 1) : (i = 1, r = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.buffers.stencil.setFunc(s.ALWAYS, i, 4294967295), o.buffers.stencil.setClear(r), o.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.buffers.stencil.setLocked(!0)
            }
        });
        var c = function () {
            o.a.call(this), this.needsSwap = !1
        };
        c.prototype = Object.create(o.a.prototype), Object.assign(c.prototype, {
            render: function (t) {
                t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
            }
        });
        var l = function (t, e) {
            if (this.renderer = t, void 0 === e) {
                var n = {
                        minFilter: i.d,
                        magFilter: i.d,
                        format: i.j
                    },
                    o = t.getSize(new i.o);
                this._pixelRatio = t.getPixelRatio(), this._width = o.width, this._height = o.height, (e = new i.q(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1"
            } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
            this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], s.a, this.copyPass = new s.a(r), this.clock = new i.a
        };
        Object.assign(l.prototype, {
            swapBuffers: function () {
                var t = this.readBuffer;
                this.readBuffer = this.writeBuffer, this.writeBuffer = t
            },
            addPass: function (t) {
                this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            },
            insertPass: function (t, e) {
                this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            },
            removePass: function (t) {
                const e = this.passes.indexOf(t); - 1 !== e && this.passes.splice(e, 1)
            },
            isLastEnabledPass: function (t) {
                for (var e = t + 1; e < this.passes.length; e++)
                    if (this.passes[e].enabled) return !1;
                return !0
            },
            render: function (t) {
                void 0 === t && (t = this.clock.getDelta());
                var e, n, i = this.renderer.getRenderTarget(),
                    r = !1,
                    s = this.passes.length;
                for (n = 0; n < s; n++)
                    if (!1 !== (e = this.passes[n]).enabled) {
                        if (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), e.render(this.renderer, this.writeBuffer, this.readBuffer, t, r), e.needsSwap) {
                            if (r) {
                                var o = this.renderer.getContext(),
                                    l = this.renderer.state.buffers.stencil;
                                l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(o.EQUAL, 1, 4294967295)
                            }
                            this.swapBuffers()
                        }
                        void 0 !== a && (e instanceof a ? r = !0 : e instanceof c && (r = !1))
                    } this.renderer.setRenderTarget(i)
            },
            reset: function (t) {
                if (void 0 === t) {
                    var e = this.renderer.getSize(new i.o);
                    this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                }
                this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
            },
            setSize: function (t, e) {
                this._width = t, this._height = e;
                var n = this._width * this._pixelRatio,
                    i = this._height * this._pixelRatio;
                this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
                for (var r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i)
            },
            setPixelRatio: function (t) {
                this._pixelRatio = t, this.setSize(this._width, this._height)
            }
        });
        var h, u, p, d = function () {
            this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        };
        Object.assign(d.prototype, {
            setSize: function () {},
            render: function () {}
        }), d.FullScreenQuad = (h = new i.g(-1, 1, 1, -1, 0, 1), u = new i.i(2, 2), p = function (t) {
            this._mesh = new i.e(u, t)
        }, Object.defineProperty(p.prototype, "material", {
            get: function () {
                return this._mesh.material
            },
            set: function (t) {
                this._mesh.material = t
            }
        }), Object.assign(p.prototype, {
            dispose: function () {
                this._mesh.geometry.dispose()
            },
            render: function (t) {
                t.render(this._mesh, h)
            }
        }), p)
    },
    Ng1w: function (t, e, n) {
        "use strict";
        n.d(e, "a", (function () {
            return s
        }));
        var i = n("Womt"),
            r = n("G1Ma"),
            s = function (t, e) {
                r.a.call(this), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof i.l ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = i.n.clone(t.uniforms), this.material = new i.l({
                    defines: Object.assign({}, t.defines),
                    uniforms: this.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                })), this.fsQuad = new r.a.FullScreenQuad(this.material)
            };
        s.prototype = Object.assign(Object.create(r.a.prototype), {
            constructor: s,
            render: function (t, e, n) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
            }
        })
    },
    Womt: function (t, e, n) {
        "use strict";
        n.d(e, "a", (function () {
            return Oa
        })), n.d(e, "b", (function () {
            return Mo
        })), n.d(e, "c", (function () {
            return tr
        })), n.d(e, "d", (function () {
            return i
        })), n.d(e, "e", (function () {
            return Ie
        })), n.d(e, "f", (function () {
            return _t
        })), n.d(e, "g", (function () {
            return ca
        })), n.d(e, "h", (function () {
            return Ge
        })), n.d(e, "i", (function () {
            return $e
        })), n.d(e, "j", (function () {
            return r
        })), n.d(e, "k", (function () {
            return or
        })), n.d(e, "l", (function () {
            return Ve
        })), n.d(e, "m", (function () {
            return No
        })), n.d(e, "n", (function () {
            return ke
        })), n.d(e, "o", (function () {
            return l
        })), n.d(e, "p", (function () {
            return x
        })), n.d(e, "q", (function () {
            return v
        })), n.d(e, "r", (function () {
            return rr
        }));
        const i = 1006,
            r = 1023;

        function s() {}
        Object.assign(s.prototype, {
            addEventListener: function (t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            },
            hasEventListener: function (t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            },
            removeEventListener: function (t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            },
            dispatchEvent: function (t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
                }
            }
        });
        const o = [];
        for (let t = 0; t < 256; t++) o[t] = (t < 16 ? "0" : "") + t.toString(16);
        let a = 1234567;
        const c = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function () {
                const t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0;
                return (o[255 & t] + o[t >> 8 & 255] + o[t >> 16 & 255] + o[t >> 24 & 255] + "-" + o[255 & e] + o[e >> 8 & 255] + "-" + o[e >> 16 & 15 | 64] + o[e >> 24 & 255] + "-" + o[63 & n | 128] + o[n >> 8 & 255] + "-" + o[n >> 16 & 255] + o[n >> 24 & 255] + o[255 & i] + o[i >> 8 & 255] + o[i >> 16 & 255] + o[i >> 24 & 255]).toUpperCase()
            },
            clamp: function (t, e, n) {
                return Math.max(e, Math.min(n, t))
            },
            euclideanModulo: function (t, e) {
                return (t % e + e) % e
            },
            mapLinear: function (t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            lerp: function (t, e, n) {
                return (1 - n) * t + n * e
            },
            smoothstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function (t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function (t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function (t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function (t) {
                return void 0 !== t && (a = t % 2147483647), a = 16807 * a % 2147483647, (a - 1) / 2147483646
            },
            degToRad: function (t) {
                return t * c.DEG2RAD
            },
            radToDeg: function (t) {
                return t * c.RAD2DEG
            },
            isPowerOfTwo: function (t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function (t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function (t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            },
            setQuaternionFromProperEuler: function (t, e, n, i, r) {
                const s = Math.cos,
                    o = Math.sin,
                    a = s(n / 2),
                    c = o(n / 2),
                    l = s((e + i) / 2),
                    h = o((e + i) / 2),
                    u = s((e - i) / 2),
                    p = o((e - i) / 2),
                    d = s((i - e) / 2),
                    f = o((i - e) / 2);
                switch (r) {
                    case "XYX":
                        t.set(a * h, c * u, c * p, a * l);
                        break;
                    case "YZY":
                        t.set(c * p, a * h, c * u, a * l);
                        break;
                    case "ZXZ":
                        t.set(c * u, c * p, a * h, a * l);
                        break;
                    case "XZX":
                        t.set(a * h, c * f, c * d, a * l);
                        break;
                    case "YXY":
                        t.set(c * d, a * h, c * f, a * l);
                        break;
                    case "ZYZ":
                        t.set(c * f, c * d, a * h, a * l)
                }
            }
        };
        class l {
            constructor(t = 0, e = 0) {
                Object.defineProperty(this, "isVector2", {
                    value: !0
                }), this.x = t, this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            add(t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this)
            }
            addScalar(t) {
                return this.x += t, this.y += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }
            sub(t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this)
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }
            fromBufferAttribute(t, e, n) {
                return this.x = t.getX(e), this.y = t.getY(e), this
            }
            rotateAround(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = this.x - t.x,
                    s = this.y - t.y;
                return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }
        }
        class h {
            constructor() {
                Object.defineProperty(this, "isMatrix3", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
            }
            set(t, e, n, i, r, s, o, a, c) {
                const l = this.elements;
                return l[0] = t, l[1] = i, l[2] = o, l[3] = e, l[4] = r, l[5] = a, l[6] = n, l[7] = s, l[8] = c, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[3],
                    a = n[6],
                    c = n[1],
                    l = n[4],
                    h = n[7],
                    u = n[2],
                    p = n[5],
                    d = n[8],
                    f = i[0],
                    m = i[3],
                    g = i[6],
                    v = i[1],
                    y = i[4],
                    _ = i[7],
                    x = i[2],
                    b = i[5],
                    M = i[8];
                return r[0] = s * f + o * v + a * x, r[3] = s * m + o * y + a * b, r[6] = s * g + o * _ + a * M, r[1] = c * f + l * v + h * x, r[4] = c * m + l * y + h * b, r[7] = c * g + l * _ + h * M, r[2] = u * f + p * v + d * x, r[5] = u * m + p * y + d * b, r[8] = u * g + p * _ + d * M, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    c = t[7],
                    l = t[8];
                return e * s * l - e * o * c - n * r * l + n * o * a + i * r * c - i * s * a
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    c = t[7],
                    l = t[8],
                    h = l * s - o * c,
                    u = o * a - l * r,
                    p = c * r - s * a,
                    d = e * h + n * u + i * p;
                if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / d;
                return t[0] = h * f, t[1] = (i * c - l * n) * f, t[2] = (o * n - i * s) * f, t[3] = u * f, t[4] = (l * e - i * a) * f, t[5] = (i * r - o * e) * f, t[6] = p * f, t[7] = (n * a - c * e) * f, t[8] = (s * e - n * r) * f, this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).copy(this).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }
            setUvTransform(t, e, n, i, r, s, o) {
                const a = Math.cos(r),
                    c = Math.sin(r);
                this.set(n * a, n * c, -n * (a * s + c * o) + s + t, -i * c, i * a, -i * (-c * s + a * o) + o + e, 0, 0, 1)
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
            }
            rotate(t) {
                const e = Math.cos(t),
                    n = Math.sin(t),
                    i = this.elements,
                    r = i[0],
                    s = i[3],
                    o = i[6],
                    a = i[1],
                    c = i[4],
                    l = i[7];
                return i[0] = e * r + n * a, i[3] = e * s + n * c, i[6] = e * o + n * l, i[1] = -n * r + e * a, i[4] = -n * s + e * c, i[7] = -n * o + e * l, this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
        }
        let u;
        const p = {
            getDataURL: function (t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                let e;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === u && (u = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), u.width = t.width, u.height = t.height;
                    const n = u.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = u
                }
                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        };
        let d = 0;

        function f(t = f.DEFAULT_IMAGE, e = f.DEFAULT_MAPPING, n = 1001, s = 1001, o = i, a = 1008, u = r, p = 1009, m = 1, g = 3e3) {
            Object.defineProperty(this, "id", {
                value: d++
            }), this.uuid = c.generateUUID(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = s, this.magFilter = o, this.minFilter = a, this.anisotropy = m, this.format = u, this.internalFormat = null, this.type = p, this.offset = new l(0, 0), this.repeat = new l(1, 1), this.center = new l(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new h, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = g, this.version = 0, this.onUpdate = null
        }

        function m(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? p.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : {}
        }
        f.DEFAULT_IMAGE = void 0, f.DEFAULT_MAPPING = 300, f.prototype = Object.assign(Object.create(s.prototype), {
            constructor: f,
            isTexture: !0,
            updateMatrix: function () {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function (t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const i = this.image;
                    if (void 0 === i.uuid && (i.uuid = c.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                        let e;
                        if (Array.isArray(i)) {
                            e = [];
                            for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(m(i[t].image)) : e.push(m(i[t]))
                        } else e = m(i);
                        t.images[i.uuid] = {
                            uuid: i.uuid,
                            url: e
                        }
                    }
                    n.image = i.uuid
                }
                return e || (t.textures[this.uuid] = n), n
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function (t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case 1e3:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case 1001:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case 1002:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case 1e3:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case 1001:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case 1002:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
        }), Object.defineProperty(f.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        });
        class g {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                Object.defineProperty(this, "isVector4", {
                    value: !0
                }), this.x = t, this.y = e, this.z = n, this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t, this.y = e, this.z = n, this.w = i, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setW(t) {
                return this.w = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }
            add(t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }
            sub(t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    s = t.elements;
                return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const s = t.elements,
                    o = s[0],
                    a = s[4],
                    c = s[8],
                    l = s[1],
                    h = s[5],
                    u = s[9],
                    p = s[2],
                    d = s[6],
                    f = s[10];
                if (Math.abs(a - l) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) {
                    if (Math.abs(a + l) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 && Math.abs(o + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (o + 1) / 2,
                        s = (h + 1) / 2,
                        m = (f + 1) / 2,
                        g = (a + l) / 4,
                        v = (c + p) / 4,
                        y = (u + d) / 4;
                    return t > s && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = g / n, r = v / n) : s > m ? s < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(s), n = g / i, r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(m), n = v / r, i = y / r), this.set(n, i, r, e), this
                }
                let m = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (l - a) * (l - a));
                return Math.abs(m) < .001 && (m = 1), this.x = (d - u) / m, this.y = (c - p) / m, this.z = (l - a) / m, this.w = Math.acos((o + h + f - 1) / 2), this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }
            fromBufferAttribute(t, e, n) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }
        }

        function v(t, e, n) {
            this.width = t, this.height = e, this.scissor = new g(0, 0, t, e), this.scissorTest = !1, this.viewport = new g(0, 0, t, e), n = n || {}, this.texture = new f(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : i, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }

        function y(t, e, n) {
            v.call(this, t, e, n), this.samples = 4
        }
        v.prototype = Object.assign(Object.create(s.prototype), {
            constructor: v,
            isWebGLRenderTarget: !0,
            setSize: function (t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), y.prototype = Object.assign(Object.create(v.prototype), {
            constructor: y,
            isWebGLMultisampleRenderTarget: !0,
            copy: function (t) {
                return v.prototype.copy.call(this, t), this.samples = t.samples, this
            }
        });
        class _ {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                Object.defineProperty(this, "isQuaternion", {
                    value: !0
                }), this._x = t, this._y = e, this._z = n, this._w = i
            }
            static slerp(t, e, n, i) {
                return n.copy(t).slerp(e, i)
            }
            static slerpFlat(t, e, n, i, r, s, o) {
                let a = n[i + 0],
                    c = n[i + 1],
                    l = n[i + 2],
                    h = n[i + 3];
                const u = r[s + 0],
                    p = r[s + 1],
                    d = r[s + 2],
                    f = r[s + 3];
                if (h !== f || a !== u || c !== p || l !== d) {
                    let t = 1 - o;
                    const e = a * u + c * p + l * d + h * f,
                        n = e >= 0 ? 1 : -1,
                        i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i),
                            s = Math.atan2(r, e * n);
                        t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                    }
                    const r = o * n;
                    if (a = a * t + u * r, c = c * t + p * r, l = l * t + d * r, h = h * t + f * r, t === 1 - o) {
                        const t = 1 / Math.sqrt(a * a + c * c + l * l + h * h);
                        a *= t, c *= t, l *= t, h *= t
                    }
                }
                t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                const o = n[i],
                    a = n[i + 1],
                    c = n[i + 2],
                    l = n[i + 3],
                    h = r[s],
                    u = r[s + 1],
                    p = r[s + 2],
                    d = r[s + 3];
                return t[e] = o * d + l * h + a * p - c * u, t[e + 1] = a * d + l * u + c * h - o * p, t[e + 2] = c * d + l * p + o * u - a * h, t[e + 3] = l * d - o * h - a * u - c * p, t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t, this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    s = t._order,
                    o = Math.cos,
                    a = Math.sin,
                    c = o(n / 2),
                    l = o(i / 2),
                    h = o(r / 2),
                    u = a(n / 2),
                    p = a(i / 2),
                    d = a(r / 2);
                switch (s) {
                    case "XYZ":
                        this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d;
                        break;
                    case "YXZ":
                        this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d;
                        break;
                    case "ZXY":
                        this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d;
                        break;
                    case "ZYX":
                        this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d;
                        break;
                    case "YZX":
                        this._x = u * l * h + c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h - u * p * d;
                        break;
                    case "XZY":
                        this._x = u * l * h - c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h + u * p * d
                }
                return !1 !== e && this._onChangeCallback(), this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2,
                    i = Math.sin(n);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(t) {
                const e = t.elements,
                    n = e[0],
                    i = e[4],
                    r = e[8],
                    s = e[1],
                    o = e[5],
                    a = e[9],
                    c = e[2],
                    l = e[6],
                    h = e[10],
                    u = n + o + h;
                if (u > 0) {
                    const t = .5 / Math.sqrt(u + 1);
                    this._w = .25 / t, this._x = (l - a) * t, this._y = (r - c) * t, this._z = (s - i) * t
                } else if (n > o && n > h) {
                    const t = 2 * Math.sqrt(1 + n - o - h);
                    this._w = (l - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + c) / t
                } else if (o > h) {
                    const t = 2 * Math.sqrt(1 + o - n - h);
                    this._w = (r - c) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + l) / t
                } else {
                    const t = 2 * Math.sqrt(1 + h - n - o);
                    this._w = (s - i) / t, this._x = (r + c) / t, this._y = (a + l) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(c.clamp(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n) return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }
            multiply(t, e) {
                return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    s = t._w,
                    o = e._x,
                    a = e._y,
                    c = e._z,
                    l = e._w;
                return this._x = n * l + s * o + i * c - r * a, this._y = i * l + s * a + r * o - n * c, this._z = r * l + s * c + n * a - i * o, this._w = s * l - n * o - i * a - r * c, this._onChangeCallback(), this
            }
            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x,
                    i = this._y,
                    r = this._z,
                    s = this._w;
                let o = s * t._w + n * t._x + i * t._y + r * t._z;
                if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                const a = 1 - o * o;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const c = Math.sqrt(a),
                    l = Math.atan2(c, o),
                    h = Math.sin((1 - e) * l) / c,
                    u = Math.sin(e * l) / c;
                return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}
        }
        class x {
            constructor(t = 0, e = 0, n = 0) {
                Object.defineProperty(this, "isVector3", {
                    value: !0
                }), this.x = t, this.y = e, this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }
            add(t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }
            sub(t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }
            multiply(t, e) {
                return void 0 !== e ? this.multiplyVectors(t, e) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }
            applyEuler(t) {
                return !t || t.isEuler, this.applyQuaternion(M.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(M.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements,
                    s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
            }
            applyQuaternion(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.x,
                    s = t.y,
                    o = t.z,
                    a = t.w,
                    c = a * e + s * i - o * n,
                    l = a * n + o * e - r * i,
                    h = a * i + r * n - s * e,
                    u = -r * e - s * n - o * i;
                return this.x = c * a + u * -r + l * -o - h * -s, this.y = l * a + u * -s + h * -r - c * -o, this.z = h * a + u * -o + c * -s - l * -r, this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }
            cross(t, e) {
                return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x,
                    i = t.y,
                    r = t.z,
                    s = e.x,
                    o = e.y,
                    a = e.z;
                return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return b.copy(this).projectOnVector(t), this.sub(b)
            }
            reflect(t) {
                return this.sub(b.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(c.clamp(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y,
                    i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = i, this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }
            fromBufferAttribute(t, e, n) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
        }
        const b = new x,
            M = new _;
        class w {
            constructor(t, e) {
                Object.defineProperty(this, "isBox3", {
                    value: !0
                }), this.min = void 0 !== t ? t : new x(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new x(-1 / 0, -1 / 0, -1 / 0)
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromArray(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    o = -1 / 0;
                for (let a = 0, c = t.length; a < c; a += 3) {
                    const c = t[a],
                        l = t[a + 1],
                        h = t[a + 2];
                    c < e && (e = c), l < n && (n = l), h < i && (i = h), c > r && (r = c), l > s && (s = l), h > o && (o = h)
                }
                return this.min.set(e, n, i), this.max.set(r, s, o), this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    o = -1 / 0;
                for (let a = 0, c = t.count; a < c; a++) {
                    const c = t.getX(a),
                        l = t.getY(a),
                        h = t.getZ(a);
                    c < e && (e = c), l < n && (n = l), h < i && (i = h), c > r && (r = c), l > s && (s = l), h > o && (o = h)
                }
                return this.min.set(e, n, i), this.max.set(r, s, o), this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = A.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            setFromObject(t) {
                return this.makeEmpty(), this.expandByObject(t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return void 0 === t && (t = new x), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (t = new x), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            expandByObject(t) {
                t.updateWorldMatrix(!1, !1);
                const e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), L.copy(e.boundingBox), L.applyMatrix4(t.matrixWorld), this.union(L));
                const n = t.children;
                for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return void 0 === e && (e = new x), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, A), A.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(I), z.subVectors(this.max, I), C.subVectors(t.a, I), P.subVectors(t.b, I), E.subVectors(t.c, I), N.subVectors(P, C), O.subVectors(E, P), D.subVectors(C, E);
                let e = [0, -N.z, N.y, 0, -O.z, O.y, 0, -D.z, D.y, N.z, 0, -N.x, O.z, 0, -O.x, D.z, 0, -D.x, -N.y, N.x, 0, -O.y, O.x, 0, -D.y, D.x, 0];
                return !!S(e, C, P, E, z) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!S(e, C, P, E, z) && (R.crossVectors(N, O), e = [R.x, R.y, R.z], S(e, C, P, E, z)))
            }
            clampPoint(t, e) {
                return void 0 === e && (e = new x), e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return A.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return this.getCenter(t.center), t.radius = .5 * this.getSize(A).length(), t
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (T[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), T[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), T[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), T[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), T[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), T[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), T[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), T[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(T)), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }

        function S(t, e, n, i, r) {
            for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                F.fromArray(t, s);
                const o = r.x * Math.abs(F.x) + r.y * Math.abs(F.y) + r.z * Math.abs(F.z),
                    a = e.dot(F),
                    c = n.dot(F),
                    l = i.dot(F);
                if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > o) return !1
            }
            return !0
        }
        const T = [new x, new x, new x, new x, new x, new x, new x, new x],
            A = new x,
            L = new w,
            C = new x,
            P = new x,
            E = new x,
            N = new x,
            O = new x,
            D = new x,
            I = new x,
            z = new x,
            R = new x,
            F = new x,
            U = new w;
        class B {
            constructor(t, e) {
                this.center = void 0 !== t ? t : new x, this.radius = void 0 !== e ? e : -1
            }
            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : U.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return void 0 === e && (e = new x), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }
            getBoundingBox(t) {
                return void 0 === t && (t = new w), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }
            translate(t) {
                return this.center.add(t), this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        }
        const k = new x,
            V = new x,
            j = new x,
            G = new x,
            W = new x,
            H = new x,
            q = new x;
        class X {
            constructor(t, e) {
                this.origin = void 0 !== t ? t : new x, this.direction = void 0 !== e ? e : new x(0, 0, -1)
            }
            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }
            at(t, e) {
                return void 0 === e && (e = new x), e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }
            recast(t) {
                return this.origin.copy(this.at(t, k)), this
            }
            closestPointToPoint(t, e) {
                void 0 === e && (e = new x), e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = k.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (k.copy(this.direction).multiplyScalar(e).add(this.origin), k.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                V.copy(t).add(e).multiplyScalar(.5), j.copy(e).sub(t).normalize(), G.copy(this.origin).sub(V);
                const r = .5 * t.distanceTo(e),
                    s = -this.direction.dot(j),
                    o = G.dot(this.direction),
                    a = -G.dot(j),
                    c = G.lengthSq(),
                    l = Math.abs(1 - s * s);
                let h, u, p, d;
                if (l > 0)
                    if (h = s * a - o, u = s * o - a, d = r * l, h >= 0)
                        if (u >= -d)
                            if (u <= d) {
                                const t = 1 / l;
                                h *= t, u *= t, p = h * (h + s * u + 2 * o) + u * (s * h + u + 2 * a) + c
                            } else u = r, h = Math.max(0, -(s * u + o)), p = -h * h + u * (u + 2 * a) + c;
                else u = -r, h = Math.max(0, -(s * u + o)), p = -h * h + u * (u + 2 * a) + c;
                else u <= -d ? (h = Math.max(0, -(-s * r + o)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), p = -h * h + u * (u + 2 * a) + c) : u <= d ? (h = 0, u = Math.min(Math.max(-r, -a), r), p = u * (u + 2 * a) + c) : (h = Math.max(0, -(s * r + o)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), p = -h * h + u * (u + 2 * a) + c);
                else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + o)), p = -h * h + u * (u + 2 * a) + c;
                return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(j).multiplyScalar(u).add(V), p
            }
            intersectSphere(t, e) {
                k.subVectors(t.center, this.origin);
                const n = k.dot(this.direction),
                    i = k.dot(k) - n * n,
                    r = t.radius * t.radius;
                if (i > r) return null;
                const s = Math.sqrt(r - i),
                    o = n - s,
                    a = n + s;
                return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e) return !0;
                return t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, s, o, a;
                const c = 1 / this.direction.x,
                    l = 1 / this.direction.y,
                    h = 1 / this.direction.z,
                    u = this.origin;
                return c >= 0 ? (n = (t.min.x - u.x) * c, i = (t.max.x - u.x) * c) : (n = (t.max.x - u.x) * c, i = (t.min.x - u.x) * c), l >= 0 ? (r = (t.min.y - u.y) * l, s = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, s = (t.min.y - u.y) * l), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (o = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, k)
            }
            intersectTriangle(t, e, n, i, r) {
                W.subVectors(e, t), H.subVectors(n, t), q.crossVectors(W, H);
                let s, o = this.direction.dot(q);
                if (o > 0) {
                    if (i) return null;
                    s = 1
                } else {
                    if (!(o < 0)) return null;
                    s = -1, o = -o
                }
                G.subVectors(this.origin, t);
                const a = s * this.direction.dot(H.crossVectors(G, H));
                if (a < 0) return null;
                const c = s * this.direction.dot(W.cross(G));
                if (c < 0) return null;
                if (a + c > o) return null;
                const l = -s * G.dot(q);
                return l < 0 ? null : this.at(l / o, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        }
        class Y {
            constructor() {
                Object.defineProperty(this, "isMatrix4", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
            }
            set(t, e, n, i, r, s, o, a, c, l, h, u, p, d, f, m) {
                const g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = c, g[6] = l, g[10] = h, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new Y).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }
            copyPosition(t) {
                const e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(t) {
                const e = this.elements,
                    n = t.elements,
                    i = 1 / Z.setFromMatrixColumn(t, 0).length(),
                    r = 1 / Z.setFromMatrixColumn(t, 1).length(),
                    s = 1 / Z.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromEuler(t) {
                !t || t.isEuler;
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z,
                    s = Math.cos(n),
                    o = Math.sin(n),
                    a = Math.cos(i),
                    c = Math.sin(i),
                    l = Math.cos(r),
                    h = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = s * l,
                        n = s * h,
                        i = o * l,
                        r = o * h;
                    e[0] = a * l, e[4] = -a * h, e[8] = c, e[1] = n + i * c, e[5] = t - r * c, e[9] = -o * a, e[2] = r - t * c, e[6] = i + n * c, e[10] = s * a
                } else if ("YXZ" === t.order) {
                    const t = a * l,
                        n = a * h,
                        i = c * l,
                        r = c * h;
                    e[0] = t + r * o, e[4] = i * o - n, e[8] = s * c, e[1] = s * h, e[5] = s * l, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                } else if ("ZXY" === t.order) {
                    const t = a * l,
                        n = a * h,
                        i = c * l,
                        r = c * h;
                    e[0] = t - r * o, e[4] = -s * h, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * l, e[9] = r - t * o, e[2] = -s * c, e[6] = o, e[10] = s * a
                } else if ("ZYX" === t.order) {
                    const t = s * l,
                        n = s * h,
                        i = o * l,
                        r = o * h;
                    e[0] = a * l, e[4] = i * c - n, e[8] = t * c + r, e[1] = a * h, e[5] = r * c + t, e[9] = n * c - i, e[2] = -c, e[6] = o * a, e[10] = s * a
                } else if ("YZX" === t.order) {
                    const t = s * a,
                        n = s * c,
                        i = o * a,
                        r = o * c;
                    e[0] = a * l, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = s * l, e[9] = -o * l, e[2] = -c * l, e[6] = n * h + i, e[10] = t - r * h
                } else if ("XZY" === t.order) {
                    const t = s * a,
                        n = s * c,
                        i = o * a,
                        r = o * c;
                    e[0] = a * l, e[4] = -h, e[8] = c * l, e[1] = t * h + r, e[5] = s * l, e[9] = n * h - i, e[2] = i * h - n, e[6] = o * l, e[10] = r * h + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Q, t, K)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return et.subVectors(t, e), 0 === et.lengthSq() && (et.z = 1), et.normalize(), $.crossVectors(n, et), 0 === $.lengthSq() && (1 === Math.abs(n.z) ? et.x += 1e-4 : et.z += 1e-4, et.normalize(), $.crossVectors(n, et)), $.normalize(), tt.crossVectors(et, $), i[0] = $.x, i[4] = tt.x, i[8] = et.x, i[1] = $.y, i[5] = tt.y, i[9] = et.y, i[2] = $.z, i[6] = tt.z, i[10] = et.z, this
            }
            multiply(t, e) {
                return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[4],
                    a = n[8],
                    c = n[12],
                    l = n[1],
                    h = n[5],
                    u = n[9],
                    p = n[13],
                    d = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    y = n[7],
                    _ = n[11],
                    x = n[15],
                    b = i[0],
                    M = i[4],
                    w = i[8],
                    S = i[12],
                    T = i[1],
                    A = i[5],
                    L = i[9],
                    C = i[13],
                    P = i[2],
                    E = i[6],
                    N = i[10],
                    O = i[14],
                    D = i[3],
                    I = i[7],
                    z = i[11],
                    R = i[15];
                return r[0] = s * b + o * T + a * P + c * D, r[4] = s * M + o * A + a * E + c * I, r[8] = s * w + o * L + a * N + c * z, r[12] = s * S + o * C + a * O + c * R, r[1] = l * b + h * T + u * P + p * D, r[5] = l * M + h * A + u * E + p * I, r[9] = l * w + h * L + u * N + p * z, r[13] = l * S + h * C + u * O + p * R, r[2] = d * b + f * T + m * P + g * D, r[6] = d * M + f * A + m * E + g * I, r[10] = d * w + f * L + m * N + g * z, r[14] = d * S + f * C + m * O + g * R, r[3] = v * b + y * T + _ * P + x * D, r[7] = v * M + y * A + _ * E + x * I, r[11] = v * w + y * L + _ * N + x * z, r[15] = v * S + y * C + _ * O + x * R, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[4],
                    i = t[8],
                    r = t[12],
                    s = t[1],
                    o = t[5],
                    a = t[9],
                    c = t[13],
                    l = t[2],
                    h = t[6],
                    u = t[10],
                    p = t[14];
                return t[3] * (+r * a * h - i * c * h - r * o * u + n * c * u + i * o * p - n * a * p) + t[7] * (+e * a * p - e * c * u + r * s * u - i * s * p + i * c * l - r * a * l) + t[11] * (+e * c * h - e * o * p - r * s * h + n * s * p + r * o * l - n * c * l) + t[15] * (-i * o * l - e * a * h + e * o * u + i * s * h - n * s * u + n * a * l)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    c = t[7],
                    l = t[8],
                    h = t[9],
                    u = t[10],
                    p = t[11],
                    d = t[12],
                    f = t[13],
                    m = t[14],
                    g = t[15],
                    v = h * m * c - f * u * c + f * a * p - o * m * p - h * a * g + o * u * g,
                    y = d * u * c - l * m * c - d * a * p + s * m * p + l * a * g - s * u * g,
                    _ = l * f * c - d * h * c + d * o * p - s * f * p - l * o * g + s * h * g,
                    x = d * h * a - l * f * a - d * o * u + s * f * u + l * o * m - s * h * m,
                    b = e * v + n * y + i * _ + r * x;
                if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const M = 1 / b;
                return t[0] = v * M, t[1] = (f * u * r - h * m * r - f * i * p + n * m * p + h * i * g - n * u * g) * M, t[2] = (o * m * r - f * a * r + f * i * c - n * m * c - o * i * g + n * a * g) * M, t[3] = (h * a * r - o * u * r - h * i * c + n * u * c + o * i * p - n * a * p) * M, t[4] = y * M, t[5] = (l * m * r - d * u * r + d * i * p - e * m * p - l * i * g + e * u * g) * M, t[6] = (d * a * r - s * m * r - d * i * c + e * m * c + s * i * g - e * a * g) * M, t[7] = (s * u * r - l * a * r + l * i * c - e * u * c - s * i * p + e * a * p) * M, t[8] = _ * M, t[9] = (d * h * r - l * f * r - d * n * p + e * f * p + l * n * g - e * h * g) * M, t[10] = (s * f * r - d * o * r + d * n * c - e * f * c - s * n * g + e * o * g) * M, t[11] = (l * o * r - s * h * r - l * n * c + e * h * c + s * n * p - e * o * p) * M, t[12] = x * M, t[13] = (l * f * i - d * h * i + d * n * u - e * f * u - l * n * m + e * h * m) * M, t[14] = (d * o * i - s * f * i - d * n * a + e * f * a + s * n * m - e * o * m) * M, t[15] = (s * h * i - l * o * i + l * n * a - e * h * a - s * n * u + e * o * u) * M, this
            }
            scale(t) {
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z;
                return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
            }
            getMaxScaleOnAxis() {
                const t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            }
            makeRotationY(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = 1 - n,
                    s = t.x,
                    o = t.y,
                    a = t.z,
                    c = r * s,
                    l = r * o;
                return this.set(c * s + n, c * o - i * a, c * a + i * o, 0, c * o + i * a, l * o + n, l * a - i * s, 0, c * a - i * o, l * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(t, e, n) {
                return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
            }
            compose(t, e, n) {
                const i = this.elements,
                    r = e._x,
                    s = e._y,
                    o = e._z,
                    a = e._w,
                    c = r + r,
                    l = s + s,
                    h = o + o,
                    u = r * c,
                    p = r * l,
                    d = r * h,
                    f = s * l,
                    m = s * h,
                    g = o * h,
                    v = a * c,
                    y = a * l,
                    _ = a * h,
                    x = n.x,
                    b = n.y,
                    M = n.z;
                return i[0] = (1 - (f + g)) * x, i[1] = (p + _) * x, i[2] = (d - y) * x, i[3] = 0, i[4] = (p - _) * b, i[5] = (1 - (u + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (d + y) * M, i[9] = (m - v) * M, i[10] = (1 - (u + f)) * M, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = Z.set(i[0], i[1], i[2]).length();
                const s = Z.set(i[4], i[5], i[6]).length(),
                    o = Z.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], J.copy(this);
                const a = 1 / r,
                    c = 1 / s,
                    l = 1 / o;
                return J.elements[0] *= a, J.elements[1] *= a, J.elements[2] *= a, J.elements[4] *= c, J.elements[5] *= c, J.elements[6] *= c, J.elements[8] *= l, J.elements[9] *= l, J.elements[10] *= l, e.setFromRotationMatrix(J), n.x = r, n.y = s, n.z = o, this
            }
            makePerspective(t, e, n, i, r, s) {
                const o = this.elements,
                    a = 2 * r / (e - t),
                    c = 2 * r / (n - i),
                    l = (e + t) / (e - t),
                    h = (n + i) / (n - i),
                    u = -(s + r) / (s - r),
                    p = -2 * s * r / (s - r);
                return o[0] = a, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = c, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
            }
            makeOrthographic(t, e, n, i, r, s) {
                const o = this.elements,
                    a = 1 / (e - t),
                    c = 1 / (n - i),
                    l = 1 / (s - r),
                    h = (e + t) * a,
                    u = (n + i) * c,
                    p = (s + r) * l;
                return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }
        const Z = new x,
            J = new Y,
            Q = new x(0, 0, 0),
            K = new x(1, 1, 1),
            $ = new x,
            tt = new x,
            et = new x;
        class nt {
            constructor(t = 0, e = 0, n = 0, i = nt.DefaultOrder) {
                Object.defineProperty(this, "isEuler", {
                    value: !0
                }), this._x = t, this._y = e, this._z = n, this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t, this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(t, e, n) {
                const i = c.clamp,
                    r = t.elements,
                    s = r[0],
                    o = r[4],
                    a = r[8],
                    l = r[1],
                    h = r[5],
                    u = r[9],
                    p = r[2],
                    d = r[6],
                    f = r[10];
                switch (e = e || this._order) {
                    case "XYZ":
                        this._y = Math.asin(i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, h), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-p, s), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-p, f), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math.atan2(l, s));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-i(p, -1, 1)), Math.abs(p) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, h));
                        break;
                    case "YZX":
                        this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-p, s)) : (this._x = 0, this._y = Math.atan2(a, f));
                        break;
                    case "XZY":
                        this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, h), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, f), this._y = 0)
                }
                return this._order = e, !1 !== n && this._onChangeCallback(), this
            }
            setFromQuaternion(t, e, n) {
                return it.makeRotationFromQuaternion(t), this.setFromRotationMatrix(it, e, n)
            }
            setFromVector3(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            }
            reorder(t) {
                return rt.setFromEuler(this), this.setFromQuaternion(rt, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }
            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new x(this._x, this._y, this._z)
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}
        }
        nt.DefaultOrder = "XYZ", nt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        const it = new Y,
            rt = new _;
        class st {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t | 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
        }
        let ot = 0;
        const at = new x,
            ct = new _,
            lt = new Y,
            ht = new x,
            ut = new x,
            pt = new x,
            dt = new _,
            ft = new x(1, 0, 0),
            mt = new x(0, 1, 0),
            gt = new x(0, 0, 1),
            vt = {
                type: "added"
            },
            yt = {
                type: "removed"
            };

        function _t() {
            Object.defineProperty(this, "id", {
                value: ot++
            }), this.uuid = c.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _t.DefaultUp.clone();
            const t = new x,
                e = new nt,
                n = new _,
                i = new x(1, 1, 1);
            e._onChange((function () {
                n.setFromEuler(e, !1)
            })), n._onChange((function () {
                e.setFromQuaternion(n, void 0, !1)
            })), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new Y
                },
                normalMatrix: {
                    value: new h
                }
            }), this.matrix = new Y, this.matrixWorld = new Y, this.matrixAutoUpdate = _t.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new st, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
        }
        _t.DefaultUp = new x(0, 1, 0), _t.DefaultMatrixAutoUpdate = !0, _t.prototype = Object.assign(Object.create(s.prototype), {
            constructor: _t,
            isObject3D: !0,
            onBeforeRender: function () {},
            onAfterRender: function () {},
            applyMatrix4: function (t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function (t) {
                return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function (t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function (t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function (t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function (t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function (t, e) {
                return ct.setFromAxisAngle(t, e), this.quaternion.multiply(ct), this
            },
            rotateOnWorldAxis: function (t, e) {
                return ct.setFromAxisAngle(t, e), this.quaternion.premultiply(ct), this
            },
            rotateX: function (t) {
                return this.rotateOnAxis(ft, t)
            },
            rotateY: function (t) {
                return this.rotateOnAxis(mt, t)
            },
            rotateZ: function (t) {
                return this.rotateOnAxis(gt, t)
            },
            translateOnAxis: function (t, e) {
                return at.copy(t).applyQuaternion(this.quaternion), this.position.add(at.multiplyScalar(e)), this
            },
            translateX: function (t) {
                return this.translateOnAxis(ft, t)
            },
            translateY: function (t) {
                return this.translateOnAxis(mt, t)
            },
            translateZ: function (t) {
                return this.translateOnAxis(gt, t)
            },
            localToWorld: function (t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function (t) {
                return t.applyMatrix4(lt.copy(this.matrixWorld).invert())
            },
            lookAt: function (t, e, n) {
                t.isVector3 ? ht.copy(t) : ht.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), ut.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? lt.lookAt(ut, ht, this.up) : lt.lookAt(ht, ut, this.up), this.quaternion.setFromRotationMatrix(lt), i && (lt.extractRotation(i.matrixWorld), ct.setFromRotationMatrix(lt), this.quaternion.premultiply(ct.invert()))
            },
            add: function (t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return t === this || t && t.isObject3D && (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(vt)), this
            },
            remove: function (t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(yt)), this
            },
            clear: function () {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null, e.dispatchEvent(yt)
                }
                return this.children.length = 0, this
            },
            attach: function (t) {
                return this.updateWorldMatrix(!0, !1), lt.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), lt.multiply(t.parent.matrixWorld)), t.applyMatrix4(lt), t.updateWorldMatrix(!1, !1), this.add(t), this
            },
            getObjectById: function (t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function (t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function (t, e) {
                if (this[t] === e) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i) return i
                }
            },
            getWorldPosition: function (t) {
                return void 0 === t && (t = new x), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function (t) {
                return void 0 === t && (t = new _), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ut, t, pt), t
            },
            getWorldScale: function (t) {
                return void 0 === t && (t = new x), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ut, dt, t), t
            },
            getWorldDirection: function (t) {
                void 0 === t && (t = new x), this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            },
            raycast: function () {},
            traverse: function (t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
            },
            traverseVisible: function (t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            },
            traverseAncestors: function (t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function (t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
            },
            updateWorldMatrix: function (t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                }
            },
            toJSON: function (t) {
                const e = void 0 === t || "string" == typeof t,
                    n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};

                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            } else r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = s(t.geometries),
                        i = s(t.materials),
                        r = s(t.textures),
                        o = s(t.images),
                        a = s(t.shapes),
                        c = s(t.skeletons),
                        l = s(t.animations);
                    e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), c.length > 0 && (n.skeletons = c), l.length > 0 && (n.animations = l)
                }
                return n.object = i, n;

                function s(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
            },
            clone: function (t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function (t, e = !0) {
                if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        });
        const xt = new x,
            bt = new x,
            Mt = new h;
        class wt {
            constructor(t, e) {
                Object.defineProperty(this, "isPlane", {
                    value: !0
                }), this.normal = void 0 !== t ? t : new x(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }
            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n), this.constant = i, this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = xt.subVectors(n, e).cross(bt.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return void 0 === e && (e = new x), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                void 0 === e && (e = new x);
                const n = t.delta(xt),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return void 0 === t && (t = new x), t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || Mt.getNormalMatrix(t),
                    i = this.coplanarPoint(xt).applyMatrix4(t),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        }
        const St = new x,
            Tt = new x,
            At = new x,
            Lt = new x,
            Ct = new x,
            Pt = new x,
            Et = new x,
            Nt = new x,
            Ot = new x,
            Dt = new x;
        class It {
            constructor(t, e, n) {
                this.a = void 0 !== t ? t : new x, this.b = void 0 !== e ? e : new x, this.c = void 0 !== n ? n : new x
            }
            static getNormal(t, e, n, i) {
                void 0 === i && (i = new x), i.subVectors(n, e), St.subVectors(t, e), i.cross(St);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                St.subVectors(i, e), Tt.subVectors(n, e), At.subVectors(t, e);
                const s = St.dot(St),
                    o = St.dot(Tt),
                    a = St.dot(At),
                    c = Tt.dot(Tt),
                    l = Tt.dot(At),
                    h = s * c - o * o;
                if (void 0 === r && (r = new x), 0 === h) return r.set(-2, -1, -1);
                const u = 1 / h,
                    p = (c * a - o * l) * u,
                    d = (s * l - o * a) * u;
                return r.set(1 - p - d, d, p)
            }
            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, Lt), Lt.x >= 0 && Lt.y >= 0 && Lt.x + Lt.y <= 1
            }
            static getUV(t, e, n, i, r, s, o, a) {
                return this.getBarycoord(t, e, n, i, Lt), a.set(0, 0), a.addScaledVector(r, Lt.x), a.addScaledVector(s, Lt.y), a.addScaledVector(o, Lt.z), a
            }
            static isFrontFacing(t, e, n, i) {
                return St.subVectors(n, e), Tt.subVectors(t, e), St.cross(Tt).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }
            getArea() {
                return St.subVectors(this.c, this.b), Tt.subVectors(this.a, this.b), .5 * St.cross(Tt).length()
            }
            getMidpoint(t) {
                return void 0 === t && (t = new x), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return It.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return void 0 === t && (t = new wt), t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return It.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return It.getUV(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return It.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return It.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                void 0 === e && (e = new x);
                const n = this.a,
                    i = this.b,
                    r = this.c;
                let s, o;
                Ct.subVectors(i, n), Pt.subVectors(r, n), Nt.subVectors(t, n);
                const a = Ct.dot(Nt),
                    c = Pt.dot(Nt);
                if (a <= 0 && c <= 0) return e.copy(n);
                Ot.subVectors(t, i);
                const l = Ct.dot(Ot),
                    h = Pt.dot(Ot);
                if (l >= 0 && h <= l) return e.copy(i);
                const u = a * h - l * c;
                if (u <= 0 && a >= 0 && l <= 0) return s = a / (a - l), e.copy(n).addScaledVector(Ct, s);
                Dt.subVectors(t, r);
                const p = Ct.dot(Dt),
                    d = Pt.dot(Dt);
                if (d >= 0 && p <= d) return e.copy(r);
                const f = p * c - a * d;
                if (f <= 0 && c >= 0 && d <= 0) return o = c / (c - d), e.copy(n).addScaledVector(Pt, o);
                const m = l * d - p * h;
                if (m <= 0 && h - l >= 0 && p - d >= 0) return Et.subVectors(r, i), o = (h - l) / (h - l + (p - d)), e.copy(i).addScaledVector(Et, o);
                const g = 1 / (m + f + u);
                return s = f * g, o = u * g, e.copy(n).addScaledVector(Ct, s).addScaledVector(Pt, o)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        const zt = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            Rt = {
                h: 0,
                s: 0,
                l: 0
            },
            Ft = {
                h: 0,
                s: 0,
                l: 0
            };

        function Ut(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }

        function Bt(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function kt(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        class Vt {
            constructor(t, e, n) {
                return Object.defineProperty(this, "isColor", {
                    value: !0
                }), void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }
            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }
            setHex(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            }
            setRGB(t, e, n) {
                return this.r = t, this.g = e, this.b = n, this
            }
            setHSL(t, e, n) {
                if (t = c.euclideanModulo(t, 1), e = c.clamp(e, 0, 1), n = c.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                        r = 2 * n - i;
                    this.r = Ut(r, i, t + 1 / 3), this.g = Ut(r, i, t), this.b = Ut(r, i, t - 1 / 3)
                }
                return this
            }
            setStyle(t) {
                function e(t) {
                    void 0 !== t && parseFloat(t)
                }
                let n;
                if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    let t;
                    const i = n[1],
                        r = n[2];
                    switch (i) {
                        case "rgb":
                        case "rgba":
                            if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this;
                            if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
                                const n = parseFloat(t[1]) / 360,
                                    i = parseInt(t[2], 10) / 100,
                                    r = parseInt(t[3], 10) / 100;
                                return e(t[5]), this.setHSL(n, i, r)
                            }
                    }
                } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    const t = n[1],
                        e = t.length;
                    if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                    if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            }
            setColorName(t) {
                const e = zt[t];
                return void 0 !== e && this.setHex(e), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }
            copyGammaToLinear(t, e = 2) {
                return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            }
            copyLinearToGamma(t, e = 2) {
                const n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
            }
            convertGammaToLinear(t) {
                return this.copyGammaToLinear(this, t), this
            }
            convertLinearToGamma(t) {
                return this.copyLinearToGamma(this, t), this
            }
            copySRGBToLinear(t) {
                return this.r = Bt(t.r), this.g = Bt(t.g), this.b = Bt(t.b), this
            }
            copyLinearToSRGB(t) {
                return this.r = kt(t.r), this.g = kt(t.g), this.b = kt(t.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(t) {
                void 0 === t && (t = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                const e = this.r,
                    n = this.g,
                    i = this.b,
                    r = Math.max(e, n, i),
                    s = Math.min(e, n, i);
                let o, a;
                const c = (s + r) / 2;
                if (s === r) o = 0, a = 0;
                else {
                    const t = r - s;
                    switch (a = c <= .5 ? t / (r + s) : t / (2 - r - s), r) {
                        case e:
                            o = (n - i) / t + (n < i ? 6 : 0);
                            break;
                        case n:
                            o = (i - e) / t + 2;
                            break;
                        case i:
                            o = (e - n) / t + 4
                    }
                    o /= 6
                }
                return t.h = o, t.s = a, t.l = c, t
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(t, e, n) {
                return this.getHSL(Rt), Rt.h += t, Rt.s += e, Rt.l += n, this.setHSL(Rt.h, Rt.s, Rt.l), this
            }
            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }
            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }
            addScalar(t) {
                return this.r += t, this.g += t, this.b += t, this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }
            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }
            multiplyScalar(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }
            lerpHSL(t, e) {
                this.getHSL(Rt), t.getHSL(Ft);
                const n = c.lerp(Rt.h, Ft.h, e),
                    i = c.lerp(Rt.s, Ft.s, e),
                    r = c.lerp(Rt.l, Ft.l, e);
                return this.setHSL(n, i, r), this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }
            toJSON() {
                return this.getHex()
            }
        }
        Vt.NAMES = zt, Vt.prototype.r = 1, Vt.prototype.g = 1, Vt.prototype.b = 1;
        class jt {
            constructor(t, e, n, i, r, s = 0) {
                this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new x, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Vt, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = s
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        }
        let Gt = 0;

        function Wt() {
            Object.defineProperty(this, "id", {
                value: Gt++
            }), this.uuid = c.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
        }

        function Ht(t) {
            Wt.call(this), this.type = "MeshBasicMaterial", this.color = new Vt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
        }
        Wt.prototype = Object.assign(Object.create(s.prototype), {
            constructor: Wt,
            isMaterial: !0,
            onBeforeCompile: function () {},
            customProgramCacheKey: function () {
                return this.onBeforeCompile.toString()
            },
            setValues: function (t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) continue;
                        if ("shading" === e) {
                            this.flatShading = 1 === n;
                            continue
                        }
                        const i = this[e];
                        void 0 !== i && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n)
                    }
            },
            toJSON: function (t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                    const e = i(t.textures),
                        r = i(t.images);
                    e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                }
                return n
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty(Wt.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), Ht.prototype = Object.create(Wt.prototype), Ht.prototype.constructor = Ht, Ht.prototype.isMeshBasicMaterial = !0, Ht.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        };
        const qt = new x,
            Xt = new l;

        function Yt(t, e, n) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Zt(t, e, n) {
            Yt.call(this, new Int8Array(t), e, n)
        }

        function Jt(t, e, n) {
            Yt.call(this, new Uint8Array(t), e, n)
        }

        function Qt(t, e, n) {
            Yt.call(this, new Uint8ClampedArray(t), e, n)
        }

        function Kt(t, e, n) {
            Yt.call(this, new Int16Array(t), e, n)
        }

        function $t(t, e, n) {
            Yt.call(this, new Uint16Array(t), e, n)
        }

        function te(t, e, n) {
            Yt.call(this, new Int32Array(t), e, n)
        }

        function ee(t, e, n) {
            Yt.call(this, new Uint32Array(t), e, n)
        }

        function ne(t, e, n) {
            Yt.call(this, new Uint16Array(t), e, n)
        }

        function ie(t, e, n) {
            Yt.call(this, new Float32Array(t), e, n)
        }

        function re(t, e, n) {
            Yt.call(this, new Float64Array(t), e, n)
        }
        Object.defineProperty(Yt.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), Object.assign(Yt.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function () {},
            setUsage: function (t) {
                return this.usage = t, this
            },
            copy: function (t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
            },
            copyAt: function (t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            },
            copyArray: function (t) {
                return this.array.set(t), this
            },
            copyColorsArray: function (t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (r = new Vt), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                }
                return this
            },
            copyVector2sArray: function (t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (r = new l), e[n++] = r.x, e[n++] = r.y
                }
                return this
            },
            copyVector3sArray: function (t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (r = new x), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                }
                return this
            },
            copyVector4sArray: function (t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (r = new g), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                }
                return this
            },
            applyMatrix3: function (t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) Xt.fromBufferAttribute(this, e), Xt.applyMatrix3(t), this.setXY(e, Xt.x, Xt.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) qt.fromBufferAttribute(this, e), qt.applyMatrix3(t), this.setXYZ(e, qt.x, qt.y, qt.z);
                return this
            },
            applyMatrix4: function (t) {
                for (let e = 0, n = this.count; e < n; e++) qt.x = this.getX(e), qt.y = this.getY(e), qt.z = this.getZ(e), qt.applyMatrix4(t), this.setXYZ(e, qt.x, qt.y, qt.z);
                return this
            },
            applyNormalMatrix: function (t) {
                for (let e = 0, n = this.count; e < n; e++) qt.x = this.getX(e), qt.y = this.getY(e), qt.z = this.getZ(e), qt.applyNormalMatrix(t), this.setXYZ(e, qt.x, qt.y, qt.z);
                return this
            },
            transformDirection: function (t) {
                for (let e = 0, n = this.count; e < n; e++) qt.x = this.getX(e), qt.y = this.getY(e), qt.z = this.getZ(e), qt.transformDirection(t), this.setXYZ(e, qt.x, qt.y, qt.z);
                return this
            },
            set: function (t, e = 0) {
                return this.array.set(t, e), this
            },
            getX: function (t) {
                return this.array[t * this.itemSize]
            },
            setX: function (t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function (t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function (t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function (t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function (t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function (t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function (t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function (t, e, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
            },
            setXYZ: function (t, e, n, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
            },
            setXYZW: function (t, e, n, i, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
            },
            onUpload: function (t) {
                return this.onUploadCallback = t, this
            },
            clone: function () {
                return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function () {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }), Zt.prototype = Object.create(Yt.prototype), Zt.prototype.constructor = Zt, Jt.prototype = Object.create(Yt.prototype), Jt.prototype.constructor = Jt, Qt.prototype = Object.create(Yt.prototype), Qt.prototype.constructor = Qt, Kt.prototype = Object.create(Yt.prototype), Kt.prototype.constructor = Kt, $t.prototype = Object.create(Yt.prototype), $t.prototype.constructor = $t, te.prototype = Object.create(Yt.prototype), te.prototype.constructor = te, ee.prototype = Object.create(Yt.prototype), ee.prototype.constructor = ee, ne.prototype = Object.create(Yt.prototype), ne.prototype.constructor = ne, ne.prototype.isFloat16BufferAttribute = !0, ie.prototype = Object.create(Yt.prototype), ie.prototype.constructor = ie, re.prototype = Object.create(Yt.prototype), re.prototype.constructor = re;
        class se {
            constructor() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            computeGroups(t) {
                const e = [];
                let n, i, r = void 0;
                const s = t.faces;
                for (i = 0; i < s.length; i++) {
                    const t = s[i];
                    t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = {
                        start: 3 * i,
                        materialIndex: r
                    })
                }
                void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e
            }
            fromGeometry(t) {
                const e = t.faces,
                    n = t.vertices,
                    i = t.faceVertexUvs,
                    r = i[0] && i[0].length > 0,
                    s = i[1] && i[1].length > 0,
                    o = t.morphTargets,
                    a = o.length;
                let c;
                if (a > 0) {
                    c = [];
                    for (let t = 0; t < a; t++) c[t] = {
                        name: o[t].name,
                        data: []
                    };
                    this.morphTargets.position = c
                }
                const h = t.morphNormals,
                    u = h.length;
                let p;
                if (u > 0) {
                    p = [];
                    for (let t = 0; t < u; t++) p[t] = {
                        name: h[t].name,
                        data: []
                    };
                    this.morphTargets.normal = p
                }
                const d = t.skinIndices,
                    f = t.skinWeights,
                    m = d.length === n.length,
                    g = f.length === n.length;
                n.length > 0 && e.length;
                for (let t = 0; t < e.length; t++) {
                    const v = e[t];
                    this.vertices.push(n[v.a], n[v.b], n[v.c]);
                    const y = v.vertexNormals;
                    if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                    else {
                        const t = v.normal;
                        this.normals.push(t, t, t)
                    }
                    const _ = v.vertexColors;
                    if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                    else {
                        const t = v.color;
                        this.colors.push(t, t, t)
                    }
                    if (!0 === r) {
                        const e = i[0][t];
                        void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : this.uvs.push(new l, new l, new l)
                    }
                    if (!0 === s) {
                        const e = i[1][t];
                        void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : this.uvs2.push(new l, new l, new l)
                    }
                    for (let t = 0; t < a; t++) {
                        const e = o[t].vertices;
                        c[t].data.push(e[v.a], e[v.b], e[v.c])
                    }
                    for (let e = 0; e < u; e++) {
                        const n = h[e].vertexNormals[t];
                        p[e].data.push(n.a, n.b, n.c)
                    }
                    m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            }
        }

        function oe(t) {
            if (0 === t.length) return -1 / 0;
            let e = t[0];
            for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
            return e
        }
        const ae = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };

        function ce(t, e) {
            return new ae[t](e)
        }
        let le = 1;
        const he = new Y,
            ue = new _t,
            pe = new x,
            de = new w,
            fe = new w,
            me = new x;

        function ge() {
            Object.defineProperty(this, "id", {
                value: le += 2
            }), this.uuid = c.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        ge.prototype = Object.assign(Object.create(s.prototype), {
            constructor: ge,
            isBufferGeometry: !0,
            getIndex: function () {
                return this.index
            },
            setIndex: function (t) {
                return Array.isArray(t) ? this.index = new(oe(t) > 65535 ? ee : $t)(t, 1) : this.index = t, this
            },
            getAttribute: function (t) {
                return this.attributes[t]
            },
            setAttribute: function (t, e) {
                return this.attributes[t] = e, this
            },
            deleteAttribute: function (t) {
                return delete this.attributes[t], this
            },
            hasAttribute: function (t) {
                return void 0 !== this.attributes[t]
            },
            addGroup: function (t, e, n = 0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            },
            clearGroups: function () {
                this.groups = []
            },
            setDrawRange: function (t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix4: function (t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new h).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function (t) {
                return he.makeRotationX(t), this.applyMatrix4(he), this
            },
            rotateY: function (t) {
                return he.makeRotationY(t), this.applyMatrix4(he), this
            },
            rotateZ: function (t) {
                return he.makeRotationZ(t), this.applyMatrix4(he), this
            },
            translate: function (t, e, n) {
                return he.makeTranslation(t, e, n), this.applyMatrix4(he), this
            },
            scale: function (t, e, n) {
                return he.makeScale(t, e, n), this.applyMatrix4(he), this
            },
            lookAt: function (t) {
                return ue.lookAt(t), ue.updateMatrix(), this.applyMatrix4(ue.matrix), this
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(pe).negate(), this.translate(pe.x, pe.y, pe.z), this
            },
            setFromObject: function (t) {
                const e = t.geometry;
                if (t.isPoints || t.isLine) {
                    const t = new ie(3 * e.vertices.length, 3),
                        n = new ie(3 * e.colors.length, 3);
                    if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        const t = new ie(e.lineDistances.length, 1);
                        this.setAttribute("lineDistance", t.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            },
            setFromPoints: function (t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new ie(e, 3)), this
            },
            updateFromObject: function (t) {
                let e = t.geometry;
                if (t.isMesh) {
                    let t = e.__directGeometry;
                    if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e);
                    t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t
                }
                if (!0 === e.verticesNeedUpdate) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1
                }
                if (!0 === e.normalsNeedUpdate) {
                    const t = this.attributes.normal;
                    void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1
                }
                if (!0 === e.colorsNeedUpdate) {
                    const t = this.attributes.color;
                    void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1
                }
                if (e.uvsNeedUpdate) {
                    const t = this.attributes.uv;
                    void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1
                }
                if (e.lineDistancesNeedUpdate) {
                    const t = this.attributes.lineDistance;
                    void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1
                }
                return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
            },
            fromGeometry: function (t) {
                return t.__directGeometry = (new se).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function (t) {
                const e = new Float32Array(3 * t.vertices.length);
                if (this.setAttribute("position", new Yt(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                    const e = new Float32Array(3 * t.normals.length);
                    this.setAttribute("normal", new Yt(e, 3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    const e = new Float32Array(3 * t.colors.length);
                    this.setAttribute("color", new Yt(e, 3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    const e = new Float32Array(2 * t.uvs.length);
                    this.setAttribute("uv", new Yt(e, 2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    const e = new Float32Array(2 * t.uvs2.length);
                    this.setAttribute("uv2", new Yt(e, 2).copyVector2sArray(t.uvs2))
                }
                this.groups = t.groups;
                for (const e in t.morphTargets) {
                    const n = [],
                        i = t.morphTargets[e];
                    for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t],
                            r = new ie(3 * e.data.length, 3);
                        r.name = e.name, n.push(r.copyVector3sArray(e.data))
                    }
                    this.morphAttributes[e] = n
                }
                if (t.skinIndices.length > 0) {
                    const e = new ie(4 * t.skinIndices.length, 4);
                    this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    const e = new ie(4 * t.skinWeights.length, 4);
                    this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new w);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) this.boundingBox.set(new x(-1 / 0, -1 / 0, -1 / 0), new x(1 / 0, 1 / 0, 1 / 0));
                else {
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                de.setFromBufferAttribute(n), this.morphTargetsRelative ? (me.addVectors(this.boundingBox.min, de.min), this.boundingBox.expandByPoint(me), me.addVectors(this.boundingBox.max, de.max), this.boundingBox.expandByPoint(me)) : (this.boundingBox.expandByPoint(de.min), this.boundingBox.expandByPoint(de.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
                }
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new B);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) this.boundingSphere.set(new x, 1 / 0);
                else if (t) {
                    const n = this.boundingSphere.center;
                    if (de.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            fe.setFromBufferAttribute(n), this.morphTargetsRelative ? (me.addVectors(de.min, fe.min), de.expandByPoint(me), me.addVectors(de.max, fe.max), de.expandByPoint(me)) : (de.expandByPoint(fe.min), de.expandByPoint(fe.max))
                        }
                    de.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++) me.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(me));
                    if (e)
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r],
                                o = this.morphTargetsRelative;
                            for (let e = 0, r = s.count; e < r; e++) me.fromBufferAttribute(s, e), o && (pe.fromBufferAttribute(t, e), me.add(pe)), i = Math.max(i, n.distanceToSquared(me))
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius)
                }
            },
            computeFaceNormals: function () {},
            computeVertexNormals: function () {
                const t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Yt(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                    const i = new x,
                        r = new x,
                        s = new x,
                        o = new x,
                        a = new x,
                        c = new x,
                        l = new x,
                        h = new x;
                    if (t)
                        for (let u = 0, p = t.count; u < p; u += 3) {
                            const p = t.getX(u + 0),
                                d = t.getX(u + 1),
                                f = t.getX(u + 2);
                            i.fromBufferAttribute(e, p), r.fromBufferAttribute(e, d), s.fromBufferAttribute(e, f), l.subVectors(s, r), h.subVectors(i, r), l.cross(h), o.fromBufferAttribute(n, p), a.fromBufferAttribute(n, d), c.fromBufferAttribute(n, f), o.add(l), a.add(l), c.add(l), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(f, c.x, c.y, c.z)
                        } else
                            for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), l.subVectors(s, r), h.subVectors(i, r), l.cross(h), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            },
            merge: function (t, e) {
                if (!t || !t.isBufferGeometry) return;
                void 0 === e && (e = 0);
                const n = this.attributes;
                for (const i in n) {
                    if (void 0 === t.attributes[i]) continue;
                    const r = n[i].array,
                        s = t.attributes[i],
                        o = s.array,
                        a = s.itemSize * e,
                        c = Math.min(o.length, r.length - a);
                    for (let t = 0, e = a; t < c; t++, e++) r[e] = o[t]
                }
                return this
            },
            normalizeNormals: function () {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++) me.fromBufferAttribute(t, e), me.normalize(), t.setXYZ(e, me.x, me.y, me.z)
            },
            toNonIndexed: function () {
                function t(t, e) {
                    const n = t.array,
                        i = t.itemSize,
                        r = t.normalized,
                        s = new n.constructor(e.length * i);
                    let o = 0,
                        a = 0;
                    for (let t = 0, r = e.length; t < r; t++) {
                        o = e[t] * i;
                        for (let t = 0; t < i; t++) s[a++] = n[o++]
                    }
                    return new Yt(s, i, r)
                }
                if (null === this.index) return this;
                const e = new ge,
                    n = this.index.array,
                    i = this.attributes;
                for (const r in i) {
                    const s = t(i[r], n);
                    e.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = [],
                        o = r[i];
                    for (let e = 0, i = o.length; e < i; e++) {
                        const i = t(o[e], n);
                        s.push(i)
                    }
                    e.morphAttributes[i] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            },
            toJSON: function () {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e],
                        r = i.toJSON(t.data);
                    "" !== i.name && (r.name = i.name), t.data.attributes[e] = r
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e],
                        s = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e],
                            r = i.toJSON(t.data);
                        "" !== i.name && (r.name = i.name), s.push(r)
                    }
                    s.length > 0 && (i[e] = s, r = !0)
                }
                r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const o = this.boundingSphere;
                return null !== o && (t.data.boundingSphere = {
                    center: o.center.toArray(),
                    radius: o.radius
                }), t
            },
            clone: function () {
                return (new ge).copy(this)
            },
            copy: function (t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = [],
                        i = r[t];
                    for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const o = t.boundingBox;
                null !== o && (this.boundingBox = o.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        const ve = new Y,
            ye = new X,
            _e = new B,
            xe = new x,
            be = new x,
            Me = new x,
            we = new x,
            Se = new x,
            Te = new x,
            Ae = new x,
            Le = new x,
            Ce = new x,
            Pe = new l,
            Ee = new l,
            Ne = new l,
            Oe = new x,
            De = new x;

        function Ie(t, e) {
            _t.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ge, this.material = void 0 !== e ? e : new Ht, this.updateMorphTargets()
        }

        function ze(t, e, n, i, r, s, o, a) {
            let c;
            if (c = 1 === e.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 2 !== e.side, a), null === c) return null;
            De.copy(a), De.applyMatrix4(t.matrixWorld);
            const l = n.ray.origin.distanceTo(De);
            return l < n.near || l > n.far ? null : {
                distance: l,
                point: De.clone(),
                object: t
            }
        }

        function Re(t, e, n, i, r, s, o, a, c, h, u, p) {
            xe.fromBufferAttribute(r, h), be.fromBufferAttribute(r, u), Me.fromBufferAttribute(r, p);
            const d = t.morphTargetInfluences;
            if (e.morphTargets && s && d) {
                Ae.set(0, 0, 0), Le.set(0, 0, 0), Ce.set(0, 0, 0);
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = d[t],
                        n = s[t];
                    0 !== e && (we.fromBufferAttribute(n, h), Se.fromBufferAttribute(n, u), Te.fromBufferAttribute(n, p), o ? (Ae.addScaledVector(we, e), Le.addScaledVector(Se, e), Ce.addScaledVector(Te, e)) : (Ae.addScaledVector(we.sub(xe), e), Le.addScaledVector(Se.sub(be), e), Ce.addScaledVector(Te.sub(Me), e)))
                }
                xe.add(Ae), be.add(Le), Me.add(Ce)
            }
            t.isSkinnedMesh && (t.boneTransform(h, xe), t.boneTransform(u, be), t.boneTransform(p, Me));
            const f = ze(t, e, n, i, xe, be, Me, Oe);
            if (f) {
                a && (Pe.fromBufferAttribute(a, h), Ee.fromBufferAttribute(a, u), Ne.fromBufferAttribute(a, p), f.uv = It.getUV(Oe, xe, be, Me, Pe, Ee, Ne, new l)), c && (Pe.fromBufferAttribute(c, h), Ee.fromBufferAttribute(c, u), Ne.fromBufferAttribute(c, p), f.uv2 = It.getUV(Oe, xe, be, Me, Pe, Ee, Ne, new l));
                const t = new jt(h, u, p);
                It.getNormal(xe, be, Me, t.normal), f.face = t
            }
            return f
        }
        Ie.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: Ie,
            isMesh: !0,
            copy: function (t) {
                return _t.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
            },
            updateMorphTargets: function () {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length
                }
            },
            raycast: function (t, e) {
                const n = this.geometry,
                    i = this.material,
                    r = this.matrixWorld;
                if (void 0 === i) return;
                if (null === n.boundingSphere && n.computeBoundingSphere(), _e.copy(n.boundingSphere), _e.applyMatrix4(r), !1 === t.ray.intersectsSphere(_e)) return;
                if (ve.copy(r).invert(), ye.copy(t.ray).applyMatrix4(ve), null !== n.boundingBox && !1 === ye.intersectsBox(n.boundingBox)) return;
                let s;
                if (n.isBufferGeometry) {
                    const r = n.index,
                        o = n.attributes.position,
                        a = n.morphAttributes.position,
                        c = n.morphTargetsRelative,
                        l = n.attributes.uv,
                        h = n.attributes.uv2,
                        u = n.groups,
                        p = n.drawRange;
                    if (null !== r)
                        if (Array.isArray(i))
                            for (let n = 0, d = u.length; n < d; n++) {
                                const d = u[n],
                                    f = i[d.materialIndex];
                                for (let n = Math.max(d.start, p.start), i = Math.min(d.start + d.count, p.start + p.count); n < i; n += 3) {
                                    const i = r.getX(n),
                                        u = r.getX(n + 1),
                                        p = r.getX(n + 2);
                                    s = Re(this, f, t, ye, o, a, c, l, h, i, u, p), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = d.materialIndex, e.push(s))
                                }
                            } else {
                                for (let n = Math.max(0, p.start), u = Math.min(r.count, p.start + p.count); n < u; n += 3) {
                                    const u = r.getX(n),
                                        p = r.getX(n + 1),
                                        d = r.getX(n + 2);
                                    s = Re(this, i, t, ye, o, a, c, l, h, u, p, d), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                }
                            } else if (void 0 !== o)
                                if (Array.isArray(i))
                                    for (let n = 0, r = u.length; n < r; n++) {
                                        const r = u[n],
                                            d = i[r.materialIndex];
                                        for (let n = Math.max(r.start, p.start), i = Math.min(r.start + r.count, p.start + p.count); n < i; n += 3) {
                                            s = Re(this, d, t, ye, o, a, c, l, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                        }
                                    } else {
                                        for (let n = Math.max(0, p.start), r = Math.min(o.count, p.start + p.count); n < r; n += 3) {
                                            s = Re(this, i, t, ye, o, a, c, l, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                        }
                                    }
                } else if (n.isGeometry) {
                    const r = Array.isArray(i),
                        o = n.vertices,
                        a = n.faces;
                    let c;
                    const h = n.faceVertexUvs[0];
                    h.length > 0 && (c = h);
                    for (let n = 0, h = a.length; n < h; n++) {
                        const h = a[n],
                            u = r ? i[h.materialIndex] : i;
                        if (void 0 === u) continue;
                        const p = o[h.a],
                            d = o[h.b],
                            f = o[h.c];
                        if (s = ze(this, u, t, ye, p, d, f, Oe), s) {
                            if (c && c[n]) {
                                const t = c[n];
                                Pe.copy(t[0]), Ee.copy(t[1]), Ne.copy(t[2]), s.uv = It.getUV(Oe, p, d, f, Pe, Ee, Ne, new l)
                            }
                            s.face = h, s.faceIndex = n, e.push(s)
                        }
                    }
                }
            }
        });
        class Fe extends ge {
            constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                super(), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const o = this;
                i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                const a = [],
                    c = [],
                    l = [],
                    h = [];
                let u = 0,
                    p = 0;

                function d(t, e, n, i, r, s, d, f, m, g, v) {
                    const y = s / m,
                        _ = d / g,
                        b = s / 2,
                        M = d / 2,
                        w = f / 2,
                        S = m + 1,
                        T = g + 1;
                    let A = 0,
                        L = 0;
                    const C = new x;
                    for (let s = 0; s < T; s++) {
                        const o = s * _ - M;
                        for (let a = 0; a < S; a++) {
                            const u = a * y - b;
                            C[t] = u * i, C[e] = o * r, C[n] = w, c.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[n] = f > 0 ? 1 : -1, l.push(C.x, C.y, C.z), h.push(a / m), h.push(1 - s / g), A += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = u + e + S * t,
                                i = u + e + S * (t + 1),
                                r = u + (e + 1) + S * (t + 1),
                                s = u + (e + 1) + S * t;
                            a.push(n, i, s), a.push(i, r, s), L += 6
                        }
                    o.addGroup(p, L, v), p += L, u += A
                }
                d("z", "y", "x", -1, -1, n, e, t, s, r, 0), d("z", "y", "x", 1, -1, n, e, -t, s, r, 1), d("x", "z", "y", 1, 1, t, n, e, i, s, 2), d("x", "z", "y", 1, -1, t, n, -e, i, s, 3), d("x", "y", "z", 1, -1, t, e, n, i, r, 4), d("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new ie(c, 3)), this.setAttribute("normal", new ie(l, 3)), this.setAttribute("uv", new ie(h, 2))
            }
        }

        function Ue(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }

        function Be(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = Ue(t[n]);
                for (const t in i) e[t] = i[t]
            }
            return e
        }
        const ke = {
            clone: Ue,
            merge: Be
        };

        function Ve(t) {
            Wt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (t.attributes, this.setValues(t))
        }

        function je() {
            _t.call(this), this.type = "Camera", this.matrixWorldInverse = new Y, this.projectionMatrix = new Y, this.projectionMatrixInverse = new Y
        }

        function Ge(t = 50, e = 1, n = .1, i = 2e3) {
            je.call(this), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        Ve.prototype = Object.create(Wt.prototype), Ve.prototype.constructor = Ve, Ve.prototype.isShaderMaterial = !0, Ve.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ue(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
        }, Ve.prototype.toJSON = function (t) {
            const e = Wt.prototype.toJSON.call(this, t);
            e.glslVersion = this.glslVersion, e.uniforms = {};
            for (const n in this.uniforms) {
                const i = this.uniforms[n].value;
                i && i.isTexture ? e.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(t).uuid
                } : i && i.isColor ? e.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? e.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? e.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? e.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? e.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? e.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : e.uniforms[n] = {
                    value: i
                }
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
            const n = {};
            for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e
        }, je.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: je,
            isCamera: !0,
            copy: function (t, e) {
                return _t.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            },
            getWorldDirection: function (t) {
                void 0 === t && (t = new x), this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function (t) {
                _t.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            updateWorldMatrix: function (t, e) {
                _t.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), Ge.prototype = Object.assign(Object.create(je.prototype), {
            constructor: Ge,
            isPerspectiveCamera: !0,
            copy: function (t, e) {
                return je.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function (t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * c.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            },
            getFocalLength: function () {
                const t = Math.tan(.5 * c.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function () {
                return 2 * c.RAD2DEG * Math.atan(Math.tan(.5 * c.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function () {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function () {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function (t, e, n, i, r, s) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                const t = this.near;
                let e = t * Math.tan(.5 * c.DEG2RAD * this.fov) / this.zoom,
                    n = 2 * e,
                    i = this.aspect * n,
                    r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = s.fullWidth,
                        o = s.fullHeight;
                    r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                }
                const o = this.filmOffset;
                0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            },
            toJSON: function (t) {
                const e = _t.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        });

        function We(t, e, n) {
            if (_t.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return;
            this.renderTarget = n;
            const i = new Ge(90, 1, t, e);
            i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new x(1, 0, 0)), this.add(i);
            const r = new Ge(90, 1, t, e);
            r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new x(-1, 0, 0)), this.add(r);
            const s = new Ge(90, 1, t, e);
            s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new x(0, 1, 0)), this.add(s);
            const o = new Ge(90, 1, t, e);
            o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new x(0, -1, 0)), this.add(o);
            const a = new Ge(90, 1, t, e);
            a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new x(0, 0, 1)), this.add(a);
            const c = new Ge(90, 1, t, e);
            c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new x(0, 0, -1)), this.add(c), this.update = function (t, e) {
                null === this.parent && this.updateMatrixWorld();
                const l = t.xr.enabled,
                    h = t.getRenderTarget();
                t.xr.enabled = !1;
                const u = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(h), t.xr.enabled = l
            }
        }

        function He(t, e, n, i, r, s, o, a, c, l) {
            t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, o = void 0 !== o ? o : 1022, f.call(this, t, e, n, i, r, s, o, a, c, l), this.flipY = !1, this._needsFlipEnvMap = !0
        }

        function qe(t, e, n) {
            Number.isInteger(e) && (e = n), v.call(this, t, t, e), e = e || {}, this.texture = new He(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture._needsFlipEnvMap = !1
        }

        function Xe(t, e, n, i, r, s, o, a, c, l, h, u) {
            f.call(this, null, s, o, a, c, l, i, r, h, u), this.image = {
                data: t || null,
                width: e || 1,
                height: n || 1
            }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }
        We.prototype = Object.create(_t.prototype), We.prototype.constructor = We, He.prototype = Object.create(f.prototype), He.prototype.constructor = He, He.prototype.isCubeTexture = !0, Object.defineProperty(He.prototype, "images", {
            get: function () {
                return this.image
            },
            set: function (t) {
                this.image = t
            }
        }), qe.prototype = Object.create(v.prototype), qe.prototype.constructor = qe, qe.prototype.isWebGLCubeRenderTarget = !0, qe.prototype.fromEquirectangularTexture = function (t, e) {
            this.texture.type = e.type, this.texture.format = r, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
            const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
                    fragmentShader: "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t"
                },
                s = new Fe(5, 5, 5),
                o = new Ve({
                    name: "CubemapFromEquirect",
                    uniforms: Ue(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
            o.uniforms.tEquirect.value = e;
            const a = new Ie(s, o),
                c = e.minFilter;
            1008 === e.minFilter && (e.minFilter = i);
            return new We(1, 10, this).update(t, a), e.minFilter = c, a.geometry.dispose(), a.material.dispose(), this
        }, qe.prototype.clear = function (t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
            t.setRenderTarget(r)
        }, Xe.prototype = Object.create(f.prototype), Xe.prototype.constructor = Xe, Xe.prototype.isDataTexture = !0;
        const Ye = new B,
            Ze = new x;
        class Je {
            constructor(t, e, n, i, r, s) {
                this.planes = [void 0 !== t ? t : new wt, void 0 !== e ? e : new wt, void 0 !== n ? n : new wt, void 0 !== i ? i : new wt, void 0 !== r ? r : new wt, void 0 !== s ? s : new wt]
            }
            set(t, e, n, i, r, s) {
                const o = this.planes;
                return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes,
                    n = t.elements,
                    i = n[0],
                    r = n[1],
                    s = n[2],
                    o = n[3],
                    a = n[4],
                    c = n[5],
                    l = n[6],
                    h = n[7],
                    u = n[8],
                    p = n[9],
                    d = n[10],
                    f = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    y = n[15];
                return e[0].setComponents(o - i, h - a, f - u, y - m).normalize(), e[1].setComponents(o + i, h + a, f + u, y + m).normalize(), e[2].setComponents(o + r, h + c, f + p, y + g).normalize(), e[3].setComponents(o - r, h - c, f - p, y - g).normalize(), e[4].setComponents(o - s, h - l, f - d, y - v).normalize(), e[5].setComponents(o + s, h + l, f + d, y + v).normalize(), this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), Ye.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ye)
            }
            intersectsSprite(t) {
                return Ye.center.set(0, 0, 0), Ye.radius = .7071067811865476, Ye.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ye)
            }
            intersectsSphere(t) {
                const e = this.planes,
                    n = t.center,
                    i = -t.radius;
                for (let t = 0; t < 6; t++) {
                    if (e[t].distanceToPoint(n) < i) return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (Ze.x = i.normal.x > 0 ? t.max.x : t.min.x, Ze.y = i.normal.y > 0 ? t.max.y : t.min.y, Ze.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Ze) < 0) return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }
        }

        function Qe() {
            let t = null,
                e = !1,
                n = null,
                i = null;

            function r(e, s) {
                n(e, s), i = t.requestAnimationFrame(r)
            }
            return {
                start: function () {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                },
                stop: function () {
                    t.cancelAnimationFrame(i), e = !1
                },
                setAnimationLoop: function (t) {
                    n = t
                },
                setContext: function (e) {
                    t = e
                }
            }
        }

        function Ke(t, e) {
            const n = e.isWebGL2,
                i = new WeakMap;
            return {
                get: function (t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                },
                remove: function (e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer), i.delete(e))
                },
                update: function (e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = i.get(e);
                    void 0 === s ? i.set(e, function (e, i) {
                        const r = e.array,
                            s = e.usage,
                            o = t.createBuffer();
                        t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback();
                        let a = 5126;
                        return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array || (r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n && (a = 5131) : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121)), {
                            buffer: o,
                            type: a,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : s.version < e.version && (! function (e, i, r) {
                        const s = i.array,
                            o = i.updateRange;
                        t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                    }(s.buffer, e, r), s.version = e.version)
                }
            }
        }
        class $e extends ge {
            constructor(t = 1, e = 1, n = 1, i = 1) {
                super(), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2,
                    s = e / 2,
                    o = Math.floor(n),
                    a = Math.floor(i),
                    c = o + 1,
                    l = a + 1,
                    h = t / o,
                    u = e / a,
                    p = [],
                    d = [],
                    f = [],
                    m = [];
                for (let t = 0; t < l; t++) {
                    const e = t * u - s;
                    for (let n = 0; n < c; n++) {
                        const i = n * h - r;
                        d.push(i, -e, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - t / a)
                    }
                }
                for (let t = 0; t < a; t++)
                    for (let e = 0; e < o; e++) {
                        const n = e + c * t,
                            i = e + c * (t + 1),
                            r = e + 1 + c * (t + 1),
                            s = e + 1 + c * t;
                        p.push(n, i, s), p.push(i, r, s)
                    }
                this.setIndex(p), this.setAttribute("position", new ie(d, 3)), this.setAttribute("normal", new ie(f, 3)), this.setAttribute("uv", new ie(m, 2))
            }
        }
        const tn = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
                transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
                uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
            },
            en = {
                common: {
                    diffuse: {
                        value: new Vt(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new h
                    },
                    uv2Transform: {
                        value: new h
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new l(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Vt(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new Vt(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new h
                    }
                },
                sprite: {
                    diffuse: {
                        value: new Vt(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new l(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new h
                    }
                }
            },
            nn = {
                basic: {
                    uniforms: Be([en.common, en.specularmap, en.envmap, en.aomap, en.lightmap, en.fog]),
                    vertexShader: tn.meshbasic_vert,
                    fragmentShader: tn.meshbasic_frag
                },
                lambert: {
                    uniforms: Be([en.common, en.specularmap, en.envmap, en.aomap, en.lightmap, en.emissivemap, en.fog, en.lights, {
                        emissive: {
                            value: new Vt(0)
                        }
                    }]),
                    vertexShader: tn.meshlambert_vert,
                    fragmentShader: tn.meshlambert_frag
                },
                phong: {
                    uniforms: Be([en.common, en.specularmap, en.envmap, en.aomap, en.lightmap, en.emissivemap, en.bumpmap, en.normalmap, en.displacementmap, en.fog, en.lights, {
                        emissive: {
                            value: new Vt(0)
                        },
                        specular: {
                            value: new Vt(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: tn.meshphong_vert,
                    fragmentShader: tn.meshphong_frag
                },
                standard: {
                    uniforms: Be([en.common, en.envmap, en.aomap, en.lightmap, en.emissivemap, en.bumpmap, en.normalmap, en.displacementmap, en.roughnessmap, en.metalnessmap, en.fog, en.lights, {
                        emissive: {
                            value: new Vt(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: tn.meshphysical_vert,
                    fragmentShader: tn.meshphysical_frag
                },
                toon: {
                    uniforms: Be([en.common, en.aomap, en.lightmap, en.emissivemap, en.bumpmap, en.normalmap, en.displacementmap, en.gradientmap, en.fog, en.lights, {
                        emissive: {
                            value: new Vt(0)
                        }
                    }]),
                    vertexShader: tn.meshtoon_vert,
                    fragmentShader: tn.meshtoon_frag
                },
                matcap: {
                    uniforms: Be([en.common, en.bumpmap, en.normalmap, en.displacementmap, en.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: tn.meshmatcap_vert,
                    fragmentShader: tn.meshmatcap_frag
                },
                points: {
                    uniforms: Be([en.points, en.fog]),
                    vertexShader: tn.points_vert,
                    fragmentShader: tn.points_frag
                },
                dashed: {
                    uniforms: Be([en.common, en.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: tn.linedashed_vert,
                    fragmentShader: tn.linedashed_frag
                },
                depth: {
                    uniforms: Be([en.common, en.displacementmap]),
                    vertexShader: tn.depth_vert,
                    fragmentShader: tn.depth_frag
                },
                normal: {
                    uniforms: Be([en.common, en.bumpmap, en.normalmap, en.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: tn.normal_vert,
                    fragmentShader: tn.normal_frag
                },
                sprite: {
                    uniforms: Be([en.sprite, en.fog]),
                    vertexShader: tn.sprite_vert,
                    fragmentShader: tn.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new h
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: tn.background_vert,
                    fragmentShader: tn.background_frag
                },
                cube: {
                    uniforms: Be([en.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: tn.cube_vert,
                    fragmentShader: tn.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: tn.equirect_vert,
                    fragmentShader: tn.equirect_frag
                },
                distanceRGBA: {
                    uniforms: Be([en.common, en.displacementmap, {
                        referencePosition: {
                            value: new x
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: tn.distanceRGBA_vert,
                    fragmentShader: tn.distanceRGBA_frag
                },
                shadow: {
                    uniforms: Be([en.lights, en.fog, {
                        color: {
                            value: new Vt(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: tn.shadow_vert,
                    fragmentShader: tn.shadow_frag
                }
            };

        function rn(t, e, n, i, r) {
            const s = new Vt(0);
            let o, a, c = 0,
                l = null,
                h = 0,
                u = null;

            function p(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, r)
            }
            return {
                getClearColor: function () {
                    return s
                },
                setClearColor: function (t, e = 1) {
                    s.set(t), c = e, p(s, c)
                },
                getClearAlpha: function () {
                    return c
                },
                setClearAlpha: function (t) {
                    c = t, p(s, c)
                },
                render: function (n, r, d, f) {
                    let m = !0 === r.isScene ? r.background : null;
                    m && m.isTexture && (m = e.get(m));
                    const g = t.xr,
                        v = g.getSession && g.getSession();
                    v && "additive" === v.environmentBlendMode && (m = null), null === m ? p(s, c) : m && m.isColor && (p(m, 1), f = !0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || 306 === m.mapping) ? (void 0 === a && (a = new Ie(new Fe(1, 1, 1), new Ve({
                        name: "BackgroundCubeMaterial",
                        uniforms: Ue(nn.cube.uniforms),
                        vertexShader: nn.cube.vertexShader,
                        fragmentShader: nn.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(a.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), i.update(a)), m.isWebGLCubeRenderTarget && (m = m.texture), a.material.uniforms.envMap.value = m, a.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1, l === m && h === m.version && u === t.toneMapping || (a.material.needsUpdate = !0, l = m, h = m.version, u = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new Ie(new $e(2, 2), new Ve({
                        name: "BackgroundMaterial",
                        uniforms: Ue(nn.background.uniforms),
                        vertexShader: nn.background.vertexShader,
                        fragmentShader: nn.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), i.update(o)), o.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), l === m && h === m.version && u === t.toneMapping || (o.material.needsUpdate = !0, l = m, h = m.version, u = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                }
            }
        }

        function sn(t, e, n, i) {
            const r = t.getParameter(34921),
                s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                o = i.isWebGL2 || null !== s,
                a = {},
                c = p(null);
            let l = c;

            function h(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }

            function u(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }

            function p(t) {
                const e = [],
                    n = [],
                    i = [];
                for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function d() {
                const t = l.newAttributes;
                for (let e = 0, n = t.length; e < n; e++) t[e] = 0
            }

            function f(t) {
                m(t, 0)
            }

            function m(n, r) {
                const s = l.newAttributes,
                    o = l.enabledAttributes,
                    a = l.attributeDivisors;
                if (s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r) {
                    (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r
                }
            }

            function g() {
                const e = l.newAttributes,
                    n = l.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
            }

            function v(e, n, r, s, o, a) {
                !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a)
            }

            function y() {
                _(), l !== c && (l = c, h(l.object))
            }

            function _() {
                c.geometry = null, c.program = null, c.wireframe = !1
            }
            return {
                setup: function (r, c, u, y, _) {
                    let x = !1;
                    if (o) {
                        const e = function (e, n, r) {
                            const o = !0 === r.wireframe;
                            let c = a[e.id];
                            void 0 === c && (c = {}, a[e.id] = c);
                            let l = c[n.id];
                            void 0 === l && (l = {}, c[n.id] = l);
                            let h = l[o];
                            void 0 === h && (h = p(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), l[o] = h);
                            return h
                        }(y, u, c);
                        l !== e && (l = e, h(l.object)), x = function (t, e) {
                            const n = l.attributes,
                                i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = n[t],
                                    s = i[t];
                                if (void 0 === e) return !0;
                                if (e.attribute !== s) return !0;
                                if (e.data !== s.data) return !0;
                                r++
                            }
                            return l.attributesNum !== r || l.index !== e
                        }(y, _), x && function (t, e) {
                            const n = {},
                                i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = i[t],
                                    s = {};
                                s.attribute = e, e.data && (s.data = e.data), n[t] = s, r++
                            }
                            l.attributes = n, l.attributesNum = r, l.index = e
                        }(y, _)
                    } else {
                        const t = !0 === c.wireframe;
                        l.geometry === y.id && l.program === u.id && l.wireframe === t || (l.geometry = y.id, l.program = u.id, l.wireframe = t, x = !0)
                    }!0 === r.isInstancedMesh && (x = !0), null !== _ && n.update(_, 34963), x && (! function (r, s, o, a) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        d();
                        const c = a.attributes,
                            l = o.getAttributes(),
                            h = s.defaultAttributeValues;
                        for (const e in l) {
                            const i = l[e];
                            if (i >= 0) {
                                const s = c[e];
                                if (void 0 !== s) {
                                    const e = s.normalized,
                                        r = s.itemSize,
                                        o = n.get(s);
                                    if (void 0 === o) continue;
                                    const c = o.buffer,
                                        l = o.type,
                                        h = o.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data,
                                            o = n.stride,
                                            u = s.offset;
                                        n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, o * h, u * h)
                                    } else s.isInstancedBufferAttribute ? (m(i, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, 0, 0)
                                } else if ("instanceMatrix" === e) {
                                    const e = n.get(r.instanceMatrix);
                                    if (void 0 === e) continue;
                                    const s = e.buffer,
                                        o = e.type;
                                    m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, o, !1, 64, 48)
                                } else if ("instanceColor" === e) {
                                    const e = n.get(r.instanceColor);
                                    if (void 0 === e) continue;
                                    const s = e.buffer,
                                        o = e.type;
                                    m(i, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i, 3, o, !1, 12, 0)
                                } else if (void 0 !== h) {
                                    const n = h[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(i, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(i, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(i, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(i, n)
                                    }
                                }
                            }
                        }
                        g()
                    }(r, c, u, y), null !== _ && t.bindBuffer(34963, n.get(_).buffer))
                },
                reset: y,
                resetDefaultState: _,
                dispose: function () {
                    y();
                    for (const t in a) {
                        const e = a[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) u(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete a[t]
                    }
                },
                releaseStatesOfGeometry: function (t) {
                    if (void 0 === a[t.id]) return;
                    const e = a[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) u(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete a[t.id]
                },
                releaseStatesOfProgram: function (t) {
                    for (const e in a) {
                        const n = a[e];
                        if (void 0 === n[t.id]) continue;
                        const i = n[t.id];
                        for (const t in i) u(i[t].object), delete i[t];
                        delete n[t.id]
                    }
                },
                initAttributes: d,
                enableAttribute: f,
                disableUnusedAttributes: g
            }
        }

        function on(t, e, n, i) {
            const r = i.isWebGL2;
            let s;
            this.setMode = function (t) {
                s = t
            }, this.render = function (e, i) {
                t.drawArrays(s, e, i), n.update(i, s, 1)
            }, this.renderInstances = function (i, o, a) {
                if (0 === a) return;
                let c, l;
                if (r) c = t, l = "drawArraysInstanced";
                else if (c = e.get("ANGLE_instanced_arrays"), l = "drawArraysInstancedANGLE", null === c) return;
                c[l](s, i, o, a), n.update(o, s, a)
            }
        }

        function an(t, e, n) {
            let i;

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let o = void 0 !== n.precision ? n.precision : "highp";
            const a = r(o);
            a !== o && (o = a);
            const c = !0 === n.logarithmicDepthBuffer,
                l = t.getParameter(34930),
                h = t.getParameter(35660),
                u = t.getParameter(3379),
                p = t.getParameter(34076),
                d = t.getParameter(34921),
                f = t.getParameter(36347),
                m = t.getParameter(36348),
                g = t.getParameter(36349),
                v = h > 0,
                y = s || !!e.get("OES_texture_float");
            return {
                isWebGL2: s,
                getMaxAnisotropy: function () {
                    if (void 0 !== i) return i;
                    const n = e.get("EXT_texture_filter_anisotropic");
                    return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, i
                },
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: c,
                maxTextures: l,
                maxVertexTextures: h,
                maxTextureSize: u,
                maxCubemapSize: p,
                maxAttributes: d,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: s ? t.getParameter(36183) : 0
            }
        }

        function cn(t) {
            const e = this;
            let n = null,
                i = 0,
                r = !1,
                s = !1;
            const o = new wt,
                a = new h,
                c = {
                    value: null,
                    needsUpdate: !1
                };

            function l() {
                c.value !== n && (c.value = n, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
            }

            function u(t, n, i, r) {
                const s = null !== t ? t.length : 0;
                let l = null;
                if (0 !== s) {
                    if (l = c.value, !0 !== r || null === l) {
                        const e = i + 4 * s,
                            r = n.matrixWorldInverse;
                        a.getNormalMatrix(r), (null === l || l.length < e) && (l = new Float32Array(e));
                        for (let e = 0, n = i; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(l, n), l[n + 3] = o.constant
                    }
                    c.value = l, c.needsUpdate = !0
                }
                return e.numPlanes = s, e.numIntersection = 0, l
            }
            this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, s) {
                const o = 0 !== t.length || e || 0 !== i || r;
                return r = e, n = u(t, s, 0), i = t.length, o
            }, this.beginShadows = function () {
                s = !0, u(null)
            }, this.endShadows = function () {
                s = !1, l()
            }, this.setState = function (e, o, a) {
                const h = e.clippingPlanes,
                    p = e.clipIntersection,
                    d = e.clipShadows,
                    f = t.get(e);
                if (!r || null === h || 0 === h.length || s && !d) s ? u(null) : l();
                else {
                    const t = s ? 0 : i,
                        e = 4 * t;
                    let r = f.clippingState || null;
                    c.value = r, r = u(h, o, e, a);
                    for (let t = 0; t !== e; ++t) r[t] = n[t];
                    f.clippingState = r, this.numIntersection = p ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function ln(t) {
            let e = new WeakMap;

            function n(t, e) {
                return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t
            }

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }
            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const s = r.mapping;
                        if (303 === s || 304 === s) {
                            if (e.has(r)) {
                                return n(e.get(r).texture, r.mapping)
                            } {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const o = t.getRenderList(),
                                        a = t.getRenderTarget(),
                                        c = t.getRenderState(),
                                        l = new qe(s.height / 2);
                                    return l.fromEquirectangularTexture(t, r), e.set(r, l), t.setRenderTarget(a), t.setRenderList(o), t.setRenderState(c), r.addEventListener("dispose", i), n(l.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }

        function hn(t) {
            const e = {};
            return {
                has: function (n) {
                    if (void 0 !== e[n]) return null !== e[n];
                    let i;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            i = t.getExtension(n)
                    }
                    return e[n] = i, null !== i
                },
                get: function (t) {
                    return this.has(t), e[t]
                }
            }
        }

        function un(t, e, n, i) {
            const r = new WeakMap,
                s = new WeakMap;

            function o(t) {
                const a = t.target,
                    c = r.get(a);
                null !== c.index && e.remove(c.index);
                for (const t in c.attributes) e.remove(c.attributes[t]);
                a.removeEventListener("dispose", o), r.delete(a);
                const l = s.get(c);
                l && (e.remove(l), s.delete(c)), i.releaseStatesOfGeometry(c), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
            }

            function a(t) {
                const n = [],
                    i = t.index,
                    r = t.attributes.position;
                let o = 0;
                if (null !== i) {
                    const t = i.array;
                    o = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0],
                            r = t[e + 1],
                            s = t[e + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    const t = r.array;
                    o = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0,
                            i = e + 1,
                            r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
                const a = new(oe(n) > 65535 ? ee : $t)(n, 1);
                a.version = o;
                const c = s.get(t);
                c && e.remove(c), s.set(t, a)
            }
            return {
                get: function (t, e) {
                    let i = r.get(e);
                    return i || (e.addEventListener("dispose", o), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new ge).setFromObject(t)), i = e._bufferGeometry), r.set(e, i), n.memory.geometries++, i)
                },
                update: function (t) {
                    const n = t.attributes;
                    for (const t in n) e.update(n[t], 34962);
                    const i = t.morphAttributes;
                    for (const t in i) {
                        const n = i[t];
                        for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
                    }
                },
                getWireframeAttribute: function (t) {
                    const e = s.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && a(t)
                    } else a(t);
                    return s.get(t)
                }
            }
        }

        function pn(t, e, n, i) {
            const r = i.isWebGL2;
            let s, o, a;
            this.setMode = function (t) {
                s = t
            }, this.setIndex = function (t) {
                o = t.type, a = t.bytesPerElement
            }, this.render = function (e, i) {
                t.drawElements(s, i, o, e * a), n.update(i, s, 1)
            }, this.renderInstances = function (i, c, l) {
                if (0 === l) return;
                let h, u;
                if (r) h = t, u = "drawElementsInstanced";
                else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return;
                h[u](s, c, o, i * a, l), n.update(c, s, l)
            }
        }

        function dn(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function () {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function (t, n, i) {
                    switch (e.calls++, n) {
                        case 4:
                            e.triangles += i * (t / 3);
                            break;
                        case 1:
                            e.lines += i * (t / 2);
                            break;
                        case 3:
                            e.lines += i * (t - 1);
                            break;
                        case 2:
                            e.lines += i * t;
                            break;
                        case 0:
                            e.points += i * t
                    }
                }
            }
        }

        function fn(t, e) {
            return t[0] - e[0]
        }

        function mn(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function gn(t) {
            const e = {},
                n = new Float32Array(8),
                i = [];
            for (let t = 0; t < 8; t++) i[t] = [t, 0];
            return {
                update: function (r, s, o, a) {
                    const c = r.morphTargetInfluences,
                        l = void 0 === c ? 0 : c.length;
                    let h = e[s.id];
                    if (void 0 === h) {
                        h = [];
                        for (let t = 0; t < l; t++) h[t] = [t, 0];
                        e[s.id] = h
                    }
                    for (let t = 0; t < l; t++) {
                        const e = h[t];
                        e[0] = t, e[1] = c[t]
                    }
                    h.sort(mn);
                    for (let t = 0; t < 8; t++) t < l && h[t][1] ? (i[t][0] = h[t][0], i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);
                    i.sort(fn);
                    const u = o.morphTargets && s.morphAttributes.position,
                        p = o.morphNormals && s.morphAttributes.normal;
                    let d = 0;
                    for (let t = 0; t < 8; t++) {
                        const e = i[t],
                            r = e[0],
                            o = e[1];
                        r !== Number.MAX_SAFE_INTEGER && o ? (u && s.getAttribute("morphTarget" + t) !== u[r] && s.setAttribute("morphTarget" + t, u[r]), p && s.getAttribute("morphNormal" + t) !== p[r] && s.setAttribute("morphNormal" + t, p[r]), n[t] = o, d += o) : (u && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t), p && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t), n[t] = 0)
                    }
                    const f = s.morphTargetsRelative ? 1 : 1 - d;
                    a.getUniforms().setValue(t, "morphTargetBaseInfluence", f), a.getUniforms().setValue(t, "morphTargetInfluences", n)
                }
            }
        }

        function vn(t, e, n, i) {
            let r = new WeakMap;
            return {
                update: function (t) {
                    const s = i.render.frame,
                        o = t.geometry,
                        a = e.get(t, o);
                    return r.get(a) !== s && (o.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, s)), t.isInstancedMesh && (n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), a
                },
                dispose: function () {
                    r = new WeakMap
                }
            }
        }

        function yn(t = null, e = 1, n = 1, i = 1) {
            f.call(this, null), this.image = {
                data: t,
                width: e,
                height: n,
                depth: i
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }

        function _n(t = null, e = 1, n = 1, i = 1) {
            f.call(this, null), this.image = {
                data: t,
                width: e,
                height: n,
                depth: i
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }
        nn.physical = {
            uniforms: Be([nn.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new l(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new Vt(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                }
            }]),
            vertexShader: tn.meshphysical_vert,
            fragmentShader: tn.meshphysical_frag
        }, yn.prototype = Object.create(f.prototype), yn.prototype.constructor = yn, yn.prototype.isDataTexture2DArray = !0, _n.prototype = Object.create(f.prototype), _n.prototype.constructor = _n, _n.prototype.isDataTexture3D = !0;
        const xn = new f,
            bn = new yn,
            Mn = new _n,
            wn = new He,
            Sn = [],
            Tn = [],
            An = new Float32Array(16),
            Ln = new Float32Array(9),
            Cn = new Float32Array(4);

        function Pn(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0) return t;
            const r = e * n;
            let s = Sn[r];
            if (void 0 === s && (s = new Float32Array(r), Sn[r] = s), 0 !== e) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
            }
            return s
        }

        function En(t, e) {
            if (t.length !== e.length) return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n]) return !1;
            return !0
        }

        function Nn(t, e) {
            for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
        }

        function On(t, e) {
            let n = Tn[e];
            void 0 === n && (n = new Int32Array(e), Tn[e] = n);
            for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
            return n
        }

        function Dn(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function In(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (En(n, e)) return;
                t.uniform2fv(this.addr, e), Nn(n, e)
            }
        }

        function zn(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (En(n, e)) return;
                t.uniform3fv(this.addr, e), Nn(n, e)
            }
        }

        function Rn(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (En(n, e)) return;
                t.uniform4fv(this.addr, e), Nn(n, e)
            }
        }

        function Fn(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (En(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Nn(n, e)
            } else {
                if (En(n, i)) return;
                Cn.set(i), t.uniformMatrix2fv(this.addr, !1, Cn), Nn(n, i)
            }
        }

        function Un(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (En(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Nn(n, e)
            } else {
                if (En(n, i)) return;
                Ln.set(i), t.uniformMatrix3fv(this.addr, !1, Ln), Nn(n, i)
            }
        }

        function Bn(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (En(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Nn(n, e)
            } else {
                if (En(n, i)) return;
                An.set(i), t.uniformMatrix4fv(this.addr, !1, An), Nn(n, i)
            }
        }

        function kn(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || xn, r)
        }

        function Vn(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || bn, r)
        }

        function jn(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Mn, r)
        }

        function Gn(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || wn, r)
        }

        function Wn(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function Hn(t, e) {
            const n = this.cache;
            En(n, e) || (t.uniform2iv(this.addr, e), Nn(n, e))
        }

        function qn(t, e) {
            const n = this.cache;
            En(n, e) || (t.uniform3iv(this.addr, e), Nn(n, e))
        }

        function Xn(t, e) {
            const n = this.cache;
            En(n, e) || (t.uniform4iv(this.addr, e), Nn(n, e))
        }

        function Yn(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function Zn(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function Jn(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Qn(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function Kn(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function $n(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function ti(t, e) {
            const n = Pn(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function ei(t, e) {
            const n = Pn(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function ni(t, e) {
            const n = Pn(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function ii(t, e) {
            const n = Pn(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function ri(t, e) {
            const n = Pn(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function si(t, e) {
            const n = Pn(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function oi(t, e, n) {
            const i = e.length,
                r = On(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || xn, r[t])
        }

        function ai(t, e, n) {
            const i = e.length,
                r = On(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || wn, r[t])
        }

        function ci(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return Dn;
                    case 35664:
                        return In;
                    case 35665:
                        return zn;
                    case 35666:
                        return Rn;
                    case 35674:
                        return Fn;
                    case 35675:
                        return Un;
                    case 35676:
                        return Bn;
                    case 5124:
                    case 35670:
                        return Wn;
                    case 35667:
                    case 35671:
                        return Hn;
                    case 35668:
                    case 35672:
                        return qn;
                    case 35669:
                    case 35673:
                        return Xn;
                    case 5125:
                        return Yn;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return kn;
                    case 35679:
                    case 36299:
                    case 36307:
                        return jn;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Gn;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Vn
                }
            }(e.type)
        }

        function li(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return Zn;
                    case 35664:
                        return ti;
                    case 35665:
                        return ei;
                    case 35666:
                        return ni;
                    case 35674:
                        return ii;
                    case 35675:
                        return ri;
                    case 35676:
                        return si;
                    case 5124:
                    case 35670:
                        return Jn;
                    case 35667:
                    case 35671:
                        return Qn;
                    case 35668:
                    case 35672:
                        return Kn;
                    case 35669:
                    case 35673:
                        return $n;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return oi;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return ai
                }
            }(e.type)
        }

        function hi(t) {
            this.id = t, this.seq = [], this.map = {}
        }
        li.prototype.updateCache = function (t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Nn(e, t)
        }, hi.prototype.setValue = function (t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
                const s = i[r];
                s.setValue(t, e[s.id], n)
            }
        };
        const ui = /([\w\d_]+)(\])?(\[|\.)?/g;

        function pi(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function di(t, e, n) {
            const i = t.name,
                r = i.length;
            for (ui.lastIndex = 0;;) {
                const s = ui.exec(i),
                    o = ui.lastIndex;
                let a = s[1];
                const c = "]" === s[2],
                    l = s[3];
                if (c && (a |= 0), void 0 === l || "[" === l && o + 2 === r) {
                    pi(n, void 0 === l ? new ci(a, t, e) : new li(a, t, e));
                    break
                } {
                    let t = n.map[a];
                    void 0 === t && (t = new hi(a), pi(n, t)), n = t
                }
            }
        }

        function fi(t, e) {
            this.seq = [], this.map = {};
            const n = t.getProgramParameter(e, 35718);
            for (let i = 0; i < n; ++i) {
                const n = t.getActiveUniform(e, i);
                di(n, t.getUniformLocation(e, n.name), this)
            }
        }

        function mi(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n), t.compileShader(i), i
        }
        fi.prototype.setValue = function (t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i)
        }, fi.prototype.setOptional = function (t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i)
        }, fi.upload = function (t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
                const s = e[r],
                    o = n[s.id];
                !1 !== o.needsUpdate && s.setValue(t, o.value, i)
            }
        }, fi.seqWithValue = function (t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
                const r = t[i];
                r.id in e && n.push(r)
            }
            return n
        };
        let gi = 0;

        function vi(t) {
            switch (t) {
                case 3e3:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case 3003:
                    return ["LogLuv", "( value )"];
                default:
                    return ["Linear", "( value )"]
            }
        }

        function yi(t, e, n) {
            const i = t.getShaderParameter(e, 35713),
                r = t.getShaderInfoLog(e).trim();
            if (i && "" === r) return "";
            return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                return e.join("\n")
            }(t.getShaderSource(e))
        }

        function _i(t, e) {
            const n = vi(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }

        function xi(t, e) {
            const n = vi(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function bi(t, e) {
            let n;
            switch (e) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "OptimizedCineon";
                    break;
                case 4:
                    n = "ACESFilmic";
                    break;
                case 5:
                    n = "Custom";
                    break;
                default:
                    n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Mi(t) {
            return "" !== t
        }

        function wi(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Si(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Ti = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Ai(t) {
            return t.replace(Ti, Li)
        }

        function Li(t, e) {
            const n = tn[e];
            if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
            return Ai(n)
        }
        const Ci = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            Pi = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Ei(t) {
            return t.replace(Pi, Oi).replace(Ci, Ni)
        }

        function Ni(t, e, n, i) {
            return Oi(t, e, n, i)
        }

        function Oi(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }

        function Di(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function Ii(t, e, n, i) {
            const r = t.getContext(),
                s = n.defines;
            let o = n.vertexShader,
                a = n.fragmentShader;
            const c = function (t) {
                    let e = "SHADOWMAP_TYPE_BASIC";
                    return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                }(n),
                l = function (t) {
                    let e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case 301:
                        case 302:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case 306:
                        case 307:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(n),
                h = function (t) {
                    let e = "ENVMAP_MODE_REFLECTION";
                    if (t.envMap) switch (t.envMapMode) {
                        case 302:
                        case 307:
                            e = "ENVMAP_MODE_REFRACTION"
                    }
                    return e
                }(n),
                u = function (t) {
                    let e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case 0:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                p = t.gammaFactor > 0 ? t.gammaFactor : 1,
                d = n.isWebGL2 ? "" : function (t) {
                    return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mi).join("\n")
                }(n),
                f = function (t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        !1 !== i && e.push("#define " + n + " " + i)
                    }
                    return e.join("\n")
                }(s),
                m = r.createProgram();
            let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = [f].filter(Mi).join("\n"), g.length > 0 && (g += "\n"), v = [d, f].filter(Mi).join("\n"), v.length > 0 && (v += "\n")) : (g = [Di(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Mi).join("\n"), v = [d, Di(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? tn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? bi("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", tn.encodings_pars_fragment, n.map ? _i("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? _i("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? _i("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? _i("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? _i("lightMapTexelToLinear", n.lightMapEncoding) : "", xi("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Mi).join("\n")), o = Ai(o), o = wi(o, n), o = Si(o, n), a = Ai(a), a = wi(a, n), a = Si(a, n), o = Ei(o), a = Ei(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const _ = y + v + a,
                x = mi(r, 35633, y + g + o),
                b = mi(r, 35632, _);
            if (r.attachShader(m, x), r.attachShader(m, b), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
                const t = r.getProgramInfoLog(m).trim(),
                    e = r.getShaderInfoLog(x).trim(),
                    n = r.getShaderInfoLog(b).trim();
                let i = !0,
                    s = !0;
                if (!1 === r.getProgramParameter(m, 35714)) {
                    i = !1;
                    yi(r, x, "vertex"), yi(r, b, "fragment")
                } else "" !== t || "" !== e && "" !== n || (s = !1);
                s && (this.diagnostics = {
                    runnable: i,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: g
                    },
                    fragmentShader: {
                        log: n,
                        prefix: v
                    }
                })
            }
            let M, w;
            return r.deleteShader(x), r.deleteShader(b), this.getUniforms = function () {
                return void 0 === M && (M = new fi(r, m)), M
            }, this.getAttributes = function () {
                return void 0 === w && (w = function (t, e) {
                    const n = {},
                        i = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r).name;
                        n[i] = t.getAttribLocation(e, i)
                    }
                    return n
                }(r, m)), w
            }, this.destroy = function () {
                i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
            }, this.name = n.shaderName, this.id = gi++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = x, this.fragmentShader = b, this
        }

        function zi(t, e, n, i, r, s) {
            const o = [],
                a = i.isWebGL2,
                c = i.logarithmicDepthBuffer,
                l = i.floatVertexTextures,
                h = i.maxVertexUniforms,
                u = i.vertexTextures;
            let p = i.precision;
            const d = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

            function m(t) {
                let e;
                return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (e = t.texture.encoding) : e = 3e3, e
            }
            return {
                getParameters: function (r, o, f, g, v) {
                    const y = g.fog,
                        _ = r.isMeshStandardMaterial ? g.environment : null,
                        x = e.get(r.envMap || _),
                        b = d[r.type],
                        M = v.isSkinnedMesh ? function (t) {
                            const e = t.skeleton.bones;
                            if (l) return 1024; {
                                const t = h,
                                    n = Math.floor((t - 20) / 4),
                                    i = Math.min(n, e.length);
                                return i < e.length ? 0 : i
                            }
                        }(v) : 0;
                    let w, S;
                    if (null !== r.precision && (p = i.getMaxPrecision(r.precision), r.precision), b) {
                        const t = nn[b];
                        w = t.vertexShader, S = t.fragmentShader
                    } else w = r.vertexShader, S = r.fragmentShader;
                    const T = t.getRenderTarget();
                    return {
                        isWebGL2: a,
                        shaderID: b,
                        shaderName: r.type,
                        vertexShader: w,
                        fragmentShader: S,
                        defines: r.defines,
                        isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                        glslVersion: r.glslVersion,
                        precision: p,
                        instancing: !0 === v.isInstancedMesh,
                        instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                        supportsVertexTextures: u,
                        outputEncoding: null !== T ? m(T.texture) : t.outputEncoding,
                        map: !!r.map,
                        mapEncoding: m(r.map),
                        matcap: !!r.matcap,
                        matcapEncoding: m(r.matcap),
                        envMap: !!x,
                        envMapMode: x && x.mapping,
                        envMapEncoding: m(x),
                        envMapCubeUV: !!x && (306 === x.mapping || 307 === x.mapping),
                        lightMap: !!r.lightMap,
                        lightMapEncoding: m(r.lightMap),
                        aoMap: !!r.aoMap,
                        emissiveMap: !!r.emissiveMap,
                        emissiveMapEncoding: m(r.emissiveMap),
                        bumpMap: !!r.bumpMap,
                        normalMap: !!r.normalMap,
                        objectSpaceNormalMap: 1 === r.normalMapType,
                        tangentSpaceNormalMap: 0 === r.normalMapType,
                        clearcoatMap: !!r.clearcoatMap,
                        clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                        clearcoatNormalMap: !!r.clearcoatNormalMap,
                        displacementMap: !!r.displacementMap,
                        roughnessMap: !!r.roughnessMap,
                        metalnessMap: !!r.metalnessMap,
                        specularMap: !!r.specularMap,
                        alphaMap: !!r.alphaMap,
                        gradientMap: !!r.gradientMap,
                        sheen: !!r.sheen,
                        transmissionMap: !!r.transmissionMap,
                        combine: r.combine,
                        vertexTangents: r.normalMap && r.vertexTangents,
                        vertexColors: r.vertexColors,
                        vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
                        uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
                        fog: !!y,
                        useFog: r.fog,
                        fogExp2: y && y.isFogExp2,
                        flatShading: r.flatShading,
                        sizeAttenuation: r.sizeAttenuation,
                        logarithmicDepthBuffer: c,
                        skinning: r.skinning && M > 0,
                        maxBones: M,
                        useVertexTexture: l,
                        morphTargets: r.morphTargets,
                        morphNormals: r.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: o.directional.length,
                        numPointLights: o.point.length,
                        numSpotLights: o.spot.length,
                        numRectAreaLights: o.rectArea.length,
                        numHemiLights: o.hemi.length,
                        numDirLightShadows: o.directionalShadowMap.length,
                        numPointLightShadows: o.pointShadowMap.length,
                        numSpotLightShadows: o.spotShadowMap.length,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: r.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: r.toneMapped ? t.toneMapping : 0,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: r.premultipliedAlpha,
                        alphaTest: r.alphaTest,
                        doubleSided: 2 === r.side,
                        flipSided: 1 === r.side,
                        depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                        index0AttributeName: r.index0AttributeName,
                        extensionDerivatives: r.extensions && r.extensions.derivatives,
                        extensionFragDepth: r.extensions && r.extensions.fragDepth,
                        extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                        extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: r.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function (e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    if (!1 === e.isRawShaderMaterial) {
                        for (let t = 0; t < f.length; t++) n.push(e[f[t]]);
                        n.push(t.outputEncoding), n.push(t.gammaFactor)
                    }
                    return n.push(e.customProgramCacheKey), n.join()
                },
                getUniforms: function (t) {
                    const e = d[t.type];
                    let n;
                    if (e) {
                        const t = nn[e];
                        n = ke.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                },
                acquireProgram: function (e, n) {
                    let i;
                    for (let t = 0, e = o.length; t < e; t++) {
                        const e = o[t];
                        if (e.cacheKey === n) {
                            i = e, ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Ii(t, n, e, r), o.push(i)), i
                },
                releaseProgram: function (t) {
                    if (0 == --t.usedTimes) {
                        const e = o.indexOf(t);
                        o[e] = o[o.length - 1], o.pop(), t.destroy()
                    }
                },
                programs: o
            }
        }

        function Ri() {
            let t = new WeakMap;
            return {
                get: function (e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                },
                remove: function (e) {
                    t.delete(e)
                },
                update: function (e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function Fi(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Ui(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Bi(t) {
            const e = [];
            let n = 0;
            const i = [],
                r = [],
                s = {
                    id: -1
                };

            function o(i, r, o, a, c, l) {
                let h = e[n];
                const u = t.get(o);
                return void 0 === h ? (h = {
                    id: i.id,
                    object: i,
                    geometry: r,
                    material: o,
                    program: u.program || s,
                    groupOrder: a,
                    renderOrder: i.renderOrder,
                    z: c,
                    group: l
                }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = o, h.program = u.program || s, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = c, h.group = l), n++, h
            }
            return {
                opaque: i,
                transparent: r,
                init: function () {
                    n = 0, i.length = 0, r.length = 0
                },
                push: function (t, e, n, s, a, c) {
                    const l = o(t, e, n, s, a, c);
                    (!0 === n.transparent ? r : i).push(l)
                },
                unshift: function (t, e, n, s, a, c) {
                    const l = o(t, e, n, s, a, c);
                    (!0 === n.transparent ? r : i).unshift(l)
                },
                finish: function () {
                    for (let t = n, i = e.length; t < i; t++) {
                        const n = e[t];
                        if (null === n.id) break;
                        n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                    }
                },
                sort: function (t, e) {
                    i.length > 1 && i.sort(t || Fi), r.length > 1 && r.sort(e || Ui)
                }
            }
        }

        function ki(t) {
            let e = new WeakMap;
            return {
                get: function (n, i) {
                    const r = e.get(n);
                    let s;
                    return void 0 === r ? (s = new Bi(t), e.set(n, new WeakMap), e.get(n).set(i, s)) : (s = r.get(i), void 0 === s && (s = new Bi(t), r.set(i, s))), s
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }

        function Vi() {
            const t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new x,
                                color: new Vt
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new x,
                                direction: new x,
                                color: new Vt,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new x,
                                color: new Vt,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new x,
                                skyColor: new Vt,
                                groundColor: new Vt
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new Vt,
                                position: new x,
                                halfWidth: new x,
                                halfHeight: new x
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        let ji = 0;

        function Gi(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }

        function Wi(t, e) {
            const n = new Vi,
                i = function () {
                    const t = {};
                    return {
                        get: function (e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new l
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new l,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }(),
                r = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                };
            for (let t = 0; t < 9; t++) r.probe.push(new x);
            const s = new x,
                o = new Y,
                a = new Y;
            return {
                setup: function (c, l, h) {
                    let u = 0,
                        p = 0,
                        d = 0;
                    for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                    let f = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0,
                        _ = 0,
                        x = 0,
                        b = 0;
                    const M = h.matrixWorldInverse;
                    c.sort(Gi);
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t],
                            l = e.color,
                            h = e.intensity,
                            w = e.distance,
                            S = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) u += l.r * h, p += l.g * h, d += l.b * h;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], h);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity), t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(M), e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[f] = n, r.directionalShadowMap[f] = S, r.directionalShadowMatrix[f] = e.shadow.matrix, _++
                            }
                            r.directional[f] = t, f++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(M), t.color.copy(l).multiplyScalar(h), t.distance = w, t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(M), t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[g] = n, r.spotShadowMap[g] = S, r.spotShadowMatrix[g] = e.shadow.matrix, b++
                            }
                            r.spot[g] = t, g++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(l).multiplyScalar(h), t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(M), a.identity(), o.copy(e.matrixWorld), o.premultiply(M), a.extractRotation(o), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), r.rectArea[v] = t, v++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(M), t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[m] = n, r.pointShadowMap[m] = S, r.pointShadowMatrix[m] = e.shadow.matrix, x++
                            }
                            r.point[m] = t, m++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(M), t.direction.normalize(), t.skyColor.copy(e.color).multiplyScalar(h), t.groundColor.copy(e.groundColor).multiplyScalar(h), r.hemi[y] = t, y++
                        }
                    }
                    v > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = en.LTC_FLOAT_1, r.rectAreaLTC2 = en.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") && (r.rectAreaLTC1 = en.LTC_HALF_1, r.rectAreaLTC2 = en.LTC_HALF_2)), r.ambient[0] = u, r.ambient[1] = p, r.ambient[2] = d;
                    const w = r.hash;
                    w.directionalLength === f && w.pointLength === m && w.spotLength === g && w.rectAreaLength === v && w.hemiLength === y && w.numDirectionalShadows === _ && w.numPointShadows === x && w.numSpotShadows === b || (r.directional.length = f, r.spot.length = g, r.rectArea.length = v, r.point.length = m, r.hemi.length = y, r.directionalShadow.length = _, r.directionalShadowMap.length = _, r.pointShadow.length = x, r.pointShadowMap.length = x, r.spotShadow.length = b, r.spotShadowMap.length = b, r.directionalShadowMatrix.length = _, r.pointShadowMatrix.length = x, r.spotShadowMatrix.length = b, w.directionalLength = f, w.pointLength = m, w.spotLength = g, w.rectAreaLength = v, w.hemiLength = y, w.numDirectionalShadows = _, w.numPointShadows = x, w.numSpotShadows = b, r.version = ji++)
                },
                state: r
            }
        }

        function Hi(t, e) {
            const n = new Wi(t, e),
                i = [],
                r = [];
            return {
                init: function () {
                    i.length = 0, r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function (t) {
                    n.setup(i, r, t)
                },
                pushLight: function (t) {
                    i.push(t)
                },
                pushShadow: function (t) {
                    r.push(t)
                }
            }
        }

        function qi(t, e) {
            let n = new WeakMap;
            return {
                get: function (i, r) {
                    let s;
                    return !1 === n.has(i) ? (s = new Hi(t, e), n.set(i, new WeakMap), n.get(i).set(r, s)) : !1 === n.get(i).has(r) ? (s = new Hi(t, e), n.get(i).set(r, s)) : s = n.get(i).get(r), s
                },
                dispose: function () {
                    n = new WeakMap
                }
            }
        }

        function Xi(t) {
            Wt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
        }

        function Yi(t) {
            Wt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new x, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
        }
        Xi.prototype = Object.create(Wt.prototype), Xi.prototype.constructor = Xi, Xi.prototype.isMeshDepthMaterial = !0, Xi.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, Yi.prototype = Object.create(Wt.prototype), Yi.prototype.constructor = Yi, Yi.prototype.isMeshDistanceMaterial = !0, Yi.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        };

        function Zi(t, e, n) {
            let s = new Je;
            const o = new l,
                a = new l,
                c = new g,
                h = [],
                u = [],
                p = {},
                d = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                f = new Ve({
                    defines: {
                        SAMPLE_RATE: 2 / 8,
                        HALF_SAMPLE_RATE: 1 / 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new l
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                m = f.clone();
            m.defines.HORIZONAL_PASS = 1;
            const y = new ge;
            y.setAttribute("position", new Yt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const _ = new Ie(y, f),
                x = this;

            function b(n, i) {
                const r = e.update(_);
                f.uniforms.shadow_pass.value = n.map.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, f, _, null), m.uniforms.shadow_pass.value = n.mapPass.texture, m.uniforms.resolution.value = n.mapSize, m.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, m, _, null)
            }

            function M(t, e, n) {
                const i = t << 0 | e << 1 | n << 2;
                let r = h[i];
                return void 0 === r && (r = new Xi({
                    depthPacking: 3201,
                    morphTargets: t,
                    skinning: e
                }), h[i] = r), r
            }

            function w(t, e, n) {
                const i = t << 0 | e << 1 | n << 2;
                let r = u[i];
                return void 0 === r && (r = new Yi({
                    morphTargets: t,
                    skinning: e
                }), u[i] = r), r
            }

            function S(e, n, i, r, s, o, a) {
                let c = null,
                    l = M,
                    h = e.customDepthMaterial;
                if (!0 === r.isPointLight && (l = w, h = e.customDistanceMaterial), void 0 === h) {
                    let t = !1;
                    !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                    let r = !1;
                    !0 === e.isSkinnedMesh && !0 === i.skinning && (r = !0);
                    c = l(t, r, !0 === e.isInstancedMesh)
                } else c = h;
                if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                    const t = c.uuid,
                        e = i.uuid;
                    let n = p[t];
                    void 0 === n && (n = {}, p[t] = n);
                    let r = n[e];
                    void 0 === r && (r = c.clone(), n[e] = r), c = r
                }
                return c.visible = i.visible, c.wireframe = i.wireframe, c.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : d[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = s, c.farDistance = o), c
            }

            function T(n, i, r, o, a) {
                if (!1 === n.visible) return;
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || s.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n),
                        s = n.material;
                    if (Array.isArray(s)) {
                        const e = i.groups;
                        for (let c = 0, l = e.length; c < l; c++) {
                            const l = e[c],
                                h = s[l.materialIndex];
                            if (h && h.visible) {
                                const e = S(n, i, h, o, r.near, r.far, a);
                                t.renderBufferDirect(r, null, i, e, n, l)
                            }
                        }
                    } else if (s.visible) {
                        const e = S(n, i, s, o, r.near, r.far, a);
                        t.renderBufferDirect(r, null, i, e, n, null)
                    }
                }
                const c = n.children;
                for (let t = 0, e = c.length; t < e; t++) T(c[t], i, r, o, a)
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, l, h) {
                if (!1 === x.enabled) return;
                if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
                if (0 === e.length) return;
                const u = t.getRenderTarget(),
                    p = t.getActiveCubeFace(),
                    d = t.getActiveMipmapLevel(),
                    f = t.state;
                f.setBlending(0), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1);
                for (let u = 0, p = e.length; u < p; u++) {
                    const p = e[u],
                        d = p.shadow;
                    if (void 0 === d) continue;
                    if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue;
                    o.copy(d.mapSize);
                    const m = d.getFrameExtents();
                    if (o.multiply(m), a.copy(d.mapSize), (o.x > n || o.y > n) && (o.x > n && (a.x = Math.floor(n / m.x), o.x = a.x * m.x, d.mapSize.x = a.x), o.y > n && (a.y = Math.floor(n / m.y), o.y = a.y * m.y, d.mapSize.y = a.y)), null === d.map && !d.isPointLightShadow && 3 === this.type) {
                        const t = {
                            minFilter: i,
                            magFilter: i,
                            format: r
                        };
                        d.map = new v(o.x, o.y, t), d.map.texture.name = p.name + ".shadowMap", d.mapPass = new v(o.x, o.y, t), d.camera.updateProjectionMatrix()
                    }
                    if (null === d.map) {
                        const t = {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: r
                        };
                        d.map = new v(o.x, o.y, t), d.map.texture.name = p.name + ".shadowMap", d.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(d.map), t.clear();
                    const g = d.getViewportCount();
                    for (let t = 0; t < g; t++) {
                        const e = d.getViewport(t);
                        c.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w), f.viewport(c), d.updateMatrices(p, t), s = d.getFrustum(), T(l, h, d.camera, p, this.type)
                    }
                    d.isPointLightShadow || 3 !== this.type || b(d, h), d.needsUpdate = !1
                }
                x.needsUpdate = !1, t.setRenderTarget(u, p, d)
            }
        }

        function Ji(t, e, n) {
            const i = n.isWebGL2;
            const r = new function () {
                    let e = !1;
                    const n = new g;
                    let i = null;
                    const r = new g(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            i === n || e || (t.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e, i, s, o, a) {
                            !0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n))
                        },
                        reset: function () {
                            e = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                s = new function () {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function (t) {
                            t ? I(2929) : z(2929)
                        },
                        setMask: function (i) {
                            n === i || e || (t.depthMask(i), n = i)
                        },
                        setFunc: function (e) {
                            if (i !== e) {
                                if (e) switch (e) {
                                    case 0:
                                        t.depthFunc(512);
                                        break;
                                    case 1:
                                        t.depthFunc(519);
                                        break;
                                    case 2:
                                        t.depthFunc(513);
                                        break;
                                    case 3:
                                        t.depthFunc(515);
                                        break;
                                    case 4:
                                        t.depthFunc(514);
                                        break;
                                    case 5:
                                        t.depthFunc(518);
                                        break;
                                    case 6:
                                        t.depthFunc(516);
                                        break;
                                    case 7:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                } else t.depthFunc(515);
                                i = e
                            }
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            r !== e && (t.clearDepth(e), r = e)
                        },
                        reset: function () {
                            e = !1, n = null, i = null, r = null
                        }
                    }
                },
                o = new function () {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        o = null,
                        a = null,
                        c = null,
                        l = null;
                    return {
                        setTest: function (t) {
                            e || (t ? I(2960) : z(2960))
                        },
                        setMask: function (i) {
                            n === i || e || (t.stencilMask(i), n = i)
                        },
                        setFunc: function (e, n, o) {
                            i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o)
                        },
                        setOp: function (e, n, i) {
                            o === e && a === n && c === i || (t.stencilOp(e, n, i), o = e, a = n, c = i)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            l !== e && (t.clearStencil(e), l = e)
                        },
                        reset: function () {
                            e = !1, n = null, i = null, r = null, s = null, o = null, a = null, c = null, l = null
                        }
                    }
                };
            let a = {},
                c = null,
                l = null,
                h = null,
                u = null,
                p = null,
                d = null,
                f = null,
                m = null,
                v = null,
                y = !1,
                _ = null,
                x = null,
                b = null,
                M = null,
                w = null;
            const S = t.getParameter(35661);
            let T = !1,
                A = 0;
            const L = t.getParameter(7938); - 1 !== L.indexOf("WebGL") ? (A = parseFloat(/^WebGL\ ([0-9])/.exec(L)[1]), T = A >= 1) : -1 !== L.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(L)[1]), T = A >= 2);
            let C = null,
                P = {};
            const E = new g,
                N = new g;

            function O(e, n, i) {
                const r = new Uint8Array(4),
                    s = t.createTexture();
                t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return s
            }
            const D = {};

            function I(e) {
                !0 !== a[e] && (t.enable(e), a[e] = !0)
            }

            function z(e) {
                !1 !== a[e] && (t.disable(e), a[e] = !1)
            }
            D[3553] = O(3553, 3553, 1), D[34067] = O(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), I(2929), s.setFunc(3), B(!1), k(1), I(2884), U(0);
            const R = {
                100: 32774,
                101: 32778,
                102: 32779
            };
            if (i) R[103] = 32775, R[104] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (R[103] = t.MIN_EXT, R[104] = t.MAX_EXT)
            }
            const F = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };

            function U(e, n, i, r, s, o, a, c) {
                if (0 !== e) {
                    if (l || (I(3042), l = !0), 5 === e) s = s || n, o = o || i, a = a || r, n === u && s === f || (t.blendEquationSeparate(R[n], R[s]), u = n, f = s), i === p && r === d && o === m && a === v || (t.blendFuncSeparate(F[i], F[r], F[o], F[a]), p = i, d = r, m = o, v = a), h = e, y = null;
                    else if (e !== h || c !== y) {
                        if (100 === u && 100 === f || (t.blendEquation(32774), u = 100, f = 100), c) switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFunc(0, 769);
                                break;
                            case 4:
                                t.blendFunc(0, 768)
                        }
                        p = null, d = null, m = null, v = null, h = e, y = c
                    }
                } else l && (z(3042), l = !1)
            }

            function B(e) {
                _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305), _ = e)
            }

            function k(e) {
                0 !== e ? (I(2884), e !== x && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : z(2884), x = e
            }

            function V(e, n, i) {
                e ? (I(32823), M === n && w === i || (t.polygonOffset(n, i), M = n, w = i)) : z(32823)
            }

            function j(e) {
                void 0 === e && (e = 33984 + S - 1), C !== e && (t.activeTexture(e), C = e)
            }
            return {
                buffers: {
                    color: r,
                    depth: s,
                    stencil: o
                },
                enable: I,
                disable: z,
                useProgram: function (e) {
                    return c !== e && (t.useProgram(e), c = e, !0)
                },
                setBlending: U,
                setMaterial: function (t, e) {
                    2 === t.side ? z(2884) : I(2884);
                    let n = 1 === t.side;
                    e && (n = !n), B(n), 1 === t.blending && !1 === t.transparent ? U(0) : U(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                    const i = t.stencilWrite;
                    o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), V(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                },
                setFlipSided: B,
                setCullFace: k,
                setLineWidth: function (e) {
                    e !== b && (T && t.lineWidth(e), b = e)
                },
                setPolygonOffset: V,
                setScissorTest: function (t) {
                    t ? I(3089) : z(3089)
                },
                activeTexture: j,
                bindTexture: function (e, n) {
                    null === C && j();
                    let i = P[C];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, P[C] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || D[e]), i.type = e, i.texture = n)
                },
                unbindTexture: function () {
                    const e = P[C];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function () {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {}
                },
                texImage2D: function () {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {}
                },
                texImage3D: function () {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {}
                },
                scissor: function (e) {
                    !1 === E.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), E.copy(e))
                },
                viewport: function (e) {
                    !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e))
                },
                reset: function () {
                    a = {}, C = null, P = {}, c = null, l = null, h = null, u = null, p = null, d = null, f = null, m = null, v = null, y = !1, _ = null, x = null, b = null, M = null, w = null, r.reset(), s.reset(), o.reset()
                }
            }
        }

        function Qi(t, e, n, s, o, a, l) {
            const h = o.isWebGL2,
                u = (o.maxTextures, o.maxCubemapSize),
                p = o.maxTextureSize,
                d = o.maxSamples,
                f = new WeakMap;
            let m, g = !1;
            try {
                g = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function v(t, e) {
                return g ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function y(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? c.floorPowerOfTwo : Math.floor,
                            s = i(r * t.width),
                            o = i(r * t.height);
                        void 0 === m && (m = v(s, o));
                        const a = n ? v(s, o) : m;
                        a.width = s, a.height = o;
                        return a.getContext("2d").drawImage(t, 0, 0, s, o), a
                    }
                    return t
                }
                return t
            }

            function _(t) {
                return c.isPowerOfTwo(t.width) && c.isPowerOfTwo(t.height)
            }

            function x(t, e) {
                return t.generateMipmaps && e && 1003 !== t.minFilter && t.minFilter !== i
            }

            function b(e, n, i, r) {
                t.generateMipmap(e);
                s.get(n).__maxMipLevel = Math.log(Math.max(i, r)) * Math.LOG2E
            }

            function M(n, i, r) {
                if (!1 === h) return i;
                if (null !== n && void 0 !== t[n]) return t[n];
                let s = i;
                return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s
            }

            function w(t) {
                return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
            }

            function S(e) {
                const n = e.target;
                n.removeEventListener("dispose", S),
                    function (e) {
                        const n = s.get(e);
                        if (void 0 === n.__webglInit) return;
                        t.deleteTexture(n.__webglTexture), s.remove(e)
                    }(n), n.isVideoTexture && f.delete(n), l.memory.textures--
            }

            function T(e) {
                const n = e.target;
                n.removeEventListener("dispose", T),
                    function (e) {
                        const n = s.get(e),
                            i = s.get(e.texture);
                        if (!e) return;
                        void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture);
                        e.depthTexture && e.depthTexture.dispose();
                        if (e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++) t.deleteFramebuffer(n.__webglFramebuffer[e]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
                        else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                        s.remove(e.texture), s.remove(e)
                    }(n), l.memory.textures--
            }
            let A = 0;

            function L(t, e) {
                const i = s.get(t);
                if (t.isVideoTexture && function (t) {
                        const e = l.render.frame;
                        f.get(t) !== e && (f.set(t, e), t.update())
                    }(t), t.version > 0 && i.__version !== t.version) {
                    const n = t.image;
                    if (void 0 === n);
                    else if (!1 !== n.complete) return void D(i, t, e)
                }
                n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture)
            }

            function C(e, i) {
                const o = s.get(e);
                e.version > 0 && o.__version !== e.version ? function (e, i, s) {
                    if (6 !== i.image.length) return;
                    O(e, i), n.activeTexture(33984 + s), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY);
                    const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                        c = i.image[0] && i.image[0].isDataTexture,
                        l = [];
                    for (let t = 0; t < 6; t++) l[t] = o || c ? c ? i.image[t].image : i.image[t] : y(i.image[t], !1, !0, u);
                    const p = l[0],
                        d = _(p) || h,
                        f = a.convert(i.format),
                        m = a.convert(i.type),
                        g = M(i.internalFormat, f, m);
                    let v;
                    if (N(34067, i, d), o) {
                        for (let t = 0; t < 6; t++) {
                            v = l[t].mipmaps;
                            for (let e = 0; e < v.length; e++) {
                                const s = v[e];
                                i.format !== r && 1022 !== i.format ? null !== f && n.compressedTexImage2D(34069 + t, e, g, s.width, s.height, 0, s.data) : n.texImage2D(34069 + t, e, g, s.width, s.height, 0, f, m, s.data)
                            }
                        }
                        e.__maxMipLevel = v.length - 1
                    } else {
                        v = i.mipmaps;
                        for (let t = 0; t < 6; t++)
                            if (c) {
                                n.texImage2D(34069 + t, 0, g, l[t].width, l[t].height, 0, f, m, l[t].data);
                                for (let e = 0; e < v.length; e++) {
                                    const i = v[e].image[t].image;
                                    n.texImage2D(34069 + t, e + 1, g, i.width, i.height, 0, f, m, i.data)
                                }
                            } else {
                                n.texImage2D(34069 + t, 0, g, f, m, l[t]);
                                for (let e = 0; e < v.length; e++) {
                                    const i = v[e];
                                    n.texImage2D(34069 + t, e + 1, g, f, m, i.image[t])
                                }
                            } e.__maxMipLevel = v.length
                    }
                    x(i, d) && b(34067, i, p.width, p.height);
                    e.__version = i.version, i.onUpdate && i.onUpdate(i)
                }(o, e, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture))
            }
            const P = {
                    1e3: 10497,
                    1001: 33071,
                    1002: 33648
                },
                E = {
                    1003: 9728,
                    1004: 9984,
                    1005: 9986,
                    [i]: 9729,
                    1007: 9985,
                    1008: 9987
                };

            function N(n, i, r) {
                r ? (t.texParameteri(n, 10242, P[i.wrapS]), t.texParameteri(n, 10243, P[i.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, P[i.wrapR]), t.texParameteri(n, 10240, E[i.magFilter]), t.texParameteri(n, 10241, E[i.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), 1001 !== i.wrapS || i.wrapT, t.texParameteri(n, 10240, w(i.magFilter)), t.texParameteri(n, 10241, w(i.minFilter)), 1003 !== i.minFilter && i.minFilter);
                const a = e.get("EXT_texture_filter_anisotropic");
                if (a) {
                    if (1015 === i.type && null === e.get("OES_texture_float_linear")) return;
                    if (1016 === i.type && null === (h || e.get("OES_texture_half_float_linear"))) return;
                    (i.anisotropy > 1 || s.get(i).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, o.getMaxAnisotropy())), s.get(i).__currentAnisotropy = i.anisotropy)
                }
            }

            function O(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), l.memory.textures++)
            }

            function D(e, s, o) {
                let c = 3553;
                s.isDataTexture2DArray && (c = 35866), s.isDataTexture3D && (c = 32879), O(e, s), n.activeTexture(33984 + o), n.bindTexture(c, e.__webglTexture), t.pixelStorei(37440, s.flipY), t.pixelStorei(37441, s.premultiplyAlpha), t.pixelStorei(3317, s.unpackAlignment);
                const l = function (t) {
                        return !h && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && t.minFilter !== i)
                    }(s) && !1 === _(s.image),
                    u = y(s.image, l, !1, p),
                    d = _(u) || h,
                    f = a.convert(s.format);
                let m, g = a.convert(s.type),
                    v = M(s.internalFormat, f, g);
                N(c, s, d);
                const w = s.mipmaps;
                if (s.isDepthTexture) v = 6402, h ? v = 1015 === s.type ? 36012 : 1014 === s.type ? 33190 : 1020 === s.type ? 35056 : 33189 : s.type, 1026 === s.format && 6402 === v && 1012 !== s.type && 1014 !== s.type && (s.type = 1012, g = a.convert(s.type)), 1027 === s.format && 6402 === v && (v = 34041, 1020 !== s.type && (s.type = 1020, g = a.convert(s.type))), n.texImage2D(3553, 0, v, u.width, u.height, 0, f, g, null);
                else if (s.isDataTexture)
                    if (w.length > 0 && d) {
                        for (let t = 0, e = w.length; t < e; t++) m = w[t], n.texImage2D(3553, t, v, m.width, m.height, 0, f, g, m.data);
                        s.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
                    } else n.texImage2D(3553, 0, v, u.width, u.height, 0, f, g, u.data), e.__maxMipLevel = 0;
                else if (s.isCompressedTexture) {
                    for (let t = 0, e = w.length; t < e; t++) m = w[t], s.format !== r && 1022 !== s.format ? null !== f && n.compressedTexImage2D(3553, t, v, m.width, m.height, 0, m.data) : n.texImage2D(3553, t, v, m.width, m.height, 0, f, g, m.data);
                    e.__maxMipLevel = w.length - 1
                } else if (s.isDataTexture2DArray) n.texImage3D(35866, 0, v, u.width, u.height, u.depth, 0, f, g, u.data), e.__maxMipLevel = 0;
                else if (s.isDataTexture3D) n.texImage3D(32879, 0, v, u.width, u.height, u.depth, 0, f, g, u.data), e.__maxMipLevel = 0;
                else if (w.length > 0 && d) {
                    for (let t = 0, e = w.length; t < e; t++) m = w[t], n.texImage2D(3553, t, v, f, g, m);
                    s.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
                } else n.texImage2D(3553, 0, v, f, g, u), e.__maxMipLevel = 0;
                x(s, d) && b(c, s, u.width, u.height), e.__version = s.version, s.onUpdate && s.onUpdate(s)
            }

            function I(e, i, r, o) {
                const c = a.convert(i.texture.format),
                    l = a.convert(i.texture.type),
                    h = M(i.texture.internalFormat, c, l);
                n.texImage2D(o, 0, h, i.width, i.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, r, o, s.get(i.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
            }

            function z(e, n, i) {
                if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                    let r = 33189;
                    if (i) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (1015 === e.type ? r = 36012 : 1014 === e.type && (r = 33190));
                        const i = F(n);
                        t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                    } else t.renderbufferStorage(36161, r, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (i) {
                        const e = F(n);
                        t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                    } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = a.convert(n.texture.format),
                        r = a.convert(n.texture.type),
                        s = M(n.texture.internalFormat, e, r);
                    if (i) {
                        const e = F(n);
                        t.renderbufferStorageMultisample(36161, e, s, n.width, n.height)
                    } else t.renderbufferStorage(36161, s, n.width, n.height)
                }
                t.bindRenderbuffer(36161, null)
            }

            function R(e) {
                const n = s.get(e),
                    i = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function (e, n) {
                        if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        s.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), L(n.depthTexture, 0);
                        const i = s.get(n.depthTexture).__webglTexture;
                        if (1026 === n.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, i, 0);
                        else {
                            if (1027 !== n.depthTexture.format) throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(36160, 33306, 3553, i, 0)
                        }
                    }(n.__webglFramebuffer, e)
                } else if (i) {
                    n.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), z(n.__webglDepthbuffer[i], e, !1)
                } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), z(n.__webglDepthbuffer, e, !1);
                t.bindFramebuffer(36160, null)
            }

            function F(t) {
                return h && t.isWebGLMultisampleRenderTarget ? Math.min(d, t.samples) : 0
            }
            let U = !1,
                B = !1;
            this.allocateTextureUnit = function () {
                const t = A;
                return A += 1, t
            }, this.resetTextureUnits = function () {
                A = 0
            }, this.setTexture2D = L, this.setTexture2DArray = function (t, e) {
                const i = s.get(t);
                t.version > 0 && i.__version !== t.version ? D(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture))
            }, this.setTexture3D = function (t, e) {
                const i = s.get(t);
                t.version > 0 && i.__version !== t.version ? D(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture))
            }, this.setTextureCube = C, this.setupRenderTarget = function (e) {
                const i = s.get(e),
                    o = s.get(e.texture);
                e.addEventListener("dispose", T), o.__webglTexture = t.createTexture(), l.memory.textures++;
                const c = !0 === e.isWebGLCubeRenderTarget,
                    u = !0 === e.isWebGLMultisampleRenderTarget,
                    p = _(e) || h;
                if (!h || 1022 !== e.texture.format || 1015 !== e.texture.type && 1016 !== e.texture.type || (e.texture.format = r), c) {
                    i.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++) i.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (i.__webglFramebuffer = t.createFramebuffer(), u && h) {
                    i.__webglMultisampledFramebuffer = t.createFramebuffer(), i.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, i.__webglColorRenderbuffer);
                    const n = a.convert(e.texture.format),
                        r = a.convert(e.texture.type),
                        s = M(e.texture.internalFormat, n, r),
                        o = F(e);
                    t.renderbufferStorageMultisample(36161, o, s, e.width, e.height), t.bindFramebuffer(36160, i.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (i.__webglDepthRenderbuffer = t.createRenderbuffer(), z(i.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                }
                if (c) {
                    n.bindTexture(34067, o.__webglTexture), N(34067, e.texture, p);
                    for (let t = 0; t < 6; t++) I(i.__webglFramebuffer[t], e, 36064, 34069 + t);
                    x(e.texture, p) && b(34067, e.texture, e.width, e.height), n.bindTexture(34067, null)
                } else n.bindTexture(3553, o.__webglTexture), N(3553, e.texture, p), I(i.__webglFramebuffer, e, 36064, 3553), x(e.texture, p) && b(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);
                e.depthBuffer && R(e)
            }, this.updateRenderTargetMipmap = function (t) {
                const e = t.texture;
                if (x(e, _(t) || h)) {
                    const i = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                        r = s.get(e).__webglTexture;
                    n.bindTexture(i, r), b(i, e, t.width, t.height), n.bindTexture(i, null)
                }
            }, this.updateMultisampleRenderTarget = function (e) {
                if (e.isWebGLMultisampleRenderTarget && h) {
                    const n = s.get(e);
                    t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                    const i = e.width,
                        r = e.height;
                    let o = 16384;
                    e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024), t.blitFramebuffer(0, 0, i, r, 0, 0, i, r, o, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                }
            }, this.safeSetTexture2D = function (t, e) {
                t && t.isWebGLRenderTarget && (!1 === U && (U = !0), t = t.texture), L(t, e)
            }, this.safeSetTextureCube = function (t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === B && (B = !0), t = t.texture), C(t, e)
            }
        }

        function Ki(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function (t) {
                    let n;
                    if (1009 === t) return 5121;
                    if (1017 === t) return 32819;
                    if (1018 === t) return 32820;
                    if (1019 === t) return 33635;
                    if (1010 === t) return 5120;
                    if (1011 === t) return 5122;
                    if (1012 === t) return 5123;
                    if (1013 === t) return 5124;
                    if (1014 === t) return 5125;
                    if (1015 === t) return 5126;
                    if (1016 === t) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                    if (1021 === t) return 6406;
                    if (1022 === t) return 6407;
                    if (t === r) return 6408;
                    if (1024 === t) return 6409;
                    if (1025 === t) return 6410;
                    if (1026 === t) return 6402;
                    if (1027 === t) return 34041;
                    if (1028 === t) return 6403;
                    if (1029 === t) return 36244;
                    if (1030 === t) return 33319;
                    if (1031 === t) return 33320;
                    if (1032 === t) return 36248;
                    if (1033 === t) return 36249;
                    if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                        if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                        if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                        if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                        if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                        if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                        if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : 1020 === t ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }

        function $i(t = []) {
            Ge.call(this), this.cameras = t
        }

        function tr() {
            _t.call(this), this.type = "Group"
        }

        function er() {
            this._targetRay = null, this._grip = null, this._hand = null
        }

        function nr(t, e) {
            const n = this;
            let i = null,
                r = 1,
                s = null,
                o = "local-floor",
                a = null;
            const c = [],
                l = new Map,
                h = new Ge;
            h.layers.enable(1), h.viewport = new g;
            const u = new Ge;
            u.layers.enable(2), u.viewport = new g;
            const p = [h, u],
                d = new $i;
            d.layers.enable(1), d.layers.enable(2);
            let f = null,
                m = null;

            function v(t) {
                const e = l.get(t.inputSource);
                e && e.dispatchEvent({
                    type: t.type,
                    data: t.inputSource
                })
            }

            function y() {
                l.forEach((function (t, e) {
                    t.disconnect(e)
                })), l.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), A.stop(), n.isPresenting = !1, n.dispatchEvent({
                    type: "sessionend"
                })
            }

            function _(t) {
                s = t, A.setContext(i), A.start(), n.isPresenting = !0, n.dispatchEvent({
                    type: "sessionstart"
                })
            }

            function b(t) {
                const e = i.inputSources;
                for (let t = 0; t < c.length; t++) l.set(e[t], c[t]);
                for (let e = 0; e < t.removed.length; e++) {
                    const n = t.removed[e],
                        i = l.get(n);
                    i && (i.dispatchEvent({
                        type: "disconnected",
                        data: n
                    }), l.delete(n))
                }
                for (let e = 0; e < t.added.length; e++) {
                    const n = t.added[e],
                        i = l.get(n);
                    i && i.dispatchEvent({
                        type: "connected",
                        data: n
                    })
                }
            }
            this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
                let e = c[t];
                return void 0 === e && (e = new er, c[t] = e), e.getTargetRaySpace()
            }, this.getControllerGrip = function (t) {
                let e = c[t];
                return void 0 === e && (e = new er, c[t] = e), e.getGripSpace()
            }, this.getHand = function (t) {
                let e = c[t];
                return void 0 === e && (e = new er, c[t] = e), e.getHandSpace()
            }, this.setFramebufferScaleFactor = function (t) {
                r = t, n.isPresenting
            }, this.setReferenceSpaceType = function (t) {
                o = t, n.isPresenting
            }, this.getReferenceSpace = function () {
                return s
            }, this.getSession = function () {
                return i
            }, this.setSession = function (t) {
                if (i = t, null !== i) {
                    i.addEventListener("select", v), i.addEventListener("selectstart", v), i.addEventListener("selectend", v), i.addEventListener("squeeze", v), i.addEventListener("squeezestart", v), i.addEventListener("squeezeend", v), i.addEventListener("end", y);
                    const t = e.getContextAttributes();
                    !0 !== t.xrCompatible && e.makeXRCompatible();
                    const n = {
                            antialias: t.antialias,
                            alpha: t.alpha,
                            depth: t.depth,
                            stencil: t.stencil,
                            framebufferScaleFactor: r
                        },
                        s = new XRWebGLLayer(i, e, n);
                    i.updateRenderState({
                        baseLayer: s
                    }), i.requestReferenceSpace(o).then(_), i.addEventListener("inputsourceschange", b)
                }
            };
            const M = new x,
                w = new x;

            function S(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
            }
            this.getCamera = function (t) {
                d.near = u.near = h.near = t.near, d.far = u.far = h.far = t.far, f === d.near && m === d.far || (i.updateRenderState({
                    depthNear: d.near,
                    depthFar: d.far
                }), f = d.near, m = d.far);
                const e = t.parent,
                    n = d.cameras;
                S(d, e);
                for (let t = 0; t < n.length; t++) S(n[t], e);
                t.matrixWorld.copy(d.matrixWorld);
                const r = t.children;
                for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                return 2 === n.length ? function (t, e, n) {
                    M.setFromMatrixPosition(e.matrixWorld), w.setFromMatrixPosition(n.matrixWorld);
                    const i = M.distanceTo(w),
                        r = e.projectionMatrix.elements,
                        s = n.projectionMatrix.elements,
                        o = r[14] / (r[10] - 1),
                        a = r[14] / (r[10] + 1),
                        c = (r[9] + 1) / r[5],
                        l = (r[9] - 1) / r[5],
                        h = (r[8] - 1) / r[0],
                        u = (s[8] + 1) / s[0],
                        p = o * h,
                        d = o * u,
                        f = i / (-h + u),
                        m = f * -h;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = o + f,
                        v = a + f,
                        y = p - m,
                        _ = d + (i - m),
                        x = c * a / v * g,
                        b = l * a / v * g;
                    t.projectionMatrix.makePerspective(y, _, x, b, g, v)
                }(d, h, u) : d.projectionMatrix.copy(h.projectionMatrix), d
            };
            let T = null;
            const A = new Qe;
            A.setAnimationLoop((function (e, n) {
                if (a = n.getViewerPose(s), null !== a) {
                    const e = a.views,
                        n = i.renderState.baseLayer;
                    t.setFramebuffer(n.framebuffer);
                    let r = !1;
                    e.length !== d.cameras.length && (d.cameras.length = 0, r = !0);
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t],
                            s = n.getViewport(i),
                            o = p[t];
                        o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === t && d.matrix.copy(o.matrix), !0 === r && d.cameras.push(o)
                    }
                }
                const r = i.inputSources;
                for (let t = 0; t < c.length; t++) {
                    const e = c[t],
                        i = r[t];
                    e.update(i, n, s)
                }
                T && T(e, n)
            })), this.setAnimationLoop = function (t) {
                T = t
            }, this.dispose = function () {}
        }

        function ir(t) {
            function e(e, n) {
                e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                const i = t.get(n).envMap;
                if (i) {
                    e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                    const r = t.get(i).__maxMipLevel;
                    void 0 !== r && (e.maxMipLevel.value = r)
                }
                let r, s;
                n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
            }

            function n(e, n) {
                e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
                t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
            }
            return {
                refreshFogUniforms: function (t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function (t, i, r, s) {
                    i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function (t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function (t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function (t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function (t, e) {
                        n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                        t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                    }(t, i) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function (t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function (t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function (t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function (t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isLineBasicMaterial ? (function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                    }(t, i), i.isLineDashedMaterial && function (t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        let r;
                        e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                        void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                    }(t, i, r, s) : i.isSpriteMaterial ? function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        let n;
                        e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                    }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }

        function rr(t) {
            const e = void 0 !== (t = t || {}).canvas ? t.canvas : function () {
                    const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return t.style.display = "block", t
                }(),
                n = void 0 !== t.context ? t.context : null,
                i = void 0 !== t.alpha && t.alpha,
                s = void 0 === t.depth || t.depth,
                o = void 0 === t.stencil || t.stencil,
                a = void 0 !== t.antialias && t.antialias,
                h = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                u = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                p = void 0 !== t.powerPreference ? t.powerPreference : "default",
                d = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let f = null,
                m = null;
            this.domElement = e, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            const v = this;
            let y = !1,
                _ = null,
                b = 0,
                M = 0,
                w = null,
                S = null,
                T = -1,
                A = null,
                L = null;
            const C = new g,
                P = new g;
            let E = null,
                N = e.width,
                O = e.height,
                D = 1,
                I = null,
                z = null;
            const R = new g(0, 0, N, O),
                F = new g(0, 0, N, O);
            let U = !1;
            const B = new Je;
            let k = !1,
                V = !1;
            const j = new Y,
                G = new x,
                W = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function H() {
                return null === w ? D : 1
            }
            let q, X, Z, J, Q, K, $, tt, et, nt, it, rt, st, ot, at, ct, lt, ht, ut, pt, dt, ft = n;

            function mt(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i],
                        s = e.getContext(r, n);
                    if (null !== s) return s
                }
                return null
            }
            try {
                const t = {
                    alpha: i,
                    depth: s,
                    stencil: o,
                    antialias: a,
                    premultipliedAlpha: h,
                    preserveDrawingBuffer: u,
                    powerPreference: p,
                    failIfMajorPerformanceCaveat: d
                };
                if (e.addEventListener("webglcontextlost", _t, !1), e.addEventListener("webglcontextrestored", xt, !1), null === ft) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === v.isWebGL1Renderer && e.shift(), ft = mt(e, t), null === ft) throw mt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === ft.getShaderPrecisionFormat && (ft.getShaderPrecisionFormat = function () {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw t
            }

            function gt() {
                q = new hn(ft), X = new an(ft, q, t), !1 === X.isWebGL2 && (q.get("WEBGL_depth_texture"), q.get("OES_texture_float"), q.get("OES_texture_half_float"), q.get("OES_texture_half_float_linear"), q.get("OES_standard_derivatives"), q.get("OES_element_index_uint"), q.get("OES_vertex_array_object"), q.get("ANGLE_instanced_arrays")), q.get("OES_texture_float_linear"), pt = new Ki(ft, q, X), Z = new Ji(ft, q, X), Z.scissor(P.copy(F).multiplyScalar(D).floor()), Z.viewport(C.copy(R).multiplyScalar(D).floor()), J = new dn(ft), Q = new Ri, K = new Qi(ft, q, Z, Q, X, pt, J), $ = new ln(v), tt = new Ke(ft, X), dt = new sn(ft, q, tt, X), et = new un(ft, tt, J, dt), nt = new vn(ft, et, tt, J), lt = new gn(ft), at = new cn(Q), it = new zi(v, $, q, X, dt, at), rt = new ir(Q), st = new ki(Q), ot = new qi(q, X), ct = new rn(v, $, Z, nt, h), ht = new on(ft, q, J, X), ut = new pn(ft, q, J, X), J.programs = it.programs, v.capabilities = X, v.extensions = q, v.properties = Q, v.renderLists = st, v.state = Z, v.info = J
            }
            gt();
            const vt = new nr(v, ft);
            this.xr = vt;
            const yt = new Zi(v, nt, X.maxTextureSize);

            function _t(t) {
                t.preventDefault(), y = !0
            }

            function xt() {
                y = !1, gt()
            }

            function bt(t) {
                const e = t.target;
                e.removeEventListener("dispose", bt),
                    function (t) {
                        Mt(t), Q.remove(t)
                    }(e)
            }

            function Mt(t) {
                const e = Q.get(t).program;
                void 0 !== e && it.releaseProgram(e)
            }
            this.shadowMap = yt, this.getContext = function () {
                return ft
            }, this.getContextAttributes = function () {
                return ft.getContextAttributes()
            }, this.forceContextLoss = function () {
                const t = q.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function () {
                const t = q.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function () {
                return D
            }, this.setPixelRatio = function (t) {
                void 0 !== t && (D = t, this.setSize(N, O, !1))
            }, this.getSize = function (t) {
                return void 0 === t && (t = new l), t.set(N, O)
            }, this.setSize = function (t, n, i) {
                vt.isPresenting || (N = t, O = n, e.width = Math.floor(t * D), e.height = Math.floor(n * D), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
            }, this.getDrawingBufferSize = function (t) {
                return void 0 === t && (t = new l), t.set(N * D, O * D).floor()
            }, this.setDrawingBufferSize = function (t, n, i) {
                N = t, O = n, D = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
            }, this.getCurrentViewport = function (t) {
                return void 0 === t && (t = new g), t.copy(C)
            }, this.getViewport = function (t) {
                return t.copy(R)
            }, this.setViewport = function (t, e, n, i) {
                t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i), Z.viewport(C.copy(R).multiplyScalar(D).floor())
            }, this.getScissor = function (t) {
                return t.copy(F)
            }, this.setScissor = function (t, e, n, i) {
                t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i), Z.scissor(P.copy(F).multiplyScalar(D).floor())
            }, this.getScissorTest = function () {
                return U
            }, this.setScissorTest = function (t) {
                Z.setScissorTest(U = t)
            }, this.setOpaqueSort = function (t) {
                I = t
            }, this.setTransparentSort = function (t) {
                z = t
            }, this.getClearColor = function () {
                return ct.getClearColor()
            }, this.setClearColor = function () {
                ct.setClearColor.apply(ct, arguments)
            }, this.getClearAlpha = function () {
                return ct.getClearAlpha()
            }, this.setClearAlpha = function () {
                ct.setClearAlpha.apply(ct, arguments)
            }, this.clear = function (t, e, n) {
                let i = 0;
                (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), ft.clear(i)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.dispose = function () {
                e.removeEventListener("webglcontextlost", _t, !1), e.removeEventListener("webglcontextrestored", xt, !1), st.dispose(), ot.dispose(), Q.dispose(), $.dispose(), nt.dispose(), dt.dispose(), vt.dispose(), St.stop()
            }, this.renderBufferImmediate = function (t, e) {
                dt.initAttributes();
                const n = Q.get(t);
                t.hasPositions && !n.position && (n.position = ft.createBuffer()), t.hasNormals && !n.normal && (n.normal = ft.createBuffer()), t.hasUvs && !n.uv && (n.uv = ft.createBuffer()), t.hasColors && !n.color && (n.color = ft.createBuffer());
                const i = e.getAttributes();
                t.hasPositions && (ft.bindBuffer(34962, n.position), ft.bufferData(34962, t.positionArray, 35048), dt.enableAttribute(i.position), ft.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ft.bindBuffer(34962, n.normal), ft.bufferData(34962, t.normalArray, 35048), dt.enableAttribute(i.normal), ft.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ft.bindBuffer(34962, n.uv), ft.bufferData(34962, t.uvArray, 35048), dt.enableAttribute(i.uv), ft.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ft.bindBuffer(34962, n.color), ft.bufferData(34962, t.colorArray, 35048), dt.enableAttribute(i.color), ft.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), dt.disableUnusedAttributes(), ft.drawArrays(4, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function (t, e, n, i, r, s) {
                null === e && (e = W);
                const o = r.isMesh && r.matrixWorld.determinant() < 0,
                    a = Pt(t, e, i, r);
                Z.setMaterial(i, o);
                let c = n.index;
                const l = n.attributes.position;
                if (null === c) {
                    if (void 0 === l || 0 === l.count) return
                } else if (0 === c.count) return;
                let h, u = 1;
                !0 === i.wireframe && (c = et.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && lt.update(r, n, i, a), dt.setup(r, i, a, n, c);
                let p = ht;
                null !== c && (h = tt.get(c), p = ut, p.setIndex(h));
                const d = null !== c ? c.count : l.count,
                    f = n.drawRange.start * u,
                    m = n.drawRange.count * u,
                    g = null !== s ? s.start * u : 0,
                    v = null !== s ? s.count * u : 1 / 0,
                    y = Math.max(f, g),
                    _ = Math.min(d, f + m, g + v) - 1,
                    x = Math.max(0, _ - y + 1);
                if (0 !== x) {
                    if (r.isMesh) !0 === i.wireframe ? (Z.setLineWidth(i.wireframeLinewidth * H()), p.setMode(1)) : p.setMode(4);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1), Z.setLineWidth(t * H()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                    } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                    if (r.isInstancedMesh) p.renderInstances(y, x, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        p.renderInstances(y, x, t)
                    } else p.render(y, x)
                }
            }, this.compile = function (t, e) {
                m = ot.get(t, e), m.init(), t.traverseVisible((function (t) {
                    t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
                })), m.setupLights(e);
                const n = new WeakMap;
                t.traverse((function (e) {
                    const i = e.material;
                    if (i)
                        if (Array.isArray(i))
                            for (let r = 0; r < i.length; r++) {
                                const s = i[r];
                                !1 === n.has(s) && (Ct(s, t, e), n.set(s))
                            } else !1 === n.has(i) && (Ct(i, t, e), n.set(i))
                }))
            };
            let wt = null;
            const St = new Qe;

            function Tt(t, e, n, i) {
                if (!1 === t.visible) return;
                if (t.layers.test(e.layers))
                    if (t.isGroup) n = t.renderOrder;
                    else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
                else if (t.isSprite) {
                    if (!t.frustumCulled || B.intersectsSprite(t)) {
                        i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
                        const e = nt.update(t),
                            r = t.material;
                        r.visible && f.push(t, e, r, n, G.z, null)
                    }
                } else if (t.isImmediateRenderObject) i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j), f.push(t, null, t.material, n, G.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== J.render.frame && (t.skeleton.update(), t.skeleton.frame = J.render.frame), !t.frustumCulled || B.intersectsObject(t))) {
                    i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
                    const e = nt.update(t),
                        r = t.material;
                    if (Array.isArray(r)) {
                        const i = e.groups;
                        for (let s = 0, o = i.length; s < o; s++) {
                            const o = i[s],
                                a = r[o.materialIndex];
                            a && a.visible && f.push(t, e, a, n, G.z, o)
                        }
                    } else r.visible && f.push(t, e, r, n, G.z, null)
                }
                const r = t.children;
                for (let t = 0, s = r.length; t < s; t++) Tt(r[t], e, n, i)
            }

            function At(t, e, n) {
                const i = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r],
                        o = s.object,
                        a = s.geometry,
                        c = null === i ? s.material : i,
                        l = s.group;
                    if (n.isArrayCamera) {
                        L = n;
                        const t = n.cameras;
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            o.layers.test(i.layers) && (Z.viewport(C.copy(i.viewport)), m.setupLights(i), Lt(o, e, i, a, c, l))
                        }
                    } else L = null, Lt(o, e, n, a, c, l)
                }
            }

            function Lt(t, e, n, i, r, s) {
                if (t.onBeforeRender(v, e, n, i, r, s), m = ot.get(e, L || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                    const i = Pt(n, e, r, t);
                    Z.setMaterial(r), dt.reset(),
                        function (t, e) {
                            t.render((function (t) {
                                v.renderBufferImmediate(t, e)
                            }))
                        }(t, i)
                } else v.renderBufferDirect(n, e, i, r, t, s);
                t.onAfterRender(v, e, n, i, r, s), m = ot.get(e, L || n)
            }

            function Ct(t, e, n) {
                !0 !== e.isScene && (e = W);
                const i = Q.get(t),
                    r = m.state.lights,
                    s = m.state.shadowsArray,
                    o = r.state.version,
                    a = it.getParameters(t, r.state, s, e, n),
                    c = it.getProgramCacheKey(a);
                let l = i.program,
                    h = !0;
                if (void 0 === l) t.addEventListener("dispose", bt);
                else if (l.cacheKey !== c) Mt(t);
                else if (i.lightsStateVersion !== o) h = !1;
                else {
                    if (void 0 !== a.shaderID) {
                        const n = t.isMeshStandardMaterial ? e.environment : null;
                        return void(i.envMap = $.get(t.envMap || n))
                    }
                    h = !1
                }
                h && (a.uniforms = it.getUniforms(t), t.onBeforeCompile(a, v), l = it.acquireProgram(a, c), i.program = l, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding);
                const u = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = at.numPlanes, i.numIntersection = at.numIntersection, u.clippingPlanes = at.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = $.get(t.envMap || i.environment), i.needsLights = function (t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const p = i.program.getUniforms(),
                    d = fi.seqWithValue(p.seq, u);
                i.uniformsList = d
            }

            function Pt(t, e, n, i) {
                !0 !== e.isScene && (e = W), K.resetTextureUnits();
                const s = e.fog,
                    o = n.isMeshStandardMaterial ? e.environment : null,
                    a = null === w ? v.outputEncoding : w.texture.encoding,
                    l = $.get(n.envMap || o),
                    h = Q.get(n),
                    u = m.state.lights;
                if (!0 === k && (!0 === V || t !== A)) {
                    const e = t === A && n.id === T;
                    at.setState(n, t, e)
                }
                n.version === h.__version ? n.fog && h.fog !== s || h.environment !== o || h.needsLights && h.lightsStateVersion !== u.state.version ? Ct(n, e, i) : void 0 === h.numClippingPlanes || h.numClippingPlanes === at.numPlanes && h.numIntersection === at.numIntersection ? (h.outputEncoding !== a || h.envMap !== l) && Ct(n, e, i) : Ct(n, e, i) : (Ct(n, e, i), h.__version = n.version);
                let p = !1,
                    d = !1,
                    f = !1;
                const g = h.program,
                    y = g.getUniforms(),
                    _ = h.uniforms;
                if (Z.useProgram(g.program) && (p = !0, d = !0, f = !0), n.id !== T && (T = n.id, d = !0), p || A !== t) {
                    if (y.setValue(ft, "projectionMatrix", t.projectionMatrix), X.logarithmicDepthBuffer && y.setValue(ft, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), A !== t && (A = t, d = !0, f = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        const e = y.map.cameraPosition;
                        void 0 !== e && e.setValue(ft, G.setFromMatrixPosition(t.matrixWorld))
                    }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(ft, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && y.setValue(ft, "viewMatrix", t.matrixWorldInverse)
                }
                if (n.skinning) {
                    y.setOptional(ft, i, "bindMatrix"), y.setOptional(ft, i, "bindMatrixInverse");
                    const t = i.skeleton;
                    if (t) {
                        const e = t.bones;
                        if (X.floatVertexTextures) {
                            if (null === t.boneTexture) {
                                let n = Math.sqrt(4 * e.length);
                                n = c.ceilPowerOfTwo(n), n = Math.max(n, 4);
                                const i = new Float32Array(n * n * 4);
                                i.set(t.boneMatrices);
                                const s = new Xe(i, n, n, r, 1015);
                                t.boneMatrices = i, t.boneTexture = s, t.boneTextureSize = n
                            }
                            y.setValue(ft, "boneTexture", t.boneTexture, K), y.setValue(ft, "boneTextureSize", t.boneTextureSize)
                        } else y.setOptional(ft, t, "boneMatrices")
                    }
                }
                var x, b;
                return (d || h.receiveShadow !== i.receiveShadow) && (h.receiveShadow = i.receiveShadow, y.setValue(ft, "receiveShadow", i.receiveShadow)), d && (y.setValue(ft, "toneMappingExposure", v.toneMappingExposure), h.needsLights && (b = f, (x = _).ambientLightColor.needsUpdate = b, x.lightProbe.needsUpdate = b, x.directionalLights.needsUpdate = b, x.directionalLightShadows.needsUpdate = b, x.pointLights.needsUpdate = b, x.pointLightShadows.needsUpdate = b, x.spotLights.needsUpdate = b, x.spotLightShadows.needsUpdate = b, x.rectAreaLights.needsUpdate = b, x.hemisphereLights.needsUpdate = b), s && n.fog && rt.refreshFogUniforms(_, s), rt.refreshMaterialUniforms(_, n, D, O), fi.upload(ft, h.uniformsList, _, K)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (fi.upload(ft, h.uniformsList, _, K), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && y.setValue(ft, "center", i.center), y.setValue(ft, "modelViewMatrix", i.modelViewMatrix), y.setValue(ft, "normalMatrix", i.normalMatrix), y.setValue(ft, "modelMatrix", i.matrixWorld), g
            }
            St.setAnimationLoop((function (t) {
                vt.isPresenting || wt && wt(t)
            })), "undefined" != typeof window && St.setContext(window), this.setAnimationLoop = function (t) {
                wt = t, vt.setAnimationLoop(t), null === t ? St.stop() : St.start()
            }, this.render = function (t, e) {
                let n, i;
                if (void 0 !== arguments[2] && (n = arguments[2]), void 0 !== arguments[3] && (i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return;
                if (!0 === y) return;
                dt.resetDefaultState(), T = -1, A = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === vt.enabled && !0 === vt.isPresenting && (e = vt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(v, t, e, n || w), m = ot.get(t, e), m.init(), j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), B.setFromProjectionMatrix(j), V = this.localClippingEnabled, k = at.init(this.clippingPlanes, V, e), f = st.get(t, e), f.init(), Tt(t, e, 0, v.sortObjects), f.finish(), !0 === v.sortObjects && f.sort(I, z), !0 === k && at.beginShadows();
                const r = m.state.shadowsArray;
                yt.render(r, t, e), m.setupLights(e), !0 === k && at.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), ct.render(f, t, e, i);
                const s = f.opaque,
                    o = f.transparent;
                s.length > 0 && At(s, t, e), o.length > 0 && At(o, t, e), !0 === t.isScene && t.onAfterRender(v, t, e), null !== w && (K.updateRenderTargetMipmap(w), K.updateMultisampleRenderTarget(w)), Z.buffers.depth.setTest(!0), Z.buffers.depth.setMask(!0), Z.buffers.color.setMask(!0), Z.setPolygonOffset(!1), f = null, m = null
            }, this.setFramebuffer = function (t) {
                _ !== t && null === w && ft.bindFramebuffer(36160, t), _ = t
            }, this.getActiveCubeFace = function () {
                return b
            }, this.getActiveMipmapLevel = function () {
                return M
            }, this.getRenderList = function () {
                return f
            }, this.setRenderList = function (t) {
                f = t
            }, this.getRenderState = function () {
                return m
            }, this.setRenderState = function (t) {
                m = t
            }, this.getRenderTarget = function () {
                return w
            }, this.setRenderTarget = function (t, e = 0, n = 0) {
                w = t, b = e, M = n, t && void 0 === Q.get(t).__webglFramebuffer && K.setupRenderTarget(t);
                let i = _,
                    r = !1;
                if (t) {
                    const n = Q.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (i = n[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? Q.get(t).__webglMultisampledFramebuffer : n, C.copy(t.viewport), P.copy(t.scissor), E = t.scissorTest
                } else C.copy(R).multiplyScalar(D).floor(), P.copy(F).multiplyScalar(D).floor(), E = U;
                if (S !== i && (ft.bindFramebuffer(36160, i), S = i), Z.viewport(C), Z.scissor(P), Z.setScissorTest(E), r) {
                    const i = Q.get(t.texture);
                    ft.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                }
            }, this.readRenderTargetPixels = function (t, e, n, i, s, o, a) {
                if (!t || !t.isWebGLRenderTarget) return;
                let c = Q.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== a && (c = c[a]), c) {
                    let a = !1;
                    c !== S && (ft.bindFramebuffer(36160, c), a = !0);
                    try {
                        const c = t.texture,
                            l = c.format,
                            h = c.type;
                        if (l !== r && pt.convert(l) !== ft.getParameter(35739)) return;
                        if (!(1009 === h || pt.convert(h) === ft.getParameter(35738) || 1015 === h && (X.isWebGL2 || q.get("OES_texture_float") || q.get("WEBGL_color_buffer_float")) || 1016 === h && (X.isWebGL2 ? q.get("EXT_color_buffer_float") : q.get("EXT_color_buffer_half_float")))) return;
                        36053 === ft.checkFramebufferStatus(36160) && e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - s && ft.readPixels(e, n, i, s, pt.convert(l), pt.convert(h), o)
                    } finally {
                        a && ft.bindFramebuffer(36160, S)
                    }
                }
            }, this.copyFramebufferToTexture = function (t, e, n = 0) {
                const i = Math.pow(2, -n),
                    r = Math.floor(e.image.width * i),
                    s = Math.floor(e.image.height * i),
                    o = pt.convert(e.format);
                K.setTexture2D(e, 0), ft.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0), Z.unbindTexture()
            }, this.copyTextureToTexture = function (t, e, n, i = 0) {
                const r = e.image.width,
                    s = e.image.height,
                    o = pt.convert(n.format),
                    a = pt.convert(n.type);
                K.setTexture2D(n, 0), ft.pixelStorei(37440, n.flipY), ft.pixelStorei(37441, n.premultiplyAlpha), ft.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ft.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? ft.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ft.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && ft.generateMipmap(3553), Z.unbindTexture()
            }, this.initTexture = function (t) {
                K.setTexture2D(t, 0), Z.unbindTexture()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function sr(t) {
            rr.call(this, t)
        }
        $i.prototype = Object.assign(Object.create(Ge.prototype), {
            constructor: $i,
            isArrayCamera: !0
        }), tr.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: tr,
            isGroup: !0
        }), Object.assign(er.prototype, {
            constructor: er,
            getHandSpace: function () {
                if (null === this._hand && (this._hand = new tr, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = {
                        pinching: !1
                    }, window.XRHand))
                    for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
                        const t = new tr;
                        t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t)
                    }
                return this._hand
            },
            getTargetRaySpace: function () {
                return null === this._targetRay && (this._targetRay = new tr, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
            },
            getGripSpace: function () {
                return null === this._grip && (this._grip = new tr, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
            },
            dispatchEvent: function (t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            },
            disconnect: function (t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            },
            update: function (t, e, n) {
                let i = null,
                    r = null,
                    s = null;
                const o = this._targetRay,
                    a = this._grip,
                    c = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState)
                    if (c && t.hand) {
                        s = !0;
                        for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)
                            if (t.hand[i]) {
                                const r = e.getJointPose(t.hand[i], n),
                                    s = c.joints[i];
                                null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.jointRadius = r.radius), s.visible = null !== r;
                                const o = c.joints[window.XRHand.INDEX_PHALANX_TIP],
                                    a = c.joints[window.XRHand.THUMB_PHALANX_TIP],
                                    l = o.position.distanceTo(a.position),
                                    h = .02,
                                    u = .005;
                                c.inputState.pinching && l > h + u ? (c.inputState.pinching = !1, this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: t.handedness,
                                    target: this
                                })) : !c.inputState.pinching && l <= h - u && (c.inputState.pinching = !0, this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: t.handedness,
                                    target: this
                                }))
                            }
                    } else null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)));
                return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== c && (c.visible = null !== s), this
            }
        }), Object.assign(nr.prototype, s.prototype), sr.prototype = Object.assign(Object.create(rr.prototype), {
            constructor: sr,
            isWebGL1Renderer: !0
        });
        class or extends _t {
            constructor() {
                super(), Object.defineProperty(this, "isScene", {
                    value: !0
                }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }
        }

        function ar(t, e) {
            this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0, this.uuid = c.generateUUID()
        }
        Object.defineProperty(ar.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), Object.assign(ar.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function () {},
            setUsage: function (t) {
                return this.usage = t, this
            },
            copy: function (t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
            },
            copyAt: function (t, e, n) {
                t *= this.stride, n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            },
            set: function (t, e = 0) {
                return this.array.set(t, e), this
            },
            clone: function (t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = c.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new ar(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
                return e.setUsage(this.usage), e
            },
            onUpload: function (t) {
                return this.onUploadCallback = t, this
            },
            toJSON: function (t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = c.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        });
        const cr = new x;

        function lr(t, e, n, i) {
            this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
        }

        function hr(t) {
            Wt.call(this), this.type = "SpriteMaterial", this.color = new Vt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
        }
        let ur;
        Object.defineProperties(lr.prototype, {
            count: {
                get: function () {
                    return this.data.count
                }
            },
            array: {
                get: function () {
                    return this.data.array
                }
            },
            needsUpdate: {
                set: function (t) {
                    this.data.needsUpdate = t
                }
            }
        }), Object.assign(lr.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function (t) {
                for (let e = 0, n = this.data.count; e < n; e++) cr.x = this.getX(e), cr.y = this.getY(e), cr.z = this.getZ(e), cr.applyMatrix4(t), this.setXYZ(e, cr.x, cr.y, cr.z);
                return this
            },
            setX: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function (t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function (t, e, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            },
            setXYZ: function (t, e, n, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
            },
            setXYZW: function (t, e, n, i, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
            },
            clone: function (t) {
                if (void 0 === t) {
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return new Yt(new this.array.constructor(t), this.itemSize, this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new lr(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            },
            toJSON: function (t) {
                if (void 0 === t) {
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }), hr.prototype = Object.create(Wt.prototype), hr.prototype.constructor = hr, hr.prototype.isSpriteMaterial = !0, hr.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
        };
        const pr = new x,
            dr = new x,
            fr = new x,
            mr = new l,
            gr = new l,
            vr = new Y,
            yr = new x,
            _r = new x,
            xr = new x,
            br = new l,
            Mr = new l,
            wr = new l;

        function Sr(t) {
            if (_t.call(this), this.type = "Sprite", void 0 === ur) {
                ur = new ge;
                const t = new ar(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                ur.setIndex([0, 1, 2, 0, 2, 3]), ur.setAttribute("position", new lr(t, 3, 0, !1)), ur.setAttribute("uv", new lr(t, 2, 3, !1))
            }
            this.geometry = ur, this.material = void 0 !== t ? t : new hr, this.center = new l(.5, .5)
        }

        function Tr(t, e, n, i, r, s) {
            mr.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (gr.x = s * mr.x - r * mr.y, gr.y = r * mr.x + s * mr.y) : gr.copy(mr), t.copy(e), t.x += gr.x, t.y += gr.y, t.applyMatrix4(vr)
        }
        Sr.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: Sr,
            isSprite: !0,
            raycast: function (t, e) {
                t.camera, dr.setFromMatrixScale(this.matrixWorld), vr.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), fr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && dr.multiplyScalar(-fr.z);
                const n = this.material.rotation;
                let i, r;
                0 !== n && (r = Math.cos(n), i = Math.sin(n));
                const s = this.center;
                Tr(yr.set(-.5, -.5, 0), fr, s, dr, i, r), Tr(_r.set(.5, -.5, 0), fr, s, dr, i, r), Tr(xr.set(.5, .5, 0), fr, s, dr, i, r), br.set(0, 0), Mr.set(1, 0), wr.set(1, 1);
                let o = t.ray.intersectTriangle(yr, _r, xr, !1, pr);
                if (null === o && (Tr(_r.set(-.5, .5, 0), fr, s, dr, i, r), Mr.set(0, 1), o = t.ray.intersectTriangle(yr, xr, _r, !1, pr), null === o)) return;
                const a = t.ray.origin.distanceTo(pr);
                a < t.near || a > t.far || e.push({
                    distance: a,
                    point: pr.clone(),
                    uv: It.getUV(pr, yr, _r, xr, br, Mr, wr, new l),
                    face: null,
                    object: this
                })
            },
            copy: function (t) {
                return _t.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
            }
        });
        const Ar = new x,
            Lr = new x;

        function Cr() {
            _t.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            }), this.autoUpdate = !0
        }

        function Pr(t, e) {
            t && t.isGeometry, Ie.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Y, this.bindMatrixInverse = new Y
        }

        function Er() {
            _t.call(this), this.type = "Bone"
        }
        Cr.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: Cr,
            isLOD: !0,
            copy: function (t) {
                _t.prototype.copy.call(this, t, !1);
                const e = t.levels;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t];
                    this.addLevel(n.object.clone(), n.distance)
                }
                return this.autoUpdate = t.autoUpdate, this
            },
            addLevel: function (t, e = 0) {
                e = Math.abs(e);
                const n = this.levels;
                let i;
                for (i = 0; i < n.length && !(e < n[i].distance); i++);
                return n.splice(i, 0, {
                    distance: e,
                    object: t
                }), this.add(t), this
            },
            getCurrentLevel: function () {
                return this._currentLevel
            },
            getObjectForDistance: function (t) {
                const e = this.levels;
                if (e.length > 0) {
                    let n, i;
                    for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                    return e[n - 1].object
                }
                return null
            },
            raycast: function (t, e) {
                if (this.levels.length > 0) {
                    Ar.setFromMatrixPosition(this.matrixWorld);
                    const n = t.ray.origin.distanceTo(Ar);
                    this.getObjectForDistance(n).raycast(t, e)
                }
            },
            update: function (t) {
                const e = this.levels;
                if (e.length > 1) {
                    Ar.setFromMatrixPosition(t.matrixWorld), Lr.setFromMatrixPosition(this.matrixWorld);
                    const n = Ar.distanceTo(Lr) / t.zoom;
                    let i, r;
                    for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                    for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
                }
            },
            toJSON: function (t) {
                const e = _t.prototype.toJSON.call(this, t);
                !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                const n = this.levels;
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    e.object.levels.push({
                        object: i.object.uuid,
                        distance: i.distance
                    })
                }
                return e
            }
        }), Pr.prototype = Object.assign(Object.create(Ie.prototype), {
            constructor: Pr,
            isSkinnedMesh: !0,
            copy: function (t) {
                return Ie.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
            },
            bind: function (t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            },
            pose: function () {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function () {
                const t = new g,
                    e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            },
            updateMatrixWorld: function (t) {
                Ie.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
            },
            boneTransform: function () {
                const t = new x,
                    e = new g,
                    n = new g,
                    i = new x,
                    r = new Y;
                return function (s, o) {
                    const a = this.skeleton,
                        c = this.geometry;
                    e.fromBufferAttribute(c.attributes.skinIndex, s), n.fromBufferAttribute(c.attributes.skinWeight, s), t.fromBufferAttribute(c.attributes.position, s).applyMatrix4(this.bindMatrix), o.set(0, 0, 0);
                    for (let s = 0; s < 4; s++) {
                        const c = n.getComponent(s);
                        if (0 !== c) {
                            const n = e.getComponent(s);
                            r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]), o.addScaledVector(i.copy(t).applyMatrix4(r), c)
                        }
                    }
                    return o.applyMatrix4(this.bindMatrixInverse)
                }
            }()
        }), Er.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: Er,
            isBone: !0
        });
        const Nr = new Y,
            Or = new Y;

        function Dr(t = [], e = []) {
            this.uuid = c.generateUUID(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
        }
        Object.assign(Dr.prototype, {
            init: function () {
                const t = this.bones,
                    e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                else if (t.length !== e.length) {
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Y)
                }
            },
            calculateInverses: function () {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new Y;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                }
            },
            pose: function () {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            },
            update: function () {
                const t = this.bones,
                    e = this.boneInverses,
                    n = this.boneMatrices,
                    i = this.boneTexture;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i] ? t[i].matrixWorld : Or;
                    Nr.multiplyMatrices(r, e[i]), Nr.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            },
            clone: function () {
                return new Dr(this.bones, this.boneInverses)
            },
            getBoneByName: function (t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t) return n
                }
            },
            dispose: function () {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
            },
            fromJSON: function (t, e) {
                this.uuid = t.uuid;
                for (let n = 0, i = t.bones.length; n < i; n++) {
                    let i = e[t.bones[n]];
                    void 0 === i && (i = new Er), this.bones.push(i), this.boneInverses.push((new Y).fromArray(t.boneInverses[n]))
                }
                return this.init(), this
            },
            toJSON: function () {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones,
                    n = this.boneInverses;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i];
                    t.bones.push(r.uuid);
                    const s = n[i];
                    t.boneInverses.push(s.toArray())
                }
                return t
            }
        });
        const Ir = new Y,
            zr = new Y,
            Rr = [],
            Fr = new Ie;

        function Ur(t, e, n) {
            Ie.call(this, t, e), this.instanceMatrix = new Yt(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
        }

        function Br(t) {
            Wt.call(this), this.type = "LineBasicMaterial", this.color = new Vt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
        }
        Ur.prototype = Object.assign(Object.create(Ie.prototype), {
            constructor: Ur,
            isInstancedMesh: !0,
            copy: function (t) {
                return Ie.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this
            },
            getColorAt: function (t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            },
            getMatrixAt: function (t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            },
            raycast: function (t, e) {
                const n = this.matrixWorld,
                    i = this.count;
                if (Fr.geometry = this.geometry, Fr.material = this.material, void 0 !== Fr.material)
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Ir), zr.multiplyMatrices(n, Ir), Fr.matrixWorld = zr, Fr.raycast(t, Rr);
                        for (let t = 0, n = Rr.length; t < n; t++) {
                            const n = Rr[t];
                            n.instanceId = r, n.object = this, e.push(n)
                        }
                        Rr.length = 0
                    }
            },
            setColorAt: function (t, e) {
                null === this.instanceColor && (this.instanceColor = new Yt(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            },
            setMatrixAt: function (t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            },
            updateMorphTargets: function () {}
        }), Br.prototype = Object.create(Wt.prototype), Br.prototype.constructor = Br, Br.prototype.isLineBasicMaterial = !0, Br.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
        };
        const kr = new x,
            Vr = new x,
            jr = new Y,
            Gr = new X,
            Wr = new B;

        function Hr(t, e, n) {
            _t.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new ge, this.material = void 0 !== e ? e : new Br, this.updateMorphTargets()
        }
        Hr.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: Hr,
            isLine: !0,
            copy: function (t) {
                return _t.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
            },
            computeLineDistances: function () {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    if (null === t.index) {
                        const e = t.attributes.position,
                            n = [0];
                        for (let t = 1, i = e.count; t < i; t++) kr.fromBufferAttribute(e, t - 1), Vr.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += kr.distanceTo(Vr);
                        t.setAttribute("lineDistance", new ie(n, 1))
                    }
                } else if (t.isGeometry) {
                    const e = t.vertices,
                        n = t.lineDistances;
                    n[0] = 0;
                    for (let t = 1, i = e.length; t < i; t++) n[t] = n[t - 1], n[t] += e[t - 1].distanceTo(e[t])
                }
                return this
            },
            raycast: function (t, e) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = t.params.Line.threshold;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Wr.copy(n.boundingSphere), Wr.applyMatrix4(i), Wr.radius += r, !1 === t.ray.intersectsSphere(Wr)) return;
                jr.copy(i).invert(), Gr.copy(t.ray).applyMatrix4(jr);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = s * s,
                    a = new x,
                    c = new x,
                    l = new x,
                    h = new x,
                    u = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const i = n.index,
                        r = n.attributes.position;
                    if (null !== i) {
                        const n = i.array;
                        for (let i = 0, s = n.length - 1; i < s; i += u) {
                            const s = n[i],
                                u = n[i + 1];
                            a.fromBufferAttribute(r, s), c.fromBufferAttribute(r, u);
                            if (Gr.distanceSqToSegment(a, c, h, l) > o) continue;
                            h.applyMatrix4(this.matrixWorld);
                            const p = t.ray.origin.distanceTo(h);
                            p < t.near || p > t.far || e.push({
                                distance: p,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else
                        for (let n = 0, i = r.count - 1; n < i; n += u) {
                            a.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
                            if (Gr.distanceSqToSegment(a, c, h, l) > o) continue;
                            h.applyMatrix4(this.matrixWorld);
                            const i = t.ray.origin.distanceTo(h);
                            i < t.near || i > t.far || e.push({
                                distance: i,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                } else if (n.isGeometry) {
                    const i = n.vertices,
                        r = i.length;
                    for (let n = 0; n < r - 1; n += u) {
                        if (Gr.distanceSqToSegment(i[n], i[n + 1], h, l) > o) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const r = t.ray.origin.distanceTo(h);
                        r < t.near || r > t.far || e.push({
                            distance: r,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            },
            updateMorphTargets: function () {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length
                }
            }
        });
        const qr = new x,
            Xr = new x;

        function Yr(t, e) {
            Hr.call(this, t, e), this.type = "LineSegments"
        }

        function Zr(t, e) {
            Hr.call(this, t, e), this.type = "LineLoop"
        }

        function Jr(t) {
            Wt.call(this), this.type = "PointsMaterial", this.color = new Vt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
        }
        Yr.prototype = Object.assign(Object.create(Hr.prototype), {
            constructor: Yr,
            isLineSegments: !0,
            computeLineDistances: function () {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    if (null === t.index) {
                        const e = t.attributes.position,
                            n = [];
                        for (let t = 0, i = e.count; t < i; t += 2) qr.fromBufferAttribute(e, t), Xr.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + qr.distanceTo(Xr);
                        t.setAttribute("lineDistance", new ie(n, 1))
                    }
                } else if (t.isGeometry) {
                    const e = t.vertices,
                        n = t.lineDistances;
                    for (let t = 0, i = e.length; t < i; t += 2) qr.copy(e[t]), Xr.copy(e[t + 1]), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + qr.distanceTo(Xr)
                }
                return this
            }
        }), Zr.prototype = Object.assign(Object.create(Hr.prototype), {
            constructor: Zr,
            isLineLoop: !0
        }), Jr.prototype = Object.create(Wt.prototype), Jr.prototype.constructor = Jr, Jr.prototype.isPointsMaterial = !0, Jr.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
        };
        const Qr = new Y,
            Kr = new X,
            $r = new B,
            ts = new x;

        function es(t, e) {
            _t.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new ge, this.material = void 0 !== e ? e : new Jr, this.updateMorphTargets()
        }

        function ns(t, e, n, i, r, s, o) {
            const a = Kr.distanceSqToPoint(t);
            if (a < n) {
                const n = new x;
                Kr.closestPointToPoint(t, n), n.applyMatrix4(i);
                const c = r.ray.origin.distanceTo(n);
                if (c < r.near || c > r.far) return;
                s.push({
                    distance: c,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: e,
                    face: null,
                    object: o
                })
            }
        }

        function is(t, e, n, r, s, o, a, c, l) {
            f.call(this, t, e, n, r, s, o, a, c, l), this.format = void 0 !== a ? a : 1022, this.minFilter = void 0 !== o ? o : i, this.magFilter = void 0 !== s ? s : i, this.generateMipmaps = !1;
            const h = this;
            "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                h.needsUpdate = !0, t.requestVideoFrameCallback(e)
            }))
        }

        function rs(t, e, n, i, r, s, o, a, c, l, h, u) {
            f.call(this, null, s, o, a, c, l, i, r, h, u), this.image = {
                width: e,
                height: n
            }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
        }

        function ss(t, e, n, i, r, s, o, a, c) {
            f.call(this, t, e, n, i, r, s, o, a, c), this.needsUpdate = !0
        }

        function os(t, e, n, i, r, s, o, a, c, l) {
            if (1026 !== (l = void 0 !== l ? l : 1026) && 1027 !== l) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && 1026 === l && (n = 1012), void 0 === n && 1027 === l && (n = 1020), f.call(this, null, i, r, s, o, a, l, n, c), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== o ? o : 1003, this.minFilter = void 0 !== a ? a : 1003, this.flipY = !1, this.generateMipmaps = !1
        }
        es.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: es,
            isPoints: !0,
            copy: function (t) {
                return _t.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
            },
            raycast: function (t, e) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = t.params.Points.threshold;
                if (null === n.boundingSphere && n.computeBoundingSphere(), $r.copy(n.boundingSphere), $r.applyMatrix4(i), $r.radius += r, !1 === t.ray.intersectsSphere($r)) return;
                Qr.copy(i).invert(), Kr.copy(t.ray).applyMatrix4(Qr);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = s * s;
                if (n.isBufferGeometry) {
                    const r = n.index,
                        s = n.attributes.position;
                    if (null !== r) {
                        const n = r.array;
                        for (let r = 0, a = n.length; r < a; r++) {
                            const a = n[r];
                            ts.fromBufferAttribute(s, a), ns(ts, a, o, i, t, e, this)
                        }
                    } else
                        for (let n = 0, r = s.count; n < r; n++) ts.fromBufferAttribute(s, n), ns(ts, n, o, i, t, e, this)
                } else {
                    const r = n.vertices;
                    for (let n = 0, s = r.length; n < s; n++) ns(r[n], n, o, i, t, e, this)
                }
            },
            updateMorphTargets: function () {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length
                }
            }
        }), is.prototype = Object.assign(Object.create(f.prototype), {
            constructor: is,
            clone: function () {
                return new this.constructor(this.image).copy(this)
            },
            isVideoTexture: !0,
            update: function () {
                const t = this.image;
                !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), rs.prototype = Object.create(f.prototype), rs.prototype.constructor = rs, rs.prototype.isCompressedTexture = !0, ss.prototype = Object.create(f.prototype), ss.prototype.constructor = ss, ss.prototype.isCanvasTexture = !0, os.prototype = Object.create(f.prototype), os.prototype.constructor = os, os.prototype.isDepthTexture = !0;
        let as = 0;
        const cs = new Y,
            ls = new _t,
            hs = new x;

        function us() {
            Object.defineProperty(this, "id", {
                value: as += 2
            }), this.uuid = c.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }
        us.prototype = Object.assign(Object.create(s.prototype), {
            constructor: us,
            isGeometry: !0,
            applyMatrix4: function (t) {
                const e = (new h).getNormalMatrix(t);
                for (let e = 0, n = this.vertices.length; e < n; e++) {
                    this.vertices[e].applyMatrix4(t)
                }
                for (let t = 0, n = this.faces.length; t < n; t++) {
                    const n = this.faces[t];
                    n.normal.applyMatrix3(e).normalize();
                    for (let t = 0, i = n.vertexNormals.length; t < i; t++) n.vertexNormals[t].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            },
            rotateX: function (t) {
                return cs.makeRotationX(t), this.applyMatrix4(cs), this
            },
            rotateY: function (t) {
                return cs.makeRotationY(t), this.applyMatrix4(cs), this
            },
            rotateZ: function (t) {
                return cs.makeRotationZ(t), this.applyMatrix4(cs), this
            },
            translate: function (t, e, n) {
                return cs.makeTranslation(t, e, n), this.applyMatrix4(cs), this
            },
            scale: function (t, e, n) {
                return cs.makeScale(t, e, n), this.applyMatrix4(cs), this
            },
            lookAt: function (t) {
                return ls.lookAt(t), ls.updateMatrix(), this.applyMatrix4(ls.matrix), this
            },
            fromBufferGeometry: function (t) {
                const e = this,
                    n = null !== t.index ? t.index : void 0,
                    i = t.attributes;
                if (void 0 === i.position) return this;
                const r = i.position,
                    s = i.normal,
                    o = i.color,
                    a = i.uv,
                    c = i.uv2;
                void 0 !== c && (this.faceVertexUvs[1] = []);
                for (let t = 0; t < r.count; t++) e.vertices.push((new x).fromBufferAttribute(r, t)), void 0 !== o && e.colors.push((new Vt).fromBufferAttribute(o, t));

                function h(t, n, i, r) {
                    const h = void 0 === o ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                        u = void 0 === s ? [] : [(new x).fromBufferAttribute(s, t), (new x).fromBufferAttribute(s, n), (new x).fromBufferAttribute(s, i)],
                        p = new jt(t, n, i, u, h, r);
                    e.faces.push(p), void 0 !== a && e.faceVertexUvs[0].push([(new l).fromBufferAttribute(a, t), (new l).fromBufferAttribute(a, n), (new l).fromBufferAttribute(a, i)]), void 0 !== c && e.faceVertexUvs[1].push([(new l).fromBufferAttribute(c, t), (new l).fromBufferAttribute(c, n), (new l).fromBufferAttribute(c, i)])
                }
                const u = t.groups;
                if (u.length > 0)
                    for (let t = 0; t < u.length; t++) {
                        const e = u[t],
                            i = e.start;
                        for (let t = i, r = i + e.count; t < r; t += 3) void 0 !== n ? h(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex) : h(t, t + 1, t + 2, e.materialIndex)
                    } else if (void 0 !== n)
                        for (let t = 0; t < n.count; t += 3) h(n.getX(t), n.getX(t + 1), n.getX(t + 2));
                    else
                        for (let t = 0; t < r.count; t += 3) h(t, t + 1, t + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(hs).negate(), this.translate(hs.x, hs.y, hs.z), this
            },
            normalize: function () {
                this.computeBoundingSphere();
                const t = this.boundingSphere.center,
                    e = this.boundingSphere.radius,
                    n = 0 === e ? 1 : 1 / e,
                    i = new Y;
                return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
            },
            computeFaceNormals: function () {
                const t = new x,
                    e = new x;
                for (let n = 0, i = this.faces.length; n < i; n++) {
                    const i = this.faces[n],
                        r = this.vertices[i.a],
                        s = this.vertices[i.b],
                        o = this.vertices[i.c];
                    t.subVectors(o, s), e.subVectors(r, s), t.cross(e), t.normalize(), i.normal.copy(t)
                }
            },
            computeVertexNormals: function (t = !0) {
                const e = new Array(this.vertices.length);
                for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new x;
                if (t) {
                    const t = new x,
                        n = new x;
                    for (let i = 0, r = this.faces.length; i < r; i++) {
                        const r = this.faces[i],
                            s = this.vertices[r.a],
                            o = this.vertices[r.b],
                            a = this.vertices[r.c];
                        t.subVectors(a, o), n.subVectors(s, o), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t)
                    }
                } else {
                    this.computeFaceNormals();
                    for (let t = 0, n = this.faces.length; t < n; t++) {
                        const n = this.faces[t];
                        e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal)
                    }
                }
                for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize();
                for (let t = 0, n = this.faces.length; t < n; t++) {
                    const n = this.faces[t],
                        i = n.vertexNormals;
                    3 === i.length ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c])) : (i[0] = e[n.a].clone(), i[1] = e[n.b].clone(), i[2] = e[n.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function () {
                this.computeFaceNormals();
                for (let t = 0, e = this.faces.length; t < e; t++) {
                    const e = this.faces[t],
                        n = e.vertexNormals;
                    3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function () {
                for (let t = 0, e = this.faces.length; t < e; t++) {
                    const e = this.faces[t];
                    e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []);
                    for (let t = 0, n = e.vertexNormals.length; t < n; t++) e.__originalVertexNormals[t] ? e.__originalVertexNormals[t].copy(e.vertexNormals[t]) : e.__originalVertexNormals[t] = e.vertexNormals[t].clone()
                }
                const t = new us;
                t.faces = this.faces;
                for (let e = 0, n = this.morphTargets.length; e < n; e++) {
                    if (!this.morphNormals[e]) {
                        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                        const t = this.morphNormals[e].faceNormals,
                            n = this.morphNormals[e].vertexNormals;
                        for (let e = 0, i = this.faces.length; e < i; e++) {
                            const e = new x,
                                i = {
                                    a: new x,
                                    b: new x,
                                    c: new x
                                };
                            t.push(e), n.push(i)
                        }
                    }
                    const n = this.morphNormals[e];
                    t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
                    for (let t = 0, e = this.faces.length; t < e; t++) {
                        const e = this.faces[t],
                            i = n.faceNormals[t],
                            r = n.vertexNormals[t];
                        i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2])
                    }
                }
                for (let t = 0, e = this.faces.length; t < e; t++) {
                    const e = this.faces[t];
                    e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
                }
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new w), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new B), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function (t, e, n = 0) {
                if (!t || !t.isGeometry) return;
                let i;
                const r = this.vertices.length,
                    s = this.vertices,
                    o = t.vertices,
                    a = this.faces,
                    c = t.faces,
                    l = this.colors,
                    u = t.colors;
                void 0 !== e && (i = (new h).getNormalMatrix(e));
                for (let t = 0, n = o.length; t < n; t++) {
                    const n = o[t].clone();
                    void 0 !== e && n.applyMatrix4(e), s.push(n)
                }
                for (let t = 0, e = u.length; t < e; t++) l.push(u[t].clone());
                for (let t = 0, e = c.length; t < e; t++) {
                    const e = c[t];
                    let s, o;
                    const l = e.vertexNormals,
                        h = e.vertexColors,
                        u = new jt(e.a + r, e.b + r, e.c + r);
                    u.normal.copy(e.normal), void 0 !== i && u.normal.applyMatrix3(i).normalize();
                    for (let t = 0, e = l.length; t < e; t++) s = l[t].clone(), void 0 !== i && s.applyMatrix3(i).normalize(), u.vertexNormals.push(s);
                    u.color.copy(e.color);
                    for (let t = 0, e = h.length; t < e; t++) o = h[t], u.vertexColors.push(o.clone());
                    u.materialIndex = e.materialIndex + n, a.push(u)
                }
                for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                    const n = t.faceVertexUvs[e];
                    void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t],
                            r = [];
                        for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone());
                        this.faceVertexUvs[e].push(r)
                    }
                }
            },
            mergeMesh: function (t) {
                t && t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
            },
            mergeVertices: function (t = 4) {
                const e = {},
                    n = [],
                    i = [],
                    r = Math.pow(10, t);
                for (let t = 0, s = this.vertices.length; t < s; t++) {
                    const s = this.vertices[t],
                        o = Math.round(s.x * r) + "_" + Math.round(s.y * r) + "_" + Math.round(s.z * r);
                    void 0 === e[o] ? (e[o] = t, n.push(this.vertices[t]), i[t] = n.length - 1) : i[t] = i[e[o]]
                }
                const s = [];
                for (let t = 0, e = this.faces.length; t < e; t++) {
                    const e = this.faces[t];
                    e.a = i[e.a], e.b = i[e.b], e.c = i[e.c];
                    const n = [e.a, e.b, e.c];
                    for (let e = 0; e < 3; e++)
                        if (n[e] === n[(e + 1) % 3]) {
                            s.push(t);
                            break
                        }
                }
                for (let t = s.length - 1; t >= 0; t--) {
                    const e = s[t];
                    this.faces.splice(e, 1);
                    for (let t = 0, n = this.faceVertexUvs.length; t < n; t++) this.faceVertexUvs[t].splice(e, 1)
                }
                const o = this.vertices.length - n.length;
                return this.vertices = n, o
            },
            setFromPoints: function (t) {
                this.vertices = [];
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    this.vertices.push(new x(n.x, n.y, n.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function () {
                const t = this.faces,
                    e = t.length;
                for (let n = 0; n < e; n++) t[n]._id = n;
                t.sort((function (t, e) {
                    return t.materialIndex - e.materialIndex
                }));
                const n = this.faceVertexUvs[0],
                    i = this.faceVertexUvs[1];
                let r, s;
                n && n.length === e && (r = []), i && i.length === e && (s = []);
                for (let o = 0; o < e; o++) {
                    const e = t[o]._id;
                    r && r.push(n[e]), s && s.push(i[e])
                }
                r && (this.faceVertexUvs[0] = r), s && (this.faceVertexUvs[1] = s)
            },
            toJSON: function () {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                const e = [];
                for (let t = 0; t < this.vertices.length; t++) {
                    const n = this.vertices[t];
                    e.push(n.x, n.y, n.z)
                }
                const n = [],
                    i = [],
                    r = {},
                    s = [],
                    o = {},
                    a = [],
                    c = {};
                for (let t = 0; t < this.faces.length; t++) {
                    const e = this.faces[t],
                        i = !0,
                        r = !1,
                        s = void 0 !== this.faceVertexUvs[0][t],
                        o = e.normal.length() > 0,
                        a = e.vertexNormals.length > 0,
                        c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
                        d = e.vertexColors.length > 0;
                    let f = 0;
                    if (f = l(f, 0, 0), f = l(f, 1, i), f = l(f, 2, r), f = l(f, 3, s), f = l(f, 4, o), f = l(f, 5, a), f = l(f, 6, c), f = l(f, 7, d), n.push(f), n.push(e.a, e.b, e.c), n.push(e.materialIndex), s) {
                        const e = this.faceVertexUvs[0][t];
                        n.push(p(e[0]), p(e[1]), p(e[2]))
                    }
                    if (o && n.push(h(e.normal)), a) {
                        const t = e.vertexNormals;
                        n.push(h(t[0]), h(t[1]), h(t[2]))
                    }
                    if (c && n.push(u(e.color)), d) {
                        const t = e.vertexColors;
                        n.push(u(t[0]), u(t[1]), u(t[2]))
                    }
                }

                function l(t, e, n) {
                    return n ? t | 1 << e : t & ~(1 << e)
                }

                function h(t) {
                    const e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== r[e] || (r[e] = i.length / 3, i.push(t.x, t.y, t.z)), r[e]
                }

                function u(t) {
                    const e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== o[e] || (o[e] = s.length, s.push(t.getHex())), o[e]
                }

                function p(t) {
                    const e = t.x.toString() + t.y.toString();
                    return void 0 !== c[e] || (c[e] = a.length / 2, a.push(t.x, t.y)), c[e]
                }
                return t.data = {}, t.data.vertices = e, t.data.normals = i, s.length > 0 && (t.data.colors = s), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t
            },
            clone: function () {
                return (new us).copy(this)
            },
            copy: function (t) {
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                const e = t.vertices;
                for (let t = 0, n = e.length; t < n; t++) this.vertices.push(e[t].clone());
                const n = t.colors;
                for (let t = 0, e = n.length; t < e; t++) this.colors.push(n[t].clone());
                const i = t.faces;
                for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone());
                for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                    const n = t.faceVertexUvs[e];
                    void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t],
                            r = [];
                        for (let t = 0, e = i.length; t < e; t++) {
                            const e = i[t];
                            r.push(e.clone())
                        }
                        this.faceVertexUvs[e].push(r)
                    }
                }
                const r = t.morphTargets;
                for (let t = 0, e = r.length; t < e; t++) {
                    const e = {};
                    if (e.name = r[t].name, void 0 !== r[t].vertices) {
                        e.vertices = [];
                        for (let n = 0, i = r[t].vertices.length; n < i; n++) e.vertices.push(r[t].vertices[n].clone())
                    }
                    if (void 0 !== r[t].normals) {
                        e.normals = [];
                        for (let n = 0, i = r[t].normals.length; n < i; n++) e.normals.push(r[t].normals[n].clone())
                    }
                    this.morphTargets.push(e)
                }
                const s = t.morphNormals;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = {};
                    if (void 0 !== s[t].vertexNormals) {
                        e.vertexNormals = [];
                        for (let n = 0, i = s[t].vertexNormals.length; n < i; n++) {
                            const i = s[t].vertexNormals[n],
                                r = {};
                            r.a = i.a.clone(), r.b = i.b.clone(), r.c = i.c.clone(), e.vertexNormals.push(r)
                        }
                    }
                    if (void 0 !== s[t].faceNormals) {
                        e.faceNormals = [];
                        for (let n = 0, i = s[t].faceNormals.length; n < i; n++) e.faceNormals.push(s[t].faceNormals[n].clone())
                    }
                    this.morphNormals.push(e)
                }
                const o = t.skinWeights;
                for (let t = 0, e = o.length; t < e; t++) this.skinWeights.push(o[t].clone());
                const a = t.skinIndices;
                for (let t = 0, e = a.length; t < e; t++) this.skinIndices.push(a[t].clone());
                const c = t.lineDistances;
                for (let t = 0, e = c.length; t < e; t++) this.lineDistances.push(c[t]);
                const l = t.boundingBox;
                null !== l && (this.boundingBox = l.clone());
                const h = t.boundingSphere;
                return null !== h && (this.boundingSphere = h.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        new x, new x, new x, new It;
        const ps = function (t, e, n) {
            n = n || 2;
            const i = e && e.length,
                r = i ? e[0] * n : t.length;
            let s = ds(t, 0, r, n, !0);
            const o = [];
            if (!s || s.next === s.prev) return o;
            let a, c, l, h, u, p, d;
            if (i && (s = function (t, e, n, i) {
                    const r = [];
                    let s, o, a, c, l;
                    for (s = 0, o = e.length; s < o; s++) a = e[s] * i, c = s < o - 1 ? e[s + 1] * i : t.length, l = ds(t, a, c, i, !1), l === l.next && (l.steiner = !0), r.push(Ss(l));
                    for (r.sort(xs), s = 0; s < r.length; s++) bs(r[s], n), n = fs(n, n.next);
                    return n
                }(t, e, s, n)), t.length > 80 * n) {
                a = l = t[0], c = h = t[1];
                for (let e = n; e < r; e += n) u = t[e], p = t[e + 1], u < a && (a = u), p < c && (c = p), u > l && (l = u), p > h && (h = p);
                d = Math.max(l - a, h - c), d = 0 !== d ? 1 / d : 0
            }
            return ms(s, o, n, a, c, d), o
        };

        function ds(t, e, n, i, r) {
            let s, o;
            if (r === function (t, e, n, i) {
                    let r = 0;
                    for (let s = e, o = n - i; s < n; s += i) r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
                    return r
                }(t, e, n, i) > 0)
                for (s = e; s < n; s += i) o = Is(s, t[s], t[s + 1], o);
            else
                for (s = n - i; s >= e; s -= i) o = Is(s, t[s], t[s + 1], o);
            return o && Cs(o, o.next) && (zs(o), o = o.next), o
        }

        function fs(t, e) {
            if (!t) return t;
            e || (e = t);
            let n, i = t;
            do {
                if (n = !1, i.steiner || !Cs(i, i.next) && 0 !== Ls(i.prev, i, i.next)) i = i.next;
                else {
                    if (zs(i), i = e = i.prev, i === i.next) break;
                    n = !0
                }
            } while (n || i !== e);
            return e
        }

        function ms(t, e, n, i, r, s, o) {
            if (!t) return;
            !o && s && function (t, e, n, i) {
                let r = t;
                do {
                    null === r.z && (r.z = ws(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null, r.prevZ = null,
                    function (t) {
                        let e, n, i, r, s, o, a, c, l = 1;
                        do {
                            for (n = t, t = null, s = null, o = 0; n;) {
                                for (o++, i = n, a = 0, e = 0; e < l && (a++, i = i.nextZ, i); e++);
                                for (c = l; a > 0 || c > 0 && i;) 0 !== a && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, c--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                n = i
                            }
                            s.nextZ = null, l *= 2
                        } while (o > 1)
                    }(r)
            }(t, i, r, s);
            let a, c, l = t;
            for (; t.prev !== t.next;)
                if (a = t.prev, c = t.next, s ? vs(t, i, r, s) : gs(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), zs(t), t = c.next, l = c.next;
                else if ((t = c) === l) {
                o ? 1 === o ? ms(t = ys(fs(t), e, n), e, n, i, r, s, 2) : 2 === o && _s(t, e, n, i, r, s) : ms(fs(t), e, n, i, r, s, 1);
                break
            }
        }

        function gs(t) {
            const e = t.prev,
                n = t,
                i = t.next;
            if (Ls(e, n, i) >= 0) return !1;
            let r = t.next.next;
            for (; r !== t.prev;) {
                if (Ts(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Ls(r.prev, r, r.next) >= 0) return !1;
                r = r.next
            }
            return !0
        }

        function vs(t, e, n, i) {
            const r = t.prev,
                s = t,
                o = t.next;
            if (Ls(r, s, o) >= 0) return !1;
            const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x,
                c = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y,
                l = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x,
                h = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y,
                u = ws(a, c, e, n, i),
                p = ws(l, h, e, n, i);
            let d = t.prevZ,
                f = t.nextZ;
            for (; d && d.z >= u && f && f.z <= p;) {
                if (d !== t.prev && d !== t.next && Ts(r.x, r.y, s.x, s.y, o.x, o.y, d.x, d.y) && Ls(d.prev, d, d.next) >= 0) return !1;
                if (d = d.prevZ, f !== t.prev && f !== t.next && Ts(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Ls(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            for (; d && d.z >= u;) {
                if (d !== t.prev && d !== t.next && Ts(r.x, r.y, s.x, s.y, o.x, o.y, d.x, d.y) && Ls(d.prev, d, d.next) >= 0) return !1;
                d = d.prevZ
            }
            for (; f && f.z <= p;) {
                if (f !== t.prev && f !== t.next && Ts(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Ls(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            return !0
        }

        function ys(t, e, n) {
            let i = t;
            do {
                const r = i.prev,
                    s = i.next.next;
                !Cs(r, s) && Ps(r, i, i.next, s) && Os(r, s) && Os(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), zs(i), zs(i.next), i = t = s), i = i.next
            } while (i !== t);
            return fs(i)
        }

        function _s(t, e, n, i, r, s) {
            let o = t;
            do {
                let t = o.next.next;
                for (; t !== o.prev;) {
                    if (o.i !== t.i && As(o, t)) {
                        let a = Ds(o, t);
                        return o = fs(o, o.next), a = fs(a, a.next), ms(o, e, n, i, r, s), void ms(a, e, n, i, r, s)
                    }
                    t = t.next
                }
                o = o.next
            } while (o !== t)
        }

        function xs(t, e) {
            return t.x - e.x
        }

        function bs(t, e) {
            if (e = function (t, e) {
                    let n = e;
                    const i = t.x,
                        r = t.y;
                    let s, o = -1 / 0;
                    do {
                        if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                            const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (t <= i && t > o) {
                                if (o = t, t === i) {
                                    if (r === n.y) return n;
                                    if (r === n.next.y) return n.next
                                }
                                s = n.x < n.next.x ? n : n.next
                            }
                        }
                        n = n.next
                    } while (n !== e);
                    if (!s) return null;
                    if (i === o) return s;
                    const a = s,
                        c = s.x,
                        l = s.y;
                    let h, u = 1 / 0;
                    n = s;
                    do {
                        i >= n.x && n.x >= c && i !== n.x && Ts(r < l ? i : o, r, c, l, r < l ? o : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Os(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Ms(s, n))) && (s = n, u = h)), n = n.next
                    } while (n !== a);
                    return s
                }(t, e)) {
                const n = Ds(e, t);
                fs(e, e.next), fs(n, n.next)
            }
        }

        function Ms(t, e) {
            return Ls(t.prev, t, e.prev) < 0 && Ls(e.next, t, t.next) < 0
        }

        function ws(t, e, n, i, r) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function Ss(t) {
            let e = t,
                n = t;
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
            } while (e !== t);
            return n
        }

        function Ts(t, e, n, i, r, s, o, a) {
            return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0
        }

        function As(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && ! function (t, e) {
                let n = t;
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Ps(n, n.next, t, e)) return !0;
                    n = n.next
                } while (n !== t);
                return !1
            }(t, e) && (Os(t, e) && Os(e, t) && function (t, e) {
                let n = t,
                    i = !1;
                const r = (t.x + e.x) / 2,
                    s = (t.y + e.y) / 2;
                do {
                    n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                } while (n !== t);
                return i
            }(t, e) && (Ls(t.prev, t, e.prev) || Ls(t, e.prev, e)) || Cs(t, e) && Ls(t.prev, t, t.next) > 0 && Ls(e.prev, e, e.next) > 0)
        }

        function Ls(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }

        function Cs(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function Ps(t, e, n, i) {
            const r = Ns(Ls(t, e, n)),
                s = Ns(Ls(t, e, i)),
                o = Ns(Ls(n, i, t)),
                a = Ns(Ls(n, i, e));
            return r !== s && o !== a || (!(0 !== r || !Es(t, n, e)) || (!(0 !== s || !Es(t, i, e)) || (!(0 !== o || !Es(n, t, i)) || !(0 !== a || !Es(n, e, i)))))
        }

        function Es(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }

        function Ns(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }

        function Os(t, e) {
            return Ls(t.prev, t, t.next) < 0 ? Ls(t, e, t.next) >= 0 && Ls(t, t.prev, e) >= 0 : Ls(t, e, t.prev) < 0 || Ls(t, t.next, e) < 0
        }

        function Ds(t, e) {
            const n = new Rs(t.i, t.x, t.y),
                i = new Rs(e.i, e.x, e.y),
                r = t.next,
                s = e.prev;
            return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
        }

        function Is(t, e, n, i) {
            const r = new Rs(t, e, n);
            return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
        }

        function zs(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function Rs(t, e, n) {
            this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        const Fs = {
            area: function (t) {
                const e = t.length;
                let n = 0;
                for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                return .5 * n
            },
            isClockWise: function (t) {
                return Fs.area(t) < 0
            },
            triangulateShape: function (t, e) {
                const n = [],
                    i = [],
                    r = [];
                Us(t), Bs(n, t);
                let s = t.length;
                e.forEach(Us);
                for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, Bs(n, e[t]);
                const o = ps(n, i);
                for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3));
                return r
            }
        };

        function Us(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }

        function Bs(t, e) {
            for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
        }
        class ks extends ge {
            constructor(t, e) {
                super(), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, t = Array.isArray(t) ? t : [t];
                const n = this,
                    i = [],
                    r = [];
                for (let e = 0, n = t.length; e < n; e++) {
                    s(t[e])
                }

                function s(t) {
                    const s = [],
                        o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        a = void 0 !== e.steps ? e.steps : 1;
                    let c = void 0 !== e.depth ? e.depth : 100,
                        h = void 0 === e.bevelEnabled || e.bevelEnabled,
                        u = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        p = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
                        d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                        f = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const m = e.extrudePath,
                        g = void 0 !== e.UVGenerator ? e.UVGenerator : Vs;
                    void 0 !== e.amount && (c = e.amount);
                    let v, y, _, b, M, w = !1;
                    m && (v = m.getSpacedPoints(a), w = !0, h = !1, y = m.computeFrenetFrames(a, !1), _ = new x, b = new x, M = new x), h || (f = 0, u = 0, p = 0, d = 0);
                    const S = t.extractPoints(o);
                    let T = S.shape;
                    const A = S.holes;
                    if (!Fs.isClockWise(T)) {
                        T = T.reverse();
                        for (let t = 0, e = A.length; t < e; t++) {
                            const e = A[t];
                            Fs.isClockWise(e) && (A[t] = e.reverse())
                        }
                    }
                    const L = Fs.triangulateShape(T, A),
                        C = T;
                    for (let t = 0, e = A.length; t < e; t++) {
                        const e = A[t];
                        T = T.concat(e)
                    }

                    function P(t, e, n) {
                        return e.clone().multiplyScalar(n).add(t)
                    }
                    const E = T.length,
                        N = L.length;

                    function O(t, e, n) {
                        let i, r, s;
                        const o = t.x - e.x,
                            a = t.y - e.y,
                            c = n.x - t.x,
                            h = n.y - t.y,
                            u = o * o + a * a,
                            p = o * h - a * c;
                        if (Math.abs(p) > Number.EPSILON) {
                            const p = Math.sqrt(u),
                                d = Math.sqrt(c * c + h * h),
                                f = e.x - a / p,
                                m = e.y + o / p,
                                g = ((n.x - h / d - f) * h - (n.y + c / d - m) * c) / (o * h - a * c);
                            i = f + o * g - t.x, r = m + a * g - t.y;
                            const v = i * i + r * r;
                            if (v <= 2) return new l(i, r);
                            s = Math.sqrt(v / 2)
                        } else {
                            let t = !1;
                            o > Number.EPSILON ? c > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(h) && (t = !0), t ? (i = -a, r = o, s = Math.sqrt(u)) : (i = o, r = a, s = Math.sqrt(u / 2))
                        }
                        return new l(i / s, r / s)
                    }
                    const D = [];
                    for (let t = 0, e = C.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), D[t] = O(C[t], C[n], C[i]);
                    const I = [];
                    let z, R = D.concat();
                    for (let t = 0, e = A.length; t < e; t++) {
                        const e = A[t];
                        z = [];
                        for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), z[t] = O(e[t], e[i], e[r]);
                        I.push(z), R = R.concat(z)
                    }
                    for (let t = 0; t < f; t++) {
                        const e = t / f,
                            n = u * Math.cos(e * Math.PI / 2),
                            i = p * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = C.length; t < e; t++) {
                            const e = P(C[t], D[t], i);
                            B(e.x, e.y, -n)
                        }
                        for (let t = 0, e = A.length; t < e; t++) {
                            const e = A[t];
                            z = I[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = P(e[t], z[t], i);
                                B(r.x, r.y, -n)
                            }
                        }
                    }
                    const F = p + d;
                    for (let t = 0; t < E; t++) {
                        const e = h ? P(T[t], R[t], F) : T[t];
                        w ? (b.copy(y.normals[0]).multiplyScalar(e.x), _.copy(y.binormals[0]).multiplyScalar(e.y), M.copy(v[0]).add(b).add(_), B(M.x, M.y, M.z)) : B(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= a; t++)
                        for (let e = 0; e < E; e++) {
                            const n = h ? P(T[e], R[e], F) : T[e];
                            w ? (b.copy(y.normals[t]).multiplyScalar(n.x), _.copy(y.binormals[t]).multiplyScalar(n.y), M.copy(v[t]).add(b).add(_), B(M.x, M.y, M.z)) : B(n.x, n.y, c / a * t)
                        }
                    for (let t = f - 1; t >= 0; t--) {
                        const e = t / f,
                            n = u * Math.cos(e * Math.PI / 2),
                            i = p * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = C.length; t < e; t++) {
                            const e = P(C[t], D[t], i);
                            B(e.x, e.y, c + n)
                        }
                        for (let t = 0, e = A.length; t < e; t++) {
                            const e = A[t];
                            z = I[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = P(e[t], z[t], i);
                                w ? B(r.x, r.y + v[a - 1].y, v[a - 1].x + n) : B(r.x, r.y, c + n)
                            }
                        }
                    }

                    function U(t, e) {
                        let n = t.length;
                        for (; --n >= 0;) {
                            const i = n;
                            let r = n - 1;
                            r < 0 && (r = t.length - 1);
                            for (let t = 0, n = a + 2 * f; t < n; t++) {
                                const n = E * t,
                                    s = E * (t + 1);
                                V(e + i + n, e + r + n, e + r + s, e + i + s)
                            }
                        }
                    }

                    function B(t, e, n) {
                        s.push(t), s.push(e), s.push(n)
                    }

                    function k(t, e, r) {
                        j(t), j(e), j(r);
                        const s = i.length / 3,
                            o = g.generateTopUV(n, i, s - 3, s - 2, s - 1);
                        G(o[0]), G(o[1]), G(o[2])
                    }

                    function V(t, e, r, s) {
                        j(t), j(e), j(s), j(e), j(r), j(s);
                        const o = i.length / 3,
                            a = g.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                        G(a[0]), G(a[1]), G(a[3]), G(a[1]), G(a[2]), G(a[3])
                    }

                    function j(t) {
                        i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2])
                    }

                    function G(t) {
                        r.push(t.x), r.push(t.y)
                    }! function () {
                        const t = i.length / 3;
                        if (h) {
                            let t = 0,
                                e = E * t;
                            for (let t = 0; t < N; t++) {
                                const n = L[t];
                                k(n[2] + e, n[1] + e, n[0] + e)
                            }
                            t = a + 2 * f, e = E * t;
                            for (let t = 0; t < N; t++) {
                                const n = L[t];
                                k(n[0] + e, n[1] + e, n[2] + e)
                            }
                        } else {
                            for (let t = 0; t < N; t++) {
                                const e = L[t];
                                k(e[2], e[1], e[0])
                            }
                            for (let t = 0; t < N; t++) {
                                const e = L[t];
                                k(e[0] + E * a, e[1] + E * a, e[2] + E * a)
                            }
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }(),
                    function () {
                        const t = i.length / 3;
                        let e = 0;
                        U(C, e), e += C.length;
                        for (let t = 0, n = A.length; t < n; t++) {
                            const n = A[t];
                            U(n, e), e += n.length
                        }
                        n.addGroup(t, i.length / 3 - t, 1)
                    }()
                }
                this.setAttribute("position", new ie(i, 3)), this.setAttribute("uv", new ie(r, 2)), this.computeVertexNormals()
            }
            toJSON() {
                const t = ge.prototype.toJSON.call(this);
                return function (t, e, n) {
                    if (n.shapes = [], Array.isArray(t))
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e];
                            n.shapes.push(i.uuid)
                        } else n.shapes.push(t.uuid);
                    void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                    return n
                }(this.parameters.shapes, this.parameters.options, t)
            }
        }
        const Vs = {
            generateTopUV: function (t, e, n, i, r) {
                const s = e[3 * n],
                    o = e[3 * n + 1],
                    a = e[3 * i],
                    c = e[3 * i + 1],
                    h = e[3 * r],
                    u = e[3 * r + 1];
                return [new l(s, o), new l(a, c), new l(h, u)]
            },
            generateSideWallUV: function (t, e, n, i, r, s) {
                const o = e[3 * n],
                    a = e[3 * n + 1],
                    c = e[3 * n + 2],
                    h = e[3 * i],
                    u = e[3 * i + 1],
                    p = e[3 * i + 2],
                    d = e[3 * r],
                    f = e[3 * r + 1],
                    m = e[3 * r + 2],
                    g = e[3 * s],
                    v = e[3 * s + 1],
                    y = e[3 * s + 2];
                return Math.abs(a - u) < .01 ? [new l(o, 1 - c), new l(h, 1 - p), new l(d, 1 - m), new l(g, 1 - y)] : [new l(a, 1 - c), new l(u, 1 - p), new l(f, 1 - m), new l(v, 1 - y)]
            }
        };
        class js extends us {
            constructor(t, e) {
                super(), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new ks(t, e)), this.mergeVertices()
            }
            toJSON() {
                const t = super.toJSON();
                return function (t, e, n) {
                    if (n.shapes = [], Array.isArray(t))
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e];
                            n.shapes.push(i.uuid)
                        } else n.shapes.push(t.uuid);
                    void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                    return n
                }(this.parameters.shapes, this.parameters.options, t)
            }
        }

        function Gs(t, e, n) {
            ge.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: n
            };
            const i = [],
                r = [],
                s = [],
                o = [],
                a = 1e-5,
                c = new x,
                l = new x,
                h = new x,
                u = new x,
                p = new x;
            t.length;
            const d = e + 1;
            for (let i = 0; i <= n; i++) {
                const d = i / n;
                for (let n = 0; n <= e; n++) {
                    const i = n / e;
                    t(i, d, l), r.push(l.x, l.y, l.z), i - a >= 0 ? (t(i - a, d, h), u.subVectors(l, h)) : (t(i + a, d, h), u.subVectors(h, l)), d - a >= 0 ? (t(i, d - a, h), p.subVectors(l, h)) : (t(i, d + a, h), p.subVectors(h, l)), c.crossVectors(u, p).normalize(), s.push(c.x, c.y, c.z), o.push(i, d)
                }
            }
            for (let t = 0; t < n; t++)
                for (let n = 0; n < e; n++) {
                    const e = t * d + n,
                        r = t * d + n + 1,
                        s = (t + 1) * d + n + 1,
                        o = (t + 1) * d + n;
                    i.push(e, r, o), i.push(r, s, o)
                }
            this.setIndex(i), this.setAttribute("position", new ie(r, 3)), this.setAttribute("normal", new ie(s, 3)), this.setAttribute("uv", new ie(o, 2))
        }

        function Ws(t, e, n) {
            us.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: n
            }, this.fromBufferGeometry(new Gs(t, e, n)), this.mergeVertices()
        }
        Gs.prototype = Object.create(ge.prototype), Gs.prototype.constructor = Gs, Ws.prototype = Object.create(us.prototype), Ws.prototype.constructor = Ws;
        class Hs extends ge {
            constructor(t, e = 12) {
                super(), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                };
                const n = [],
                    i = [],
                    r = [],
                    s = [];
                let o = 0,
                    a = 0;
                if (!1 === Array.isArray(t)) c(t);
                else
                    for (let e = 0; e < t.length; e++) c(t[e]), this.addGroup(o, a, e), o += a, a = 0;

                function c(t) {
                    const o = i.length / 3,
                        c = t.extractPoints(e);
                    let l = c.shape;
                    const h = c.holes;
                    !1 === Fs.isClockWise(l) && (l = l.reverse());
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t];
                        !0 === Fs.isClockWise(e) && (h[t] = e.reverse())
                    }
                    const u = Fs.triangulateShape(l, h);
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t];
                        l = l.concat(e)
                    }
                    for (let t = 0, e = l.length; t < e; t++) {
                        const e = l[t];
                        i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
                    }
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t],
                            i = e[0] + o,
                            r = e[1] + o,
                            s = e[2] + o;
                        n.push(i, r, s), a += 3
                    }
                }
                this.setIndex(n), this.setAttribute("position", new ie(i, 3)), this.setAttribute("normal", new ie(r, 3)), this.setAttribute("uv", new ie(s, 2))
            }
            toJSON() {
                const t = ge.prototype.toJSON.call(this);
                return function (t, e) {
                    if (e.shapes = [], Array.isArray(t))
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.shapes.push(i.uuid)
                        } else e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }
        }
        class qs extends us {
            constructor(t, e) {
                super(), this.type = "ShapeGeometry", "object" == typeof e && (e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new Hs(t, e)), this.mergeVertices()
            }
            toJSON() {
                const t = us.prototype.toJSON.call(this);
                return function (t, e) {
                    if (e.shapes = [], Array.isArray(t))
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.shapes.push(i.uuid)
                        } else e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }
        }

        function Xs(t) {
            Wt.call(this), this.type = "ShadowMaterial", this.color = new Vt(0), this.transparent = !0, this.setValues(t)
        }

        function Ys(t) {
            Ve.call(this, t), this.type = "RawShaderMaterial"
        }

        function Zs(t) {
            Wt.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new Vt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t)
        }

        function Js(t) {
            Zs.call(this), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new l(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                get: function () {
                    return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                },
                set: function (t) {
                    this.reflectivity = c.clamp(2.5 * (t - 1) / (t + 1), 0, 1)
                }
            }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
        }

        function Qs(t) {
            Wt.call(this), this.type = "MeshPhongMaterial", this.color = new Vt(16777215), this.specular = new Vt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Ks(t) {
            Wt.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.color = new Vt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function $s(t) {
            Wt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function to(t) {
            Wt.call(this), this.type = "MeshLambertMaterial", this.color = new Vt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function eo(t) {
            Wt.call(this), this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new Vt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function no(t) {
            Br.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
        }
        Xs.prototype = Object.create(Wt.prototype), Xs.prototype.constructor = Xs, Xs.prototype.isShadowMaterial = !0, Xs.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this
        }, Ys.prototype = Object.create(Ve.prototype), Ys.prototype.constructor = Ys, Ys.prototype.isRawShaderMaterial = !0, Zs.prototype = Object.create(Wt.prototype), Zs.prototype.constructor = Zs, Zs.prototype.isMeshStandardMaterial = !0, Zs.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this
        }, Js.prototype = Object.create(Zs.prototype), Js.prototype.constructor = Js, Js.prototype.isMeshPhysicalMaterial = !0, Js.prototype.copy = function (t) {
            return Zs.prototype.copy.call(this, t), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Vt).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
        }, Qs.prototype = Object.create(Wt.prototype), Qs.prototype.constructor = Qs, Qs.prototype.isMeshPhongMaterial = !0, Qs.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, Ks.prototype = Object.create(Wt.prototype), Ks.prototype.constructor = Ks, Ks.prototype.isMeshToonMaterial = !0, Ks.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, $s.prototype = Object.create(Wt.prototype), $s.prototype.constructor = $s, $s.prototype.isMeshNormalMaterial = !0, $s.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, to.prototype = Object.create(Wt.prototype), to.prototype.constructor = to, to.prototype.isMeshLambertMaterial = !0, to.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, eo.prototype = Object.create(Wt.prototype), eo.prototype.constructor = eo, eo.prototype.isMeshMatcapMaterial = !0, eo.prototype.copy = function (t) {
            return Wt.prototype.copy.call(this, t), this.defines = {
                MATCAP: ""
            }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, no.prototype = Object.create(Br.prototype), no.prototype.constructor = no, no.prototype.isLineDashedMaterial = !0, no.prototype.copy = function (t) {
            return Br.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var io = Object.freeze({
            __proto__: null,
            ShadowMaterial: Xs,
            SpriteMaterial: hr,
            RawShaderMaterial: Ys,
            ShaderMaterial: Ve,
            PointsMaterial: Jr,
            MeshPhysicalMaterial: Js,
            MeshStandardMaterial: Zs,
            MeshPhongMaterial: Qs,
            MeshToonMaterial: Ks,
            MeshNormalMaterial: $s,
            MeshLambertMaterial: to,
            MeshDepthMaterial: Xi,
            MeshDistanceMaterial: Yi,
            MeshBasicMaterial: Ht,
            MeshMatcapMaterial: eo,
            LineDashedMaterial: no,
            LineBasicMaterial: Br,
            Material: Wt
        });
        const ro = {
            arraySlice: function (t, e, n) {
                return ro.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function (t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function (t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function (t) {
                const e = t.length,
                    n = new Array(e);
                for (let t = 0; t !== e; ++t) n[t] = t;
                return n.sort((function (e, n) {
                    return t[e] - t[n]
                })), n
            },
            sortedArray: function (t, e, n) {
                const i = t.length,
                    r = new t.constructor(i);
                for (let s = 0, o = 0; o !== i; ++s) {
                    const i = n[s] * e;
                    for (let n = 0; n !== e; ++n) r[o++] = t[i + n]
                }
                return r
            },
            flattenJSON: function (t, e, n, i) {
                let r = 1,
                    s = t[0];
                for (; void 0 !== s && void 0 === s[i];) s = t[r++];
                if (void 0 === s) return;
                let o = s[i];
                if (void 0 !== o)
                    if (Array.isArray(o))
                        do {
                            o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== o.toArray)
                    do {
                        o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++]
                    } while (void 0 !== s);
                else
                    do {
                        o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++]
                    } while (void 0 !== s)
            },
            subclip: function (t, e, n, i, r = 30) {
                const s = t.clone();
                s.name = e;
                const o = [];
                for (let t = 0; t < s.tracks.length; ++t) {
                    const e = s.tracks[t],
                        a = e.getValueSize(),
                        c = [],
                        l = [];
                    for (let t = 0; t < e.times.length; ++t) {
                        const s = e.times[t] * r;
                        if (!(s < n || s >= i)) {
                            c.push(e.times[t]);
                            for (let n = 0; n < a; ++n) l.push(e.values[t * a + n])
                        }
                    }
                    0 !== c.length && (e.times = ro.convertArray(c, e.times.constructor), e.values = ro.convertArray(l, e.values.constructor), o.push(e))
                }
                s.tracks = o;
                let a = 1 / 0;
                for (let t = 0; t < s.tracks.length; ++t) a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
                for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a);
                return s.resetDuration(), s
            },
            makeClipAdditive: function (t, e = 0, n = t, i = 30) {
                i <= 0 && (i = 30);
                const r = n.tracks.length,
                    s = e / i;
                for (let e = 0; e < r; ++e) {
                    const i = n.tracks[e],
                        r = i.ValueTypeName;
                    if ("bool" === r || "string" === r) continue;
                    const o = t.tracks.find((function (t) {
                        return t.name === i.name && t.ValueTypeName === r
                    }));
                    if (void 0 === o) continue;
                    let a = 0;
                    const c = i.getValueSize();
                    i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = c / 3);
                    let l = 0;
                    const h = o.getValueSize();
                    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = h / 3);
                    const u = i.times.length - 1;
                    let p;
                    if (s <= i.times[0]) {
                        const t = a,
                            e = c - a;
                        p = ro.arraySlice(i.values, t, e)
                    } else if (s >= i.times[u]) {
                        const t = u * c + a,
                            e = t + c - a;
                        p = ro.arraySlice(i.values, t, e)
                    } else {
                        const t = i.createInterpolant(),
                            e = a,
                            n = c - a;
                        t.evaluate(s), p = ro.arraySlice(t.resultBuffer, e, n)
                    }
                    if ("quaternion" === r) {
                        (new _).fromArray(p).normalize().conjugate().toArray(p)
                    }
                    const d = o.times.length;
                    for (let t = 0; t < d; ++t) {
                        const e = t * h + l;
                        if ("quaternion" === r) _.multiplyQuaternionsFlat(o.values, e, p, 0, o.values, e);
                        else {
                            const t = h - 2 * l;
                            for (let n = 0; n < t; ++n) o.values[e + n] -= p[n]
                        }
                    }
                }
                return t.blendMode = 2501, t
            }
        };

        function so(t, e, n, i) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
        }

        function oo(t, e, n, i) {
            so.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function ao(t, e, n, i) {
            so.call(this, t, e, n, i)
        }

        function co(t, e, n, i) {
            so.call(this, t, e, n, i)
        }

        function lo(t, e, n, i) {
            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = ro.convertArray(e, this.TimeBufferType), this.values = ro.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
        }

        function ho(t, e, n) {
            lo.call(this, t, e, n)
        }

        function uo(t, e, n, i) {
            lo.call(this, t, e, n, i)
        }

        function po(t, e, n, i) {
            lo.call(this, t, e, n, i)
        }

        function fo(t, e, n, i) {
            so.call(this, t, e, n, i)
        }

        function mo(t, e, n, i) {
            lo.call(this, t, e, n, i)
        }

        function go(t, e, n, i) {
            lo.call(this, t, e, n, i)
        }

        function vo(t, e, n, i) {
            lo.call(this, t, e, n, i)
        }

        function yo(t, e, n, i) {
            this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== i ? i : 2500, this.uuid = c.generateUUID(), this.duration < 0 && this.resetDuration()
        }

        function _o(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function (t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return po;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return vo;
                    case "color":
                        return uo;
                    case "quaternion":
                        return mo;
                    case "bool":
                    case "boolean":
                        return ho;
                    case "string":
                        return go
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = [],
                    n = [];
                ro.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }
        Object.assign(so.prototype, {
            evaluate: function (t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex,
                    i = e[n],
                    r = e[n - 1];
                t: {
                    e: {
                        let s;n: {
                            i: if (!(t < i)) {
                                for (let s = n + 2;;) {
                                    if (void 0 === i) {
                                        if (t < r) break i;
                                        return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                    }
                                    if (n === s) break;
                                    if (r = i, i = e[++n], t < i) break e
                                }
                                s = e.length;
                                break n
                            }if (t >= r) break t; {
                                const o = e[1];
                                t < o && (n = 2, r = o);
                                for (let s = n - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                    if (n === s) break;
                                    if (i = r, r = e[--n - 1], t >= r) break e
                                }
                                s = n, n = 0
                            }
                        }
                        for (; n < s;) {
                            const i = n + s >>> 1;
                            t < e[i] ? s = i : n = i + 1
                        }
                        if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0,
                        this.beforeStart_(0, t, i);
                        if (void 0 === i) return n = e.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, r, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function () {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function (t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = t * i;
                for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                return e
            },
            interpolate_: function () {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function () {}
        }), Object.assign(so.prototype, {
            beforeStart_: so.prototype.copySampleValue_,
            afterEnd_: so.prototype.copySampleValue_
        }), oo.prototype = Object.assign(Object.create(so.prototype), {
            constructor: oo,
            DefaultSettings_: {
                endingStart: 2400,
                endingEnd: 2400
            },
            intervalChanged_: function (t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2,
                    s = t + 1,
                    o = i[r],
                    a = i[s];
                if (void 0 === o) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t, o = 2 * e - n;
                        break;
                    case 2402:
                        r = i.length - 2, o = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t, o = n
                }
                if (void 0 === a) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        s = t, a = 2 * n - e;
                        break;
                    case 2402:
                        s = 1, a = n + i[1] - i[0];
                        break;
                    default:
                        s = t - 1, a = e
                }
                const c = .5 * (n - e),
                    l = this.valueSize;
                this._weightPrev = c / (e - o), this._weightNext = c / (a - n), this._offsetPrev = r * l, this._offsetNext = s * l
            },
            interpolate_: function (t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = t * o,
                    c = a - o,
                    l = this._offsetPrev,
                    h = this._offsetNext,
                    u = this._weightPrev,
                    p = this._weightNext,
                    d = (n - e) / (i - e),
                    f = d * d,
                    m = f * d,
                    g = -u * m + 2 * u * f - u * d,
                    v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1,
                    y = (-1 - p) * m + (1.5 + p) * f + .5 * d,
                    _ = p * m - p * f;
                for (let t = 0; t !== o; ++t) r[t] = g * s[l + t] + v * s[c + t] + y * s[a + t] + _ * s[h + t];
                return r
            }
        }), ao.prototype = Object.assign(Object.create(so.prototype), {
            constructor: ao,
            interpolate_: function (t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = t * o,
                    c = a - o,
                    l = (n - e) / (i - e),
                    h = 1 - l;
                for (let t = 0; t !== o; ++t) r[t] = s[c + t] * h + s[a + t] * l;
                return r
            }
        }), co.prototype = Object.assign(Object.create(so.prototype), {
            constructor: co,
            interpolate_: function (t) {
                return this.copySampleValue_(t - 1)
            }
        }), Object.assign(lo, {
            toJSON: function (t) {
                const e = t.constructor;
                let n;
                if (void 0 !== e.toJSON) n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: ro.convertArray(t.times, Array),
                        values: ro.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName, n
            }
        }), Object.assign(lo.prototype, {
            constructor: lo,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodDiscrete: function (t) {
                return new co(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function (t) {
                return new ao(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function (t) {
                return new oo(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function (t) {
                let e;
                switch (t) {
                    case 2300:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return this
                }
                return this.createInterpolant = e, this
            },
            getInterpolation: function () {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function () {
                return this.values.length / this.times.length
            },
            shift: function (t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                }
                return this
            },
            scale: function (t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                }
                return this
            },
            trim: function (t, e) {
                const n = this.times,
                    i = n.length;
                let r = 0,
                    s = i - 1;
                for (; r !== i && n[r] < t;) ++r;
                for (; - 1 !== s && n[s] > e;) --s;
                if (++s, 0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1), r = s - 1);
                    const t = this.getValueSize();
                    this.times = ro.arraySlice(n, r, s), this.values = ro.arraySlice(this.values, r * t, s * t)
                }
                return this
            },
            validate: function () {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (t = !1);
                const n = this.times,
                    i = this.values,
                    r = n.length;
                0 === r && (t = !1);
                let s = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        t = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        t = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && ro.isTypedArray(i))
                    for (let e = 0, n = i.length; e !== n; ++e) {
                        const n = i[e];
                        if (isNaN(n)) {
                            t = !1;
                            break
                        }
                    }
                return t
            },
            optimize: function () {
                const t = ro.arraySlice(this.times),
                    e = ro.arraySlice(this.values),
                    n = this.getValueSize(),
                    i = 2302 === this.getInterpolation(),
                    r = t.length - 1;
                let s = 1;
                for (let o = 1; o < r; ++o) {
                    let r = !1;
                    const a = t[o];
                    if (a !== t[o + 1] && (1 !== o || a !== a[0]))
                        if (i) r = !0;
                        else {
                            const t = o * n,
                                i = t - n,
                                s = t + n;
                            for (let o = 0; o !== n; ++o) {
                                const n = e[t + o];
                                if (n !== e[i + o] || n !== e[s + o]) {
                                    r = !0;
                                    break
                                }
                            }
                        } if (r) {
                        if (o !== s) {
                            t[s] = t[o];
                            const i = o * n,
                                r = s * n;
                            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                        }++s
                    }
                }
                if (r > 0) {
                    t[s] = t[r];
                    for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];
                    ++s
                }
                return s !== t.length ? (this.times = ro.arraySlice(t, 0, s), this.values = ro.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
            },
            clone: function () {
                const t = ro.arraySlice(this.times, 0),
                    e = ro.arraySlice(this.values, 0),
                    n = new(0, this.constructor)(this.name, t, e);
                return n.createInterpolant = this.createInterpolant, n
            }
        }), ho.prototype = Object.assign(Object.create(lo.prototype), {
            constructor: ho,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), uo.prototype = Object.assign(Object.create(lo.prototype), {
            constructor: uo,
            ValueTypeName: "color"
        }), po.prototype = Object.assign(Object.create(lo.prototype), {
            constructor: po,
            ValueTypeName: "number"
        }), fo.prototype = Object.assign(Object.create(so.prototype), {
            constructor: fo,
            interpolate_: function (t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = (n - e) / (i - e);
                let c = t * o;
                for (let t = c + o; c !== t; c += 4) _.slerpFlat(r, 0, s, c - o, s, c, a);
                return r
            }
        }), mo.prototype = Object.assign(Object.create(lo.prototype), {
            constructor: mo,
            ValueTypeName: "quaternion",
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodLinear: function (t) {
                return new fo(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), go.prototype = Object.assign(Object.create(lo.prototype), {
            constructor: go,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), vo.prototype = Object.assign(Object.create(lo.prototype), {
            constructor: vo,
            ValueTypeName: "vector"
        }), Object.assign(yo, {
            parse: function (t) {
                const e = [],
                    n = t.tracks,
                    i = 1 / (t.fps || 1);
                for (let t = 0, r = n.length; t !== r; ++t) e.push(_o(n[t]).scale(i));
                const r = new yo(t.name, t.duration, e, t.blendMode);
                return r.uuid = t.uuid, r
            },
            toJSON: function (t) {
                const e = [],
                    n = t.tracks,
                    i = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode
                    };
                for (let t = 0, i = n.length; t !== i; ++t) e.push(lo.toJSON(n[t]));
                return i
            },
            CreateFromMorphTargetSequence: function (t, e, n, i) {
                const r = e.length,
                    s = [];
                for (let t = 0; t < r; t++) {
                    let o = [],
                        a = [];
                    o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                    const c = ro.getKeyframeOrder(o);
                    o = ro.sortedArray(o, 1, c), a = ro.sortedArray(a, 1, c), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new po(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                }
                return new yo(t, -1, s)
            },
            findByName: function (t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e) return n[t];
                return null
            },
            CreateClipsFromMorphTargetSequences: function (t, e, n) {
                const i = {},
                    r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e],
                        s = n.name.match(r);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = i[t];
                        e || (i[t] = e = []), e.push(n)
                    }
                }
                const s = [];
                for (const t in i) s.push(yo.CreateFromMorphTargetSequence(t, i[t], e, n));
                return s
            },
            parseAnimation: function (t, e) {
                if (!t) return null;
                const n = function (t, e, n, i, r) {
                        if (0 !== n.length) {
                            const s = [],
                                o = [];
                            ro.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                        }
                    },
                    i = [],
                    r = t.name || "default",
                    s = t.fps || 30,
                    o = t.blendMode;
                let a = t.length || -1;
                const c = t.hierarchy || [];
                for (let t = 0; t < c.length; t++) {
                    const r = c[t].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < r.length; e++)
                                if (r[e].morphTargets)
                                    for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = [],
                                    s = [];
                                for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                    const i = r[e];
                                    t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new po(".morphTargetInfluence[" + n + "]", t, s))
                            }
                            a = t.length * (s || 1)
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            n(vo, s + ".position", r, "pos", i), n(mo, s + ".quaternion", r, "rot", i), n(vo, s + ".scale", r, "scl", i)
                        }
                }
                if (0 === i.length) return null;
                return new yo(r, a, i, o)
            }
        }), Object.assign(yo.prototype, {
            resetDuration: function () {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            },
            trim: function () {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            validate: function () {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            },
            optimize: function () {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            },
            clone: function () {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new yo(this.name, this.duration, t, this.blendMode)
            },
            toJSON: function () {
                return yo.toJSON(this)
            }
        });
        const xo = {
            enabled: !1,
            files: {},
            add: function (t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function (t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function (t) {
                delete this.files[t]
            },
            clear: function () {
                this.files = {}
            }
        };

        function bo(t, e, n) {
            const i = this;
            let r = !1,
                s = 0,
                o = 0,
                a = void 0;
            const c = [];
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
                o++, !1 === r && void 0 !== i.onStart && i.onStart(t, s, o), r = !0
            }, this.itemEnd = function (t) {
                s++, void 0 !== i.onProgress && i.onProgress(t, s, o), s === o && (r = !1, void 0 !== i.onLoad && i.onLoad())
            }, this.itemError = function (t) {
                void 0 !== i.onError && i.onError(t)
            }, this.resolveURL = function (t) {
                return a ? a(t) : t
            }, this.setURLModifier = function (t) {
                return a = t, this
            }, this.addHandler = function (t, e) {
                return c.push(t, e), this
            }, this.removeHandler = function (t) {
                const e = c.indexOf(t);
                return -1 !== e && c.splice(e, 2), this
            }, this.getHandler = function (t) {
                for (let e = 0, n = c.length; e < n; e += 2) {
                    const n = c[e],
                        i = c[e + 1];
                    if (n.global && (n.lastIndex = 0), n.test(t)) return i
                }
                return null
            }
        }
        const Mo = new bo;

        function wo(t) {
            this.manager = void 0 !== t ? t : Mo, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        Object.assign(wo.prototype, {
            load: function () {},
            loadAsync: function (t, e) {
                const n = this;
                return new Promise((function (i, r) {
                    n.load(t, i, e, r)
                }))
            },
            parse: function () {},
            setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            },
            setWithCredentials: function (t) {
                return this.withCredentials = t, this
            },
            setPath: function (t) {
                return this.path = t, this
            },
            setResourcePath: function (t) {
                return this.resourcePath = t, this
            },
            setRequestHeader: function (t) {
                return this.requestHeader = t, this
            }
        });
        const So = {};

        function To(t) {
            wo.call(this, t)
        }

        function Ao(t) {
            wo.call(this, t)
        }

        function Lo(t) {
            wo.call(this, t)
        }

        function Co(t) {
            wo.call(this, t)
        }

        function Po(t) {
            wo.call(this, t)
        }

        function Eo(t) {
            wo.call(this, t)
        }

        function No(t) {
            wo.call(this, t)
        }

        function Oo() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function Do(t, e, n, i, r, s, o, a) {
            Oo.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = s || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = a || 0
        }

        function Io(t, e, n, i, r, s) {
            Do.call(this, t, e, n, n, i, r, s), this.type = "ArcCurve"
        }

        function zo() {
            let t = 0,
                e = 0,
                n = 0,
                i = 0;

            function r(r, s, o, a) {
                t = r, e = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a
            }
            return {
                initCatmullRom: function (t, e, n, i, s) {
                    r(e, n, s * (n - t), s * (i - e))
                },
                initNonuniformCatmullRom: function (t, e, n, i, s, o, a) {
                    let c = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                        l = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                    c *= o, l *= o, r(e, n, c, l)
                },
                calc: function (r) {
                    const s = r * r;
                    return t + e * r + n * s + i * (s * r)
                }
            }
        }
        To.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: To,
            load: function (t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this,
                    s = xo.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                if (void 0 !== So[t]) return void So[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                let a;
                if (o) {
                    const n = o[1],
                        s = !!o[2];
                    let a = o[3];
                    a = decodeURIComponent(a), s && (a = atob(a));
                    try {
                        let i;
                        const s = (this.responseType || "").toLowerCase();
                        switch (s) {
                            case "arraybuffer":
                            case "blob":
                                const t = new Uint8Array(a.length);
                                for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                                i = "blob" === s ? new Blob([t.buffer], {
                                    type: n
                                }) : t.buffer;
                                break;
                            case "document":
                                const e = new DOMParser;
                                i = e.parseFromString(a, n);
                                break;
                            case "json":
                                i = JSON.parse(a);
                                break;
                            default:
                                i = a
                        }
                        setTimeout((function () {
                            e && e(i), r.manager.itemEnd(t)
                        }), 0)
                    } catch (e) {
                        setTimeout((function () {
                            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                        }), 0)
                    }
                } else {
                    So[t] = [], So[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function (e) {
                        const n = this.response,
                            i = So[t];
                        if (delete So[t], 200 === this.status || 0 === this.status) {
                            this.status, xo.add(t, n);
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t];
                                e.onLoad && e.onLoad(n)
                            }
                            r.manager.itemEnd(t)
                        } else {
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = i[t];
                                n.onError && n.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }
                    }), !1), a.addEventListener("progress", (function (e) {
                        const n = So[t];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            i.onProgress && i.onProgress(e)
                        }
                    }), !1), a.addEventListener("error", (function (e) {
                        const n = So[t];
                        delete So[t];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            i.onError && i.onError(e)
                        }
                        r.manager.itemError(t), r.manager.itemEnd(t)
                    }), !1), a.addEventListener("abort", (function (e) {
                        const n = So[t];
                        delete So[t];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            i.onError && i.onError(e)
                        }
                        r.manager.itemError(t), r.manager.itemEnd(t)
                    }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
                    a.send(null)
                }
                return r.manager.itemStart(t), a
            },
            setResponseType: function (t) {
                return this.responseType = t, this
            },
            setMimeType: function (t) {
                return this.mimeType = t, this
            }
        }), Ao.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: Ao,
            load: function (t, e, n, i) {
                const r = this,
                    s = new To(r.manager);
                s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function (n) {
                    try {
                        e(r.parse(JSON.parse(n)))
                    } catch (e) {
                        i && i(e), r.manager.itemError(t)
                    }
                }), n, i)
            },
            parse: function (t) {
                const e = [];
                for (let n = 0; n < t.length; n++) {
                    const i = yo.parse(t[n]);
                    e.push(i)
                }
                return e
            }
        }), Lo.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: Lo,
            load: function (t, e, n, r) {
                const s = this,
                    o = [],
                    a = new rs;
                a.image = o;
                const c = new To(this.manager);
                c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(s.withCredentials);
                let l = 0;

                function h(h) {
                    c.load(t[h], (function (t) {
                        const n = s.parse(t, !0);
                        o[h] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps
                        }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = i), a.format = n.format, a.needsUpdate = !0, e && e(a))
                    }), n, r)
                }
                if (Array.isArray(t))
                    for (let e = 0, n = t.length; e < n; ++e) h(e);
                else c.load(t, (function (t) {
                    const n = s.parse(t, !0);
                    if (n.isCubemap) {
                        const t = n.mipmaps.length / n.mipmapCount;
                        for (let e = 0; e < t; e++) {
                            o[e] = {
                                mipmaps: []
                            };
                            for (let t = 0; t < n.mipmapCount; t++) o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height
                        }
                    } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (a.minFilter = i), a.format = n.format, a.needsUpdate = !0, e && e(a)
                }), n, r);
                return a
            }
        }), Co.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: Co,
            load: function (t, e, n, i) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this,
                    s = xo.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                function a() {
                    o.removeEventListener("load", a, !1), o.removeEventListener("error", c, !1), xo.add(t, this), e && e(this), r.manager.itemEnd(t)
                }

                function c(e) {
                    o.removeEventListener("load", a, !1), o.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }
                return o.addEventListener("load", a, !1), o.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
            }
        }), Po.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: Po,
            load: function (t, e, n, i) {
                const r = new He,
                    s = new Co(this.manager);
                s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                let o = 0;

                function a(n) {
                    s.load(t[n], (function (t) {
                        r.images[n] = t, o++, 6 === o && (r.needsUpdate = !0, e && e(r))
                    }), void 0, i)
                }
                for (let e = 0; e < t.length; ++e) a(e);
                return r
            }
        }), Eo.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: Eo,
            load: function (t, e, n, r) {
                const s = this,
                    o = new Xe,
                    a = new To(this.manager);
                return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(t, (function (t) {
                    const n = s.parse(t);
                    n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001, o.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001, o.magFilter = void 0 !== n.magFilter ? n.magFilter : i, o.minFilter = void 0 !== n.minFilter ? n.minFilter : i, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = 1008), 1 === n.mipmapCount && (o.minFilter = i), o.needsUpdate = !0, e && e(o, n))
                }), n, r), o
            }
        }), No.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: No,
            load: function (t, e, n, i) {
                const s = new f,
                    o = new Co(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (n) {
                    s.image = n;
                    const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    s.format = i ? 1022 : r, s.needsUpdate = !0, void 0 !== e && e(s)
                }), n, i), s
            }
        }), Object.assign(Oo.prototype, {
            getPoint: function () {
                return null
            },
            getPointAt: function (t, e) {
                const n = this.getUtoTmapping(t);
                return this.getPoint(n, e)
            },
            getPoints: function (t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return e
            },
            getSpacedPoints: function (t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                return e
            },
            getLength: function () {
                const t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function (t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let n, i = this.getPoint(0),
                    r = 0;
                e.push(0);
                for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
                return this.cacheArcLengths = e, e
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function (t, e) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let s;
                s = e || t * n[r - 1];
                let o, a = 0,
                    c = r - 1;
                for (; a <= c;)
                    if (i = Math.floor(a + (c - a) / 2), o = n[i] - s, o < 0) a = i + 1;
                    else {
                        if (!(o > 0)) {
                            c = i;
                            break
                        }
                        c = i - 1
                    } if (i = c, n[i] === s) return i / (r - 1);
                const l = n[i];
                return (i + (s - l) / (n[i + 1] - l)) / (r - 1)
            },
            getTangent: function (t, e) {
                let n = t - 1e-4,
                    i = t + 1e-4;
                n < 0 && (n = 0), i > 1 && (i = 1);
                const r = this.getPoint(n),
                    s = this.getPoint(i),
                    o = e || (r.isVector2 ? new l : new x);
                return o.copy(s).sub(r).normalize(), o
            },
            getTangentAt: function (t, e) {
                const n = this.getUtoTmapping(t);
                return this.getTangent(n, e)
            },
            computeFrenetFrames: function (t, e) {
                const n = new x,
                    i = [],
                    r = [],
                    s = [],
                    o = new x,
                    a = new Y;
                for (let e = 0; e <= t; e++) {
                    const n = e / t;
                    i[e] = this.getTangentAt(n, new x), i[e].normalize()
                }
                r[0] = new x, s[0] = new x;
                let l = Number.MAX_VALUE;
                const h = Math.abs(i[0].x),
                    u = Math.abs(i[0].y),
                    p = Math.abs(i[0].z);
                h <= l && (l = h, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), p <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]);
                for (let e = 1; e <= t; e++) {
                    if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) {
                        o.normalize();
                        const t = Math.acos(c.clamp(i[e - 1].dot(i[e]), -1, 1));
                        r[e].applyMatrix4(a.makeRotationAxis(o, t))
                    }
                    s[e].crossVectors(i[e], r[e])
                }
                if (!0 === e) {
                    let e = Math.acos(c.clamp(r[0].dot(r[t]), -1, 1));
                    e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                    for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                }
                return {
                    tangents: i,
                    normals: r,
                    binormals: s
                }
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            },
            toJSON: function () {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            },
            fromJSON: function (t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }), Do.prototype = Object.create(Oo.prototype), Do.prototype.constructor = Do, Do.prototype.isEllipseCurve = !0, Do.prototype.getPoint = function (t, e) {
            const n = e || new l,
                i = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0;) r += i;
            for (; r > i;) r -= i;
            r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
            const o = this.aStartAngle + t * r;
            let a = this.aX + this.xRadius * Math.cos(o),
                c = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
                const t = Math.cos(this.aRotation),
                    e = Math.sin(this.aRotation),
                    n = a - this.aX,
                    i = c - this.aY;
                a = n * t - i * e + this.aX, c = n * e + i * t + this.aY
            }
            return n.set(a, c)
        }, Do.prototype.copy = function (t) {
            return Oo.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, Do.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
        }, Do.prototype.fromJSON = function (t) {
            return Oo.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, Io.prototype = Object.create(Do.prototype), Io.prototype.constructor = Io, Io.prototype.isArcCurve = !0;
        const Ro = new x,
            Fo = new zo,
            Uo = new zo,
            Bo = new zo;

        function ko(t = [], e = !1, n = "centripetal", i = .5) {
            Oo.call(this), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
        }

        function Vo(t, e, n, i, r) {
            const s = .5 * (i - e),
                o = .5 * (r - n),
                a = t * t;
            return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
        }

        function jo(t, e, n, i) {
            return function (t, e) {
                const n = 1 - t;
                return n * n * e
            }(t, e) + function (t, e) {
                return 2 * (1 - t) * t * e
            }(t, n) + function (t, e) {
                return t * t * e
            }(t, i)
        }

        function Go(t, e, n, i, r) {
            return function (t, e) {
                const n = 1 - t;
                return n * n * n * e
            }(t, e) + function (t, e) {
                const n = 1 - t;
                return 3 * n * n * t * e
            }(t, n) + function (t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, i) + function (t, e) {
                return t * t * t * e
            }(t, r)
        }

        function Wo(t = new l, e = new l, n = new l, i = new l) {
            Oo.call(this), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
        }

        function Ho(t = new x, e = new x, n = new x, i = new x) {
            Oo.call(this), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
        }

        function qo(t = new l, e = new l) {
            Oo.call(this), this.type = "LineCurve", this.v1 = t, this.v2 = e
        }

        function Xo(t = new x, e = new x) {
            Oo.call(this), this.type = "LineCurve3", this.v1 = t, this.v2 = e
        }

        function Yo(t = new l, e = new l, n = new l) {
            Oo.call(this), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
        }

        function Zo(t = new x, e = new x, n = new x) {
            Oo.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
        }

        function Jo(t = []) {
            Oo.call(this), this.type = "SplineCurve", this.points = t
        }
        ko.prototype = Object.create(Oo.prototype), ko.prototype.constructor = ko, ko.prototype.isCatmullRomCurve3 = !0, ko.prototype.getPoint = function (t, e = new x) {
            const n = e,
                i = this.points,
                r = i.length,
                s = (r - (this.closed ? 0 : 1)) * t;
            let o, a, c = Math.floor(s),
                l = s - c;
            this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r : 0 === l && c === r - 1 && (c = r - 2, l = 1), this.closed || c > 0 ? o = i[(c - 1) % r] : (Ro.subVectors(i[0], i[1]).add(i[0]), o = Ro);
            const h = i[c % r],
                u = i[(c + 1) % r];
            if (this.closed || c + 2 < r ? a = i[(c + 2) % r] : (Ro.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = Ro), "centripetal" === this.curveType || "chordal" === this.curveType) {
                const t = "chordal" === this.curveType ? .5 : .25;
                let e = Math.pow(o.distanceToSquared(h), t),
                    n = Math.pow(h.distanceToSquared(u), t),
                    i = Math.pow(u.distanceToSquared(a), t);
                n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Fo.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i), Uo.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i), Bo.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
            } else "catmullrom" === this.curveType && (Fo.initCatmullRom(o.x, h.x, u.x, a.x, this.tension), Uo.initCatmullRom(o.y, h.y, u.y, a.y, this.tension), Bo.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
            return n.set(Fo.calc(l), Uo.calc(l), Bo.calc(l)), n
        }, ko.prototype.copy = function (t) {
            Oo.prototype.copy.call(this, t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push(n.clone())
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, ko.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
                const n = this.points[e];
                t.points.push(n.toArray())
            }
            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
        }, ko.prototype.fromJSON = function (t) {
            Oo.prototype.fromJSON.call(this, t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push((new x).fromArray(n))
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Wo.prototype = Object.create(Oo.prototype), Wo.prototype.constructor = Wo, Wo.prototype.isCubicBezierCurve = !0, Wo.prototype.getPoint = function (t, e = new l) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2,
                o = this.v3;
            return n.set(Go(t, i.x, r.x, s.x, o.x), Go(t, i.y, r.y, s.y, o.y)), n
        }, Wo.prototype.copy = function (t) {
            return Oo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Wo.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Wo.prototype.fromJSON = function (t) {
            return Oo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, Ho.prototype = Object.create(Oo.prototype), Ho.prototype.constructor = Ho, Ho.prototype.isCubicBezierCurve3 = !0, Ho.prototype.getPoint = function (t, e = new x) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2,
                o = this.v3;
            return n.set(Go(t, i.x, r.x, s.x, o.x), Go(t, i.y, r.y, s.y, o.y), Go(t, i.z, r.z, s.z, o.z)), n
        }, Ho.prototype.copy = function (t) {
            return Oo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Ho.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Ho.prototype.fromJSON = function (t) {
            return Oo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, qo.prototype = Object.create(Oo.prototype), qo.prototype.constructor = qo, qo.prototype.isLineCurve = !0, qo.prototype.getPoint = function (t, e = new l) {
            const n = e;
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
        }, qo.prototype.getPointAt = function (t, e) {
            return this.getPoint(t, e)
        }, qo.prototype.getTangent = function (t, e) {
            const n = e || new l;
            return n.copy(this.v2).sub(this.v1).normalize(), n
        }, qo.prototype.copy = function (t) {
            return Oo.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, qo.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, qo.prototype.fromJSON = function (t) {
            return Oo.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Xo.prototype = Object.create(Oo.prototype), Xo.prototype.constructor = Xo, Xo.prototype.isLineCurve3 = !0, Xo.prototype.getPoint = function (t, e = new x) {
            const n = e;
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
        }, Xo.prototype.getPointAt = function (t, e) {
            return this.getPoint(t, e)
        }, Xo.prototype.copy = function (t) {
            return Oo.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Xo.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Xo.prototype.fromJSON = function (t) {
            return Oo.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Yo.prototype = Object.create(Oo.prototype), Yo.prototype.constructor = Yo, Yo.prototype.isQuadraticBezierCurve = !0, Yo.prototype.getPoint = function (t, e = new l) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2;
            return n.set(jo(t, i.x, r.x, s.x), jo(t, i.y, r.y, s.y)), n
        }, Yo.prototype.copy = function (t) {
            return Oo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Yo.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Yo.prototype.fromJSON = function (t) {
            return Oo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Zo.prototype = Object.create(Oo.prototype), Zo.prototype.constructor = Zo, Zo.prototype.isQuadraticBezierCurve3 = !0, Zo.prototype.getPoint = function (t, e = new x) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2;
            return n.set(jo(t, i.x, r.x, s.x), jo(t, i.y, r.y, s.y), jo(t, i.z, r.z, s.z)), n
        }, Zo.prototype.copy = function (t) {
            return Oo.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Zo.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Zo.prototype.fromJSON = function (t) {
            return Oo.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Jo.prototype = Object.create(Oo.prototype), Jo.prototype.constructor = Jo, Jo.prototype.isSplineCurve = !0, Jo.prototype.getPoint = function (t, e = new l) {
            const n = e,
                i = this.points,
                r = (i.length - 1) * t,
                s = Math.floor(r),
                o = r - s,
                a = i[0 === s ? s : s - 1],
                c = i[s],
                h = i[s > i.length - 2 ? i.length - 1 : s + 1],
                u = i[s > i.length - 3 ? i.length - 1 : s + 2];
            return n.set(Vo(o, a.x, c.x, h.x, u.x), Vo(o, a.y, c.y, h.y, u.y)), n
        }, Jo.prototype.copy = function (t) {
            Oo.prototype.copy.call(this, t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push(n.clone())
            }
            return this
        }, Jo.prototype.toJSON = function () {
            const t = Oo.prototype.toJSON.call(this);
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
                const n = this.points[e];
                t.points.push(n.toArray())
            }
            return t
        }, Jo.prototype.fromJSON = function (t) {
            Oo.prototype.fromJSON.call(this, t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push((new l).fromArray(n))
            }
            return this
        };
        var Qo = Object.freeze({
            __proto__: null,
            ArcCurve: Io,
            CatmullRomCurve3: ko,
            CubicBezierCurve: Wo,
            CubicBezierCurve3: Ho,
            EllipseCurve: Do,
            LineCurve: qo,
            LineCurve3: Xo,
            QuadraticBezierCurve: Yo,
            QuadraticBezierCurve3: Zo,
            SplineCurve: Jo
        });

        function Ko() {
            Oo.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function $o(t) {
            Ko.call(this), this.type = "Path", this.currentPoint = new l, t && this.setFromPoints(t)
        }

        function ta(t) {
            $o.call(this, t), this.uuid = c.generateUUID(), this.type = "Shape", this.holes = []
        }

        function ea(t, e = 1) {
            _t.call(this), this.type = "Light", this.color = new Vt(t), this.intensity = e
        }

        function na(t, e, n) {
            ea.call(this, t, n), this.type = "HemisphereLight", this.position.copy(_t.DefaultUp), this.updateMatrix(), this.groundColor = new Vt(e)
        }

        function ia(t) {
            this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new l(512, 512), this.map = null, this.mapPass = null, this.matrix = new Y, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Je, this._frameExtents = new l(1, 1), this._viewportCount = 1, this._viewports = [new g(0, 0, 1, 1)]
        }

        function ra() {
            ia.call(this, new Ge(50, 1, .5, 500)), this.focus = 1
        }

        function sa(t, e, n, i, r, s) {
            ea.call(this, t, e), this.type = "SpotLight", this.position.copy(_t.DefaultUp), this.updateMatrix(), this.target = new _t, Object.defineProperty(this, "power", {
                get: function () {
                    return this.intensity * Math.PI
                },
                set: function (t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== s ? s : 1, this.shadow = new ra
        }

        function oa() {
            ia.call(this, new Ge(90, 1, .5, 500)), this._frameExtents = new l(4, 2), this._viewportCount = 6, this._viewports = [new g(2, 1, 1, 1), new g(0, 1, 1, 1), new g(3, 1, 1, 1), new g(1, 1, 1, 1), new g(3, 0, 1, 1), new g(1, 0, 1, 1)], this._cubeDirections = [new x(1, 0, 0), new x(-1, 0, 0), new x(0, 0, 1), new x(0, 0, -1), new x(0, 1, 0), new x(0, -1, 0)], this._cubeUps = [new x(0, 1, 0), new x(0, 1, 0), new x(0, 1, 0), new x(0, 1, 0), new x(0, 0, 1), new x(0, 0, -1)]
        }

        function aa(t, e, n, i) {
            ea.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function () {
                    return 4 * this.intensity * Math.PI
                },
                set: function (t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new oa
        }

        function ca(t, e, n, i, r, s) {
            je.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== s ? s : 2e3, this.updateProjectionMatrix()
        }

        function la() {
            ia.call(this, new ca(-5, 5, 5, -5, .5, 500))
        }

        function ha(t, e) {
            ea.call(this, t, e), this.type = "DirectionalLight", this.position.copy(_t.DefaultUp), this.updateMatrix(), this.target = new _t, this.shadow = new la
        }

        function ua(t, e) {
            ea.call(this, t, e), this.type = "AmbientLight"
        }

        function pa(t, e, n, i) {
            ea.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
        }
        Ko.prototype = Object.assign(Object.create(Oo.prototype), {
            constructor: Ko,
            add: function (t) {
                this.curves.push(t)
            },
            closePath: function () {
                const t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new qo(e, t))
            },
            getPoint: function (t) {
                const e = t * this.getLength(),
                    n = this.getCurveLengths();
                let i = 0;
                for (; i < n.length;) {
                    if (n[i] >= e) {
                        const t = n[i] - e,
                            r = this.curves[i],
                            s = r.getLength(),
                            o = 0 === s ? 0 : 1 - t / s;
                        return r.getPointAt(o)
                    }
                    i++
                }
                return null
            },
            getLength: function () {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function () {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                return this.cacheLengths = t, t
            },
            getSpacedPoints: function (t = 40) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]), e
            },
            getPoints: function (t = 12) {
                const e = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const s = r[i],
                        o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
                        a = s.getPoints(o);
                    for (let t = 0; t < a.length; t++) {
                        const i = a[t];
                        n && n.equals(i) || (e.push(i), n = i)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
            },
            copy: function (t) {
                Oo.prototype.copy.call(this, t), this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose, this
            },
            toJSON: function () {
                const t = Oo.prototype.toJSON.call(this);
                t.autoClose = this.autoClose, t.curves = [];
                for (let e = 0, n = this.curves.length; e < n; e++) {
                    const n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            },
            fromJSON: function (t) {
                Oo.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push((new Qo[n.type]).fromJSON(n))
                }
                return this
            }
        }), $o.prototype = Object.assign(Object.create(Ko.prototype), {
            constructor: $o,
            setFromPoints: function (t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                return this
            },
            moveTo: function (t, e) {
                return this.currentPoint.set(t, e), this
            },
            lineTo: function (t, e) {
                const n = new qo(this.currentPoint.clone(), new l(t, e));
                return this.curves.push(n), this.currentPoint.set(t, e), this
            },
            quadraticCurveTo: function (t, e, n, i) {
                const r = new Yo(this.currentPoint.clone(), new l(t, e), new l(n, i));
                return this.curves.push(r), this.currentPoint.set(n, i), this
            },
            bezierCurveTo: function (t, e, n, i, r, s) {
                const o = new Wo(this.currentPoint.clone(), new l(t, e), new l(n, i), new l(r, s));
                return this.curves.push(o), this.currentPoint.set(r, s), this
            },
            splineThru: function (t) {
                const e = new Jo([this.currentPoint.clone()].concat(t));
                return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
            },
            arc: function (t, e, n, i, r, s) {
                const o = this.currentPoint.x,
                    a = this.currentPoint.y;
                return this.absarc(t + o, e + a, n, i, r, s), this
            },
            absarc: function (t, e, n, i, r, s) {
                return this.absellipse(t, e, n, n, i, r, s), this
            },
            ellipse: function (t, e, n, i, r, s, o, a) {
                const c = this.currentPoint.x,
                    l = this.currentPoint.y;
                return this.absellipse(t + c, e + l, n, i, r, s, o, a), this
            },
            absellipse: function (t, e, n, i, r, s, o, a) {
                const c = new Do(t, e, n, i, r, s, o, a);
                if (this.curves.length > 0) {
                    const t = c.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(c);
                const l = c.getPoint(1);
                return this.currentPoint.copy(l), this
            },
            copy: function (t) {
                return Ko.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
            },
            toJSON: function () {
                const t = Ko.prototype.toJSON.call(this);
                return t.currentPoint = this.currentPoint.toArray(), t
            },
            fromJSON: function (t) {
                return Ko.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }), ta.prototype = Object.assign(Object.create($o.prototype), {
            constructor: ta,
            getPointsHoles: function (t) {
                const e = [];
                for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                return e
            },
            extractPoints: function (t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            copy: function (t) {
                $o.prototype.copy.call(this, t), this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            },
            toJSON: function () {
                const t = $o.prototype.toJSON.call(this);
                t.uuid = this.uuid, t.holes = [];
                for (let e = 0, n = this.holes.length; e < n; e++) {
                    const n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            },
            fromJSON: function (t) {
                $o.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push((new $o).fromJSON(n))
                }
                return this
            }
        }), ea.prototype = Object.assign(Object.create(_t.prototype), {
            constructor: ea,
            isLight: !0,
            copy: function (t) {
                return _t.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function (t) {
                const e = _t.prototype.toJSON.call(this, t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }), na.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: na,
            isHemisphereLight: !0,
            copy: function (t) {
                return ea.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(ia.prototype, {
            _projScreenMatrix: new Y,
            _lightPositionWorld: new x,
            _lookTarget: new x,
            getViewportCount: function () {
                return this._viewportCount
            },
            getFrustum: function () {
                return this._frustum
            },
            updateMatrices: function (t) {
                const e = this.camera,
                    n = this.matrix,
                    i = this._projScreenMatrix,
                    r = this._lookTarget,
                    s = this._lightPositionWorld;
                s.setFromMatrixPosition(t.matrixWorld), e.position.copy(s), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
            },
            getViewport: function (t) {
                return this._viewports[t]
            },
            getFrameExtents: function () {
                return this._frameExtents
            },
            copy: function (t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), ra.prototype = Object.assign(Object.create(ia.prototype), {
            constructor: ra,
            isSpotLightShadow: !0,
            updateMatrices: function (t) {
                const e = this.camera,
                    n = 2 * c.RAD2DEG * t.angle * this.focus,
                    i = this.mapSize.width / this.mapSize.height,
                    r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), ia.prototype.updateMatrices.call(this, t)
            }
        }), sa.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: sa,
            isSpotLight: !0,
            copy: function (t) {
                return ea.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), oa.prototype = Object.assign(Object.create(ia.prototype), {
            constructor: oa,
            isPointLightShadow: !0,
            updateMatrices: function (t, e = 0) {
                const n = this.camera,
                    i = this.matrix,
                    r = this._lightPositionWorld,
                    s = this._lookTarget,
                    o = this._projScreenMatrix;
                r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), s.copy(n.position), s.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(s), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o)
            }
        }), aa.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: aa,
            isPointLight: !0,
            copy: function (t) {
                return ea.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), ca.prototype = Object.assign(Object.create(je.prototype), {
            constructor: ca,
            isOrthographicCamera: !0,
            copy: function (t, e) {
                return je.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function (t, e, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                const t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                let r = n - t,
                    s = n + t,
                    o = i + e,
                    a = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            },
            toJSON: function (t) {
                const e = _t.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }), la.prototype = Object.assign(Object.create(ia.prototype), {
            constructor: la,
            isDirectionalLightShadow: !0,
            updateMatrices: function (t) {
                ia.prototype.updateMatrices.call(this, t)
            }
        }), ha.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: ha,
            isDirectionalLight: !0,
            copy: function (t) {
                return ea.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), ua.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: ua,
            isAmbientLight: !0
        }), pa.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: pa,
            isRectAreaLight: !0,
            copy: function (t) {
                return ea.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function (t) {
                const e = ea.prototype.toJSON.call(this, t);
                return e.object.width = this.width, e.object.height = this.height, e
            }
        });
        class da {
            constructor() {
                Object.defineProperty(this, "isSphericalHarmonics3", {
                    value: !0
                }), this.coefficients = [];
                for (let t = 0; t < 9; t++) this.coefficients.push(new x)
            }
            set(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                return this
            }
            zero() {
                for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const n = t.x,
                    i = t.y,
                    r = t.z,
                    s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * i), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * i * 1.092548), e.addScaledVector(s[5], i * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], n * r * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - i * i)), e
            }
            getIrradianceAt(t, e) {
                const n = t.x,
                    i = t.y,
                    r = t.z,
                    s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * i), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * i), e.addScaledVector(s[5], .858086 * i * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * n * r), e.addScaledVector(s[8], .429043 * (n * n - i * i)), e
            }
            add(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                return this
            }
            addScaledSH(t, e) {
                for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                return this
            }
            scale(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                return this
            }
            lerp(t, e) {
                for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                return this
            }
            equals(t) {
                for (let e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t, e = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                return t
            }
            static getBasisAt(t, e) {
                const n = t.x,
                    i = t.y,
                    r = t.z;
                e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
            }
        }

        function fa(t, e) {
            ea.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new da
        }

        function ma(t) {
            wo.call(this, t), this.textures = {}
        }
        fa.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: fa,
            isLightProbe: !0,
            copy: function (t) {
                return ea.prototype.copy.call(this, t), this.sh.copy(t.sh), this
            },
            fromJSON: function (t) {
                return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
            },
            toJSON: function (t) {
                const e = ea.prototype.toJSON.call(this, t);
                return e.object.sh = this.sh.toArray(), e
            }
        }), ma.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: ma,
            load: function (t, e, n, i) {
                const r = this,
                    s = new To(r.manager);
                s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function (n) {
                    try {
                        e(r.parse(JSON.parse(n)))
                    } catch (e) {
                        i && i(e), r.manager.itemError(t)
                    }
                }), n, i)
            },
            parse: function (t) {
                const e = this.textures;

                function n(t) {
                    return e[t], e[t]
                }
                const i = new io[t.type];
                if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new Vt).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                    for (const e in t.uniforms) {
                        const r = t.uniforms[e];
                        switch (i.uniforms[e] = {}, r.type) {
                            case "t":
                                i.uniforms[e].value = n(r.value);
                                break;
                            case "c":
                                i.uniforms[e].value = (new Vt).setHex(r.value);
                                break;
                            case "v2":
                                i.uniforms[e].value = (new l).fromArray(r.value);
                                break;
                            case "v3":
                                i.uniforms[e].value = (new x).fromArray(r.value);
                                break;
                            case "v4":
                                i.uniforms[e].value = (new g).fromArray(r.value);
                                break;
                            case "m3":
                                i.uniforms[e].value = (new h).fromArray(r.value);
                                break;
                            case "m4":
                                i.uniforms[e].value = (new Y).fromArray(r.value);
                                break;
                            default:
                                i.uniforms[e].value = r.value
                        }
                    }
                if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                    for (const e in t.extensions) i.extensions[e] = t.extensions[e];
                if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                    let e = t.normalScale;
                    !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new l).fromArray(e)
                }
                return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new l).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), i
            },
            setTextures: function (t) {
                return this.textures = t, this
            }
        });
        const ga = function (t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        };

        function va() {
            ge.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
        }

        function ya(t, e, n, i) {
            "number" == typeof n && (i = n, n = !1), Yt.call(this, t, e, n), this.meshPerAttribute = i || 1
        }

        function _a(t) {
            wo.call(this, t)
        }
        va.prototype = Object.assign(Object.create(ge.prototype), {
            constructor: va,
            isInstancedBufferGeometry: !0,
            copy: function (t) {
                return ge.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                const t = ge.prototype.toJSON.call(this);
                return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
            }
        }), ya.prototype = Object.assign(Object.create(Yt.prototype), {
            constructor: ya,
            isInstancedBufferAttribute: !0,
            copy: function (t) {
                return Yt.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            },
            toJSON: function () {
                const t = Yt.prototype.toJSON.call(this);
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }), _a.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: _a,
            load: function (t, e, n, i) {
                const r = this,
                    s = new To(r.manager);
                s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function (n) {
                    try {
                        e(r.parse(JSON.parse(n)))
                    } catch (e) {
                        i && i(e), r.manager.itemError(t)
                    }
                }), n, i)
            },
            parse: function (t) {
                const e = {},
                    n = {};

                function i(t, i) {
                    if (void 0 !== e[i]) return e[i];
                    const r = t.interleavedBuffers[i],
                        s = function (t, e) {
                            if (void 0 !== n[e]) return n[e];
                            const i = t.arrayBuffers[e],
                                r = new Uint32Array(i).buffer;
                            return n[e] = r, r
                        }(t, r.buffer),
                        o = new ar(ce(r.type, s), r.stride);
                    return o.uuid = r.uuid, e[i] = o, o
                }
                const r = t.isInstancedBufferGeometry ? new va : new ge,
                    s = t.data.index;
                if (void 0 !== s) {
                    const t = ce(s.type, s.array);
                    r.setIndex(new Yt(t, 1))
                }
                const o = t.data.attributes;
                for (const e in o) {
                    const n = o[e];
                    let s;
                    if (n.isInterleavedBufferAttribute) {
                        s = new lr(i(t.data, n.data), n.itemSize, n.offset, n.normalized)
                    } else {
                        const t = ce(n.type, n.array);
                        s = new(n.isInstancedBufferAttribute ? ya : Yt)(t, n.itemSize, n.normalized)
                    }
                    void 0 !== n.name && (s.name = n.name), r.setAttribute(e, s)
                }
                const a = t.data.morphAttributes;
                if (a)
                    for (const e in a) {
                        const n = a[e],
                            s = [];
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = n[e];
                            let o;
                            if (r.isInterleavedBufferAttribute) {
                                o = new lr(i(t.data, r.data), r.itemSize, r.offset, r.normalized)
                            } else {
                                o = new Yt(ce(r.type, r.array), r.itemSize, r.normalized)
                            }
                            void 0 !== r.name && (o.name = r.name), s.push(o)
                        }
                        r.morphAttributes[e] = s
                    }
                t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                const c = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== c)
                    for (let t = 0, e = c.length; t !== e; ++t) {
                        const e = c[t];
                        r.addGroup(e.start, e.count, e.materialIndex)
                    }
                const l = t.data.boundingSphere;
                if (void 0 !== l) {
                    const t = new x;
                    void 0 !== l.center && t.fromArray(l.center), r.boundingSphere = new B(t, l.radius)
                }
                return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
            }
        });

        function xa(t) {
            wo.call(this, t), this.options = {
                premultiplyAlpha: "none"
            }
        }

        function ba() {
            this.type = "ShapePath", this.color = new Vt, this.subPaths = [], this.currentPath = null
        }

        function Ma(t) {
            this.type = "Font", this.data = t
        }

        function wa(t, e, n, i, r) {
            const s = r.glyphs[t] || r.glyphs["?"];
            if (!s) return;
            const o = new ba;
            let a, c, l, h, u, p, d, f;
            if (s.o) {
                const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
                for (let r = 0, s = t.length; r < s;) {
                    switch (t[r++]) {
                        case "m":
                            a = t[r++] * e + n, c = t[r++] * e + i, o.moveTo(a, c);
                            break;
                        case "l":
                            a = t[r++] * e + n, c = t[r++] * e + i, o.lineTo(a, c);
                            break;
                        case "q":
                            l = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, p = t[r++] * e + i, o.quadraticCurveTo(u, p, l, h);
                            break;
                        case "b":
                            l = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, p = t[r++] * e + i, d = t[r++] * e + n, f = t[r++] * e + i, o.bezierCurveTo(u, p, d, f, l, h)
                    }
                }
            }
            return {
                offsetX: s.ha * e,
                path: o
            }
        }

        function Sa(t) {
            wo.call(this, t)
        }
        let Ta;
        xa.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: xa,
            isImageBitmapLoader: !0,
            setOptions: function (t) {
                return this.options = t, this
            },
            load: function (t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this,
                    s = xo.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                const o = {};
                o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(t, o).then((function (t) {
                    return t.blob()
                })).then((function (t) {
                    return createImageBitmap(t, r.options)
                })).then((function (n) {
                    xo.add(t, n), e && e(n), r.manager.itemEnd(t)
                })).catch((function (e) {
                    i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                })), r.manager.itemStart(t)
            }
        }), Object.assign(ba.prototype, {
            moveTo: function (t, e) {
                return this.currentPath = new $o, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
            },
            lineTo: function (t, e) {
                return this.currentPath.lineTo(t, e), this
            },
            quadraticCurveTo: function (t, e, n, i) {
                return this.currentPath.quadraticCurveTo(t, e, n, i), this
            },
            bezierCurveTo: function (t, e, n, i, r, s) {
                return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this
            },
            splineThru: function (t) {
                return this.currentPath.splineThru(t), this
            },
            toShapes: function (t, e) {
                function n(t) {
                    const e = [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n],
                            r = new ta;
                        r.curves = i.curves, e.push(r)
                    }
                    return e
                }

                function i(t, e) {
                    const n = e.length;
                    let i = !1;
                    for (let r = n - 1, s = 0; s < n; r = s++) {
                        let n = e[r],
                            o = e[s],
                            a = o.x - n.x,
                            c = o.y - n.y;
                        if (Math.abs(c) > Number.EPSILON) {
                            if (c < 0 && (n = e[s], a = -a, o = e[r], c = -c), t.y < n.y || t.y > o.y) continue;
                            if (t.y === n.y) {
                                if (t.x === n.x) return !0
                            } else {
                                const e = c * (t.x - n.x) - a * (t.y - n.y);
                                if (0 === e) return !0;
                                if (e < 0) continue;
                                i = !i
                            }
                        } else {
                            if (t.y !== n.y) continue;
                            if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0
                        }
                    }
                    return i
                }
                const r = Fs.isClockWise,
                    s = this.subPaths;
                if (0 === s.length) return [];
                if (!0 === e) return n(s);
                let o, a, c;
                const l = [];
                if (1 === s.length) return a = s[0], c = new ta, c.curves = a.curves, l.push(c), l;
                let h = !r(s[0].getPoints());
                h = t ? !h : h;
                const u = [],
                    p = [];
                let d, f, m = [],
                    g = 0;
                p[g] = void 0, m[g] = [];
                for (let e = 0, n = s.length; e < n; e++) a = s[e], d = a.getPoints(), o = r(d), o = t ? !o : o, o ? (!h && p[g] && g++, p[g] = {
                    s: new ta,
                    p: d
                }, p[g].s.curves = a.curves, h && g++, m[g] = []) : m[g].push({
                    h: a,
                    p: d[0]
                });
                if (!p[0]) return n(s);
                if (p.length > 1) {
                    let t = !1;
                    const e = [];
                    for (let t = 0, e = p.length; t < e; t++) u[t] = [];
                    for (let n = 0, r = p.length; n < r; n++) {
                        const r = m[n];
                        for (let s = 0; s < r.length; s++) {
                            const o = r[s];
                            let a = !0;
                            for (let r = 0; r < p.length; r++) i(o.p, p[r].p) && (n !== r && e.push({
                                froms: n,
                                tos: r,
                                hole: s
                            }), a ? (a = !1, u[r].push(o)) : t = !0);
                            a && u[n].push(o)
                        }
                    }
                    e.length > 0 && (t || (m = u))
                }
                for (let t = 0, e = p.length; t < e; t++) {
                    c = p[t].s, l.push(c), f = m[t];
                    for (let t = 0, e = f.length; t < e; t++) c.holes.push(f[t].h)
                }
                return l
            }
        }), Object.assign(Ma.prototype, {
            isFont: !0,
            generateShapes: function (t, e = 100) {
                const n = [],
                    i = function (t, e, n) {
                        const i = Array.from ? Array.from(t) : String(t).split(""),
                            r = e / n.resolution,
                            s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                            o = [];
                        let a = 0,
                            c = 0;
                        for (let t = 0; t < i.length; t++) {
                            const e = i[t];
                            if ("\n" === e) a = 0, c -= s;
                            else {
                                const t = wa(e, r, a, c, n);
                                a += t.offsetX, o.push(t.path)
                            }
                        }
                        return o
                    }(t, e, this.data);
                for (let t = 0, e = i.length; t < e; t++) Array.prototype.push.apply(n, i[t].toShapes());
                return n
            }
        }), Sa.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: Sa,
            load: function (t, e, n, i) {
                const r = this,
                    s = new To(this.manager);
                s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function (t) {
                    let n;
                    try {
                        n = JSON.parse(t)
                    } catch (e) {
                        n = JSON.parse(t.substring(65, t.length - 2))
                    }
                    const i = r.parse(n);
                    e && e(i)
                }), n, i)
            },
            parse: function (t) {
                return new Ma(t)
            }
        });
        const Aa = function () {
            return void 0 === Ta && (Ta = new(window.AudioContext || window.webkitAudioContext)), Ta
        };

        function La(t) {
            wo.call(this, t)
        }

        function Ca(t, e, n) {
            fa.call(this, void 0, n);
            const i = (new Vt).set(t),
                r = (new Vt).set(e),
                s = new x(i.r, i.g, i.b),
                o = new x(r.r, r.g, r.b),
                a = Math.sqrt(Math.PI),
                c = a * Math.sqrt(.75);
            this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(c)
        }

        function Pa(t, e) {
            fa.call(this, void 0, e);
            const n = (new Vt).set(t);
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
        La.prototype = Object.assign(Object.create(wo.prototype), {
            constructor: La,
            load: function (t, e, n, i) {
                const r = this,
                    s = new To(r.manager);
                s.setResponseType("arraybuffer"), s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function (n) {
                    try {
                        const t = n.slice(0);
                        Aa().decodeAudioData(t, (function (t) {
                            e(t)
                        }))
                    } catch (e) {
                        i && i(e), r.manager.itemError(t)
                    }
                }), n, i)
            }
        }), Ca.prototype = Object.assign(Object.create(fa.prototype), {
            constructor: Ca,
            isHemisphereLightProbe: !0,
            copy: function (t) {
                return fa.prototype.copy.call(this, t), this
            },
            toJSON: function (t) {
                return fa.prototype.toJSON.call(this, t)
            }
        }), Pa.prototype = Object.assign(Object.create(fa.prototype), {
            constructor: Pa,
            isAmbientLightProbe: !0,
            copy: function (t) {
                return fa.prototype.copy.call(this, t), this
            },
            toJSON: function (t) {
                return fa.prototype.toJSON.call(this, t)
            }
        });
        const Ea = new Y,
            Na = new Y;
        Object.assign(function () {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Ge, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ge, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            }
        }.prototype, {
            update: function (t) {
                const e = this._cache;
                if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                    e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                    const n = t.projectionMatrix.clone(),
                        i = e.eyeSep / 2,
                        r = i * e.near / e.focus,
                        s = e.near * Math.tan(c.DEG2RAD * e.fov * .5) / e.zoom;
                    let o, a;
                    Na.elements[12] = -i, Ea.elements[12] = i, o = -s * e.aspect + r, a = s * e.aspect + r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraL.projectionMatrix.copy(n), o = -s * e.aspect - r, a = s * e.aspect - r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraR.projectionMatrix.copy(n)
                }
                this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Na), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ea)
            }
        });
        class Oa {
            constructor(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = Da(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const e = Da();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }

        function Da() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        class Ia extends _t {
            constructor(t) {
                super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            }
            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
            }
            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
            }
            setBuffer(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            }
            play(t = 0) {
                if (!0 === this.isPlaying) return;
                if (!1 === this.hasPlaybackControl) return;
                this._startedAt = this.context.currentTime + t;
                const e = this.context.createBufferSource();
                return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
            }
            stop() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }
            getFilters() {
                return this.filters
            }
            setFilters(t) {
                return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
            }
            setDetune(t) {
                if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(t) {
                return this.setFilters(t ? [t] : [])
            }
            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 !== this.hasPlaybackControl && this.loop
            }
            setLoop(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this
            }
            setLoopStart(t) {
                return this.loopStart = t, this
            }
            setLoopEnd(t) {
                return this.loopEnd = t, this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }
        }

        function za(t, e, n) {
            let i, r, s;
            switch (this.binding = t, this.valueSize = n, e) {
                case "quaternion":
                    i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                    break;
                default:
                    i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
            }
            this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
        }
        Object.assign(za.prototype, {
            accumulate: function (t, e) {
                const n = this.buffer,
                    i = this.valueSize,
                    r = t * i + i;
                let s = this.cumulativeWeight;
                if (0 === s) {
                    for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                    s = e
                } else {
                    s += e;
                    const t = e / s;
                    this._mixBufferRegion(n, r, 0, t, i)
                }
                this.cumulativeWeight = s
            },
            accumulateAdditive: function (t) {
                const e = this.buffer,
                    n = this.valueSize,
                    i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
            },
            apply: function (t) {
                const e = this.valueSize,
                    n = this.buffer,
                    i = t * e + e,
                    r = this.cumulativeWeight,
                    s = this.cumulativeWeightAdditive,
                    o = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, i, t, 1 - r, e)
                }
                s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                for (let t = e, r = e + e; t !== r; ++t)
                    if (n[t] !== n[t + e]) {
                        o.setValue(n, i);
                        break
                    }
            },
            saveOriginalState: function () {
                const t = this.binding,
                    e = this.buffer,
                    n = this.valueSize,
                    i = n * this._origIndex;
                t.getValue(e, i);
                for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            },
            restoreOriginalState: function () {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            },
            _setAdditiveIdentityNumeric: function () {
                const t = this._addIndex * this.valueSize,
                    e = t + this.valueSize;
                for (let n = t; n < e; n++) this.buffer[n] = 0
            },
            _setAdditiveIdentityQuaternion: function () {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            },
            _setAdditiveIdentityOther: function () {
                const t = this._origIndex * this.valueSize,
                    e = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
            },
            _select: function (t, e, n, i, r) {
                if (i >= .5)
                    for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
            },
            _slerp: function (t, e, n, i) {
                _.slerpFlat(t, e, t, e, t, n, i)
            },
            _slerpAdditive: function (t, e, n, i, r) {
                const s = this._workIndex * r;
                _.multiplyQuaternionsFlat(t, s, t, e, t, n), _.slerpFlat(t, e, t, e, t, s, i)
            },
            _lerp: function (t, e, n, i, r) {
                const s = 1 - i;
                for (let o = 0; o !== r; ++o) {
                    const r = e + o;
                    t[r] = t[r] * s + t[n + o] * i
                }
            },
            _lerpAdditive: function (t, e, n, i, r) {
                for (let s = 0; s !== r; ++s) {
                    const r = e + s;
                    t[r] = t[r] + t[n + s] * i
                }
            }
        });
        const Ra = new RegExp("[\\[\\]\\.:\\/]", "g"),
            Fa = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
            Ua = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            Ba = /(WCOD+)?/.source.replace("WCOD", Fa),
            ka = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            Va = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            ja = new RegExp("^" + Ua + Ba + ka + Va + "$"),
            Ga = ["material", "materials", "bones"];

        function Wa(t, e, n) {
            const i = n || Ha.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, i)
        }

        function Ha(t, e, n) {
            this.path = e, this.parsedPath = n || Ha.parseTrackName(e), this.node = Ha.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }
        Object.assign(Wa.prototype, {
            getValue: function (t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            },
            setValue: function (t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
            },
            bind: function () {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            },
            unbind: function () {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }), Object.assign(Ha, {
            Composite: Wa,
            create: function (t, e, n) {
                return t && t.isAnimationObjectGroup ? new Ha.Composite(t, e, n) : new Ha(t, e, n)
            },
            sanitizeNodeName: function (t) {
                return t.replace(/\s/g, "_").replace(Ra, "")
            },
            parseTrackName: function (t) {
                const e = ja.exec(t);
                if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1); - 1 !== Ga.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            },
            findNode: function (t, e) {
                if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function (t) {
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if (r.name === e || r.uuid === e) return r;
                                const s = n(r.children);
                                if (s) return s
                            }
                            return null
                        },
                        i = n(t.children);
                    if (i) return i
                }
                return null
            }
        }), Object.assign(Ha.prototype, {
            _getValue_unavailable: function () {},
            _setValue_unavailable: function () {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function (t, e) {
                t[e] = this.node[this.propertyName]
            }, function (t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
            }, function (t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function (t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [[function (t, e) {
                this.targetObject[this.propertyName] = t[e]
            }, function (t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }, function (t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }, function (t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                this.resolvedProperty.fromArray(t, e)
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }]],
            getValue: function (t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function (t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function () {
                let t = this.node;
                const e = this.parsedPath,
                    n = e.objectName,
                    i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = Ha.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return;
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return;
                            if (!t.material.materials) return;
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return;
                            t = t.skeleton.bones;
                            for (let e = 0; e < t.length; e++)
                                if (t[e].name === i) {
                                    i = e;
                                    break
                                } break;
                        default:
                            if (void 0 === t[n]) return;
                            t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i]) return;
                        t = t[i]
                    }
                }
                const s = t[i];
                if (void 0 === s) {
                    e.nodeName;
                    return
                }
                let o = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry) return;
                        if (!t.geometry.isBufferGeometry) return;
                        if (!t.geometry.morphAttributes) return;
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
            },
            unbind: function () {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(Ha.prototype, {
            _getValue_unbound: Ha.prototype.getValue,
            _setValue_unbound: Ha.prototype.setValue
        }), Object.assign(function () {
            this.uuid = c.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            const t = {};
            this._indicesByUUID = t;
            for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            const e = this;
            this.stats = {
                objects: {
                    get total() {
                        return e._objects.length
                    },
                    get inUse() {
                        return this.total - e.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return e._bindings.length
                }
            }
        }.prototype, {
            isAnimationObjectGroup: !0,
            add: function () {
                const t = this._objects,
                    e = this._indicesByUUID,
                    n = this._paths,
                    i = this._parsedPaths,
                    r = this._bindings,
                    s = r.length;
                let o = void 0,
                    a = t.length,
                    c = this.nCachedObjects_;
                for (let l = 0, h = arguments.length; l !== h; ++l) {
                    const h = arguments[l],
                        u = h.uuid;
                    let p = e[u];
                    if (void 0 === p) {
                        p = a++, e[u] = p, t.push(h);
                        for (let t = 0, e = s; t !== e; ++t) r[t].push(new Ha(h, n[t], i[t]))
                    } else if (p < c) {
                        o = t[p];
                        const a = --c,
                            l = t[a];
                        e[l.uuid] = p, t[p] = l, e[u] = a, t[a] = h;
                        for (let t = 0, e = s; t !== e; ++t) {
                            const e = r[t],
                                s = e[a];
                            let o = e[p];
                            e[p] = s, void 0 === o && (o = new Ha(h, n[t], i[t])), e[a] = o
                        }
                    } else t[p]
                }
                this.nCachedObjects_ = c
            },
            remove: function () {
                const t = this._objects,
                    e = this._indicesByUUID,
                    n = this._bindings,
                    i = n.length;
                let r = this.nCachedObjects_;
                for (let s = 0, o = arguments.length; s !== o; ++s) {
                    const o = arguments[s],
                        a = o.uuid,
                        c = e[a];
                    if (void 0 !== c && c >= r) {
                        const s = r++,
                            l = t[s];
                        e[l.uuid] = c, t[c] = l, e[a] = s, t[s] = o;
                        for (let t = 0, e = i; t !== e; ++t) {
                            const e = n[t],
                                i = e[s],
                                r = e[c];
                            e[c] = i, e[s] = r
                        }
                    }
                }
                this.nCachedObjects_ = r
            },
            uncache: function () {
                const t = this._objects,
                    e = this._indicesByUUID,
                    n = this._bindings,
                    i = n.length;
                let r = this.nCachedObjects_,
                    s = t.length;
                for (let o = 0, a = arguments.length; o !== a; ++o) {
                    const a = arguments[o].uuid,
                        c = e[a];
                    if (void 0 !== c)
                        if (delete e[a], c < r) {
                            const o = --r,
                                a = t[o],
                                l = --s,
                                h = t[l];
                            e[a.uuid] = c, t[c] = a, e[h.uuid] = o, t[o] = h, t.pop();
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t],
                                    i = e[o],
                                    r = e[l];
                                e[c] = i, e[o] = r, e.pop()
                            }
                        } else {
                            const r = --s,
                                o = t[r];
                            r > 0 && (e[o.uuid] = c), t[c] = o, t.pop();
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t];
                                e[c] = e[r], e.pop()
                            }
                        }
                }
                this.nCachedObjects_ = r
            },
            subscribe_: function (t, e) {
                const n = this._bindingsIndicesByPath;
                let i = n[t];
                const r = this._bindings;
                if (void 0 !== i) return r[i];
                const s = this._paths,
                    o = this._parsedPaths,
                    a = this._objects,
                    c = a.length,
                    l = this.nCachedObjects_,
                    h = new Array(c);
                i = r.length, n[t] = i, s.push(t), o.push(e), r.push(h);
                for (let n = l, i = a.length; n !== i; ++n) {
                    const i = a[n];
                    h[n] = new Ha(i, t, e)
                }
                return h
            },
            unsubscribe_: function (t) {
                const e = this._bindingsIndicesByPath,
                    n = e[t];
                if (void 0 !== n) {
                    const i = this._paths,
                        r = this._parsedPaths,
                        s = this._bindings,
                        o = s.length - 1,
                        a = s[o];
                    e[t[o]] = n, s[n] = a, s.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                }
            }
        });
        class qa {
            constructor(t, e, n = null, i = e.blendMode) {
                this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                const r = e.tracks,
                    s = r.length,
                    o = new Array(s),
                    a = {
                        endingStart: 2400,
                        endingEnd: 2400
                    };
                for (let t = 0; t !== s; ++t) {
                    const e = r[t].createInterpolant(null);
                    o[t] = e, e.settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this), this
            }
            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }
            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(t) {
                return this._startTime = t, this
            }
            setLoop(t, e) {
                return this.loop = t, this.repetitions = e, this
            }
            setEffectiveWeight(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e), this.fadeIn(e), n) {
                    const n = this._clip.duration,
                        i = t._clip.duration,
                        r = i / n,
                        s = n / i;
                    t.warp(1, r, e), this.warp(s, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, n) {
                const i = this._mixer,
                    r = i.time,
                    s = this.timeScale;
                let o = this._timeScaleInterpolant;
                null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                const a = o.parameterPositions,
                    c = o.sampleValues;
                return a[0] = r, a[1] = r + n, c[0] = t / s, c[1] = e / s, this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(t, e, n, i) {
                if (!this.enabled) return void this._updateWeight(t);
                const r = this._startTime;
                if (null !== r) {
                    const i = (t - r) * n;
                    if (i < 0 || 0 === n) return;
                    this._startTime = null, e = n * i
                }
                e *= this._updateTimeScale(t);
                const s = this._updateTime(e),
                    o = this._updateWeight(t);
                if (o > 0) {
                    const t = this._interpolants,
                        e = this._propertyBindings;
                    switch (this.blendMode) {
                        case 2501:
                            for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
                            break;
                        case 2500:
                        default:
                            for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, o)
                    }
                }
            }
            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(t)[0];
                        e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            }
            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e, e
            }
            _updateTime(t) {
                const e = this._clip.duration,
                    n = this.loop;
                let i = this.time + t,
                    r = this._loopCount;
                const s = 2202 === n;
                if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (i >= e) i = e;
                        else {
                            if (!(i < 0)) {
                                this.time = i;
                                break t
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
                        const n = Math.floor(i / e);
                        i -= e * n, r += Math.abs(n);
                        const o = this.repetitions - r;
                        if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                        else {
                            if (1 === o) {
                                const e = t < 0;
                                this._setEndings(e, !e, s)
                            } else this._setEndings(!1, !1, s);
                            this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else this.time = i;
                    if (s && 1 == (1 & r)) return e - i
                }
                return i
            }
            _setEndings(t, e, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            }
            _scheduleFading(t, e, n) {
                const i = this._mixer,
                    r = i.time;
                let s = this._weightInterpolant;
                null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                const o = s.parameterPositions,
                    a = s.sampleValues;
                return o[0] = r, a[0] = e, o[1] = r + t, a[1] = n, this
            }
        }

        function Xa(t) {
            this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }
        Xa.prototype = Object.assign(Object.create(s.prototype), {
            constructor: Xa,
            _bindAction: function (t, e) {
                const n = t._localRoot || this._root,
                    i = t._clip.tracks,
                    r = i.length,
                    s = t._propertyBindings,
                    o = t._interpolants,
                    a = n.uuid,
                    c = this._bindingsByRootAndName;
                let l = c[a];
                void 0 === l && (l = {}, c[a] = l);
                for (let t = 0; t !== r; ++t) {
                    const r = i[t],
                        c = r.name;
                    let h = l[c];
                    if (void 0 !== h) s[t] = h;
                    else {
                        if (h = s[t], void 0 !== h) {
                            null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, c));
                            continue
                        }
                        const i = e && e._propertyBindings[t].binding.parsedPath;
                        h = new za(Ha.create(n, c, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, a, c), s[t] = h
                    }
                    o[t].resultBuffer = h.buffer
                }
            },
            _activateAction: function (t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid,
                            n = t._clip.uuid,
                            i = this._actionsByClip[n];
                        this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function (t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function () {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function (t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            },
            _addInactiveAction: function (t, e, n) {
                const i = this._actions,
                    r = this._actionsByClip;
                let s = r[e];
                if (void 0 === s) s = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, r[e] = s;
                else {
                    const e = s.knownActions;
                    t._byClipCacheIndex = e.length, e.push(t)
                }
                t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t
            },
            _removeInactiveAction: function (t) {
                const e = this._actions,
                    n = e[e.length - 1],
                    i = t._cacheIndex;
                n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                const r = t._clip.uuid,
                    s = this._actionsByClip,
                    o = s[r],
                    a = o.knownActions,
                    c = a[a.length - 1],
                    l = t._byClipCacheIndex;
                c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null;
                delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[r], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function (t) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            },
            _lendAction: function (t) {
                const e = this._actions,
                    n = t._cacheIndex,
                    i = this._nActiveActions++,
                    r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            },
            _takeBackAction: function (t) {
                const e = this._actions,
                    n = t._cacheIndex,
                    i = --this._nActiveActions,
                    r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            },
            _addInactiveBinding: function (t, e, n) {
                const i = this._bindingsByRootAndName,
                    r = this._bindings;
                let s = i[e];
                void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t)
            },
            _removeInactiveBinding: function (t) {
                const e = this._bindings,
                    n = t.binding,
                    i = n.rootNode.uuid,
                    r = n.path,
                    s = this._bindingsByRootAndName,
                    o = s[i],
                    a = e[e.length - 1],
                    c = t._cacheIndex;
                a._cacheIndex = c, e[c] = a, e.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i]
            },
            _lendBinding: function (t) {
                const e = this._bindings,
                    n = t._cacheIndex,
                    i = this._nActiveBindings++,
                    r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            },
            _takeBackBinding: function (t) {
                const e = this._bindings,
                    n = t._cacheIndex,
                    i = --this._nActiveBindings,
                    r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            },
            _lendControlInterpolant: function () {
                const t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new ao(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
            },
            _takeBackControlInterpolant: function (t) {
                const e = this._controlInterpolants,
                    n = t.__cacheIndex,
                    i = --this._nActiveControlInterpolants,
                    r = e[i];
                t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function (t, e, n) {
                const i = e || this._root,
                    r = i.uuid;
                let s = "string" == typeof t ? yo.findByName(i, t) : t;
                const o = null !== s ? s.uuid : t,
                    a = this._actionsByClip[o];
                let c = null;
                if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== a) {
                    const t = a.actionByRoot[r];
                    if (void 0 !== t && t.blendMode === n) return t;
                    c = a.knownActions[0], null === s && (s = c._clip)
                }
                if (null === s) return null;
                const l = new qa(this, s, e, n);
                return this._bindAction(l, c), this._addInactiveAction(l, o, r), l
            },
            existingAction: function (t, e) {
                const n = e || this._root,
                    i = n.uuid,
                    r = "string" == typeof t ? yo.findByName(n, t) : t,
                    s = r ? r.uuid : t,
                    o = this._actionsByClip[s];
                return void 0 !== o && o.actionByRoot[i] || null
            },
            stopAllAction: function () {
                const t = this._actions;
                for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                return this
            },
            update: function (t) {
                t *= this.timeScale;
                const e = this._actions,
                    n = this._nActiveActions,
                    i = this.time += t,
                    r = Math.sign(t),
                    s = this._accuIndex ^= 1;
                for (let o = 0; o !== n; ++o) {
                    e[o]._update(i, t, r, s)
                }
                const o = this._bindings,
                    a = this._nActiveBindings;
                for (let t = 0; t !== a; ++t) o[t].apply(s);
                return this
            },
            setTime: function (t) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(t)
            },
            getRoot: function () {
                return this._root
            },
            uncacheClip: function (t) {
                const e = this._actions,
                    n = t.uuid,
                    i = this._actionsByClip,
                    r = i[n];
                if (void 0 !== r) {
                    const t = r.knownActions;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const i = t[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex,
                            s = e[e.length - 1];
                        i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            },
            uncacheRoot: function (t) {
                const e = t.uuid,
                    n = this._actionsByClip;
                for (const t in n) {
                    const i = n[t].actionByRoot[e];
                    void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName[e];
                if (void 0 !== i)
                    for (const t in i) {
                        const e = i[t];
                        e.restoreOriginalState(), this._removeInactiveBinding(e)
                    }
            },
            uncacheAction: function (t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        });
        class Ya {
            constructor(t) {
                "string" == typeof t && (t = arguments[1]), this.value = t
            }
            clone() {
                return new Ya(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }

        function Za(t, e, n) {
            ar.call(this, t, e), this.meshPerAttribute = n || 1
        }

        function Ja(t, e, n, i, r) {
            this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
        }

        function Qa(t, e, n, i) {
            this.ray = new X(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new st, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function () {
                        return this.Points
                    }
                }
            })
        }

        function Ka(t, e) {
            return t.distance - e.distance
        }

        function $a(t, e, n, i) {
            if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
                const i = t.children;
                for (let t = 0, r = i.length; t < r; t++) $a(i[t], e, n, !0)
            }
        }
        Za.prototype = Object.assign(Object.create(ar.prototype), {
            constructor: Za,
            isInstancedInterleavedBuffer: !0,
            copy: function (t) {
                return ar.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            },
            clone: function (t) {
                const e = ar.prototype.clone.call(this, t);
                return e.meshPerAttribute = this.meshPerAttribute, e
            },
            toJSON: function (t) {
                const e = ar.prototype.toJSON.call(this, t);
                return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
            }
        }), Object.defineProperty(Ja.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), Object.assign(Ja.prototype, {
            isGLBufferAttribute: !0,
            setBuffer: function (t) {
                return this.buffer = t, this
            },
            setType: function (t, e) {
                return this.type = t, this.elementSize = e, this
            },
            setItemSize: function (t) {
                return this.itemSize = t, this
            },
            setCount: function (t) {
                return this.count = t, this
            }
        }), Object.assign(Qa.prototype, {
            set: function (t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function (t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera && (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e)
            },
            intersectObject: function (t, e, n) {
                const i = n || [];
                return $a(t, this, i, e), i.sort(Ka), i
            },
            intersectObjects: function (t, e, n) {
                const i = n || [];
                if (!1 === Array.isArray(t)) return i;
                for (let n = 0, r = t.length; n < r; n++) $a(t[n], this, i, e);
                return i.sort(Ka), i
            }
        });
        const tc = new l;
        const ec = new x,
            nc = new x;

        function ic(t) {
            _t.call(this), this.material = t, this.render = function () {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
        }
        ic.prototype = Object.create(_t.prototype), ic.prototype.constructor = ic, ic.prototype.isImmediateRenderObject = !0;
        const rc = new x,
            sc = new Y,
            oc = new Y;
        const ac = new Float32Array(1),
            cc = (new Int32Array(ac.buffer), Math.pow(2, 8), [.125, .215, .35, .446, .526, .582]),
            lc = 5 + cc.length,
            {
                _lodPlanes: hc,
                _sizeLods: uc,
                _sigmas: pc
            } = dc();
        Math.sqrt(5);

        function dc() {
            const t = [],
                e = [],
                n = [];
            let i = 8;
            for (let r = 0; r < lc; r++) {
                const s = Math.pow(2, i);
                e.push(s);
                let o = 1 / s;
                r > 4 ? o = cc[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o);
                const a = 1 / (s - 1),
                    c = -a / 2,
                    l = 1 + a / 2,
                    h = [c, c, l, c, l, l, c, c, l, l, c, l],
                    u = 6,
                    p = 6,
                    d = 3,
                    f = 2,
                    m = 1,
                    g = new Float32Array(d * p * u),
                    v = new Float32Array(f * p * u),
                    y = new Float32Array(m * p * u);
                for (let t = 0; t < u; t++) {
                    const e = t % 3 * 2 / 3 - 1,
                        n = t > 2 ? 0 : -1,
                        i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    g.set(i, d * p * t), v.set(h, f * p * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, m * p * t)
                }
                const _ = new ge;
                _.setAttribute("position", new Yt(g, d)), _.setAttribute("uv", new Yt(v, f)), _.setAttribute("faceIndex", new Yt(y, m)), t.push(_), i > 4 && i--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }

        function fc(t) {
            ko.call(this, t), this.type = "catmullrom"
        }
        Oo.create = function (t, e) {
            return t.prototype = Object.create(Oo.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, Object.assign(Ko.prototype, {
            createPointsGeometry: function (t) {
                const e = this.getPoints(t);
                return this.createGeometry(e)
            },
            createSpacedPointsGeometry: function (t) {
                const e = this.getSpacedPoints(t);
                return this.createGeometry(e)
            },
            createGeometry: function (t) {
                const e = new us;
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.vertices.push(new x(i.x, i.y, i.z || 0))
                }
                return e
            }
        }), Object.assign($o.prototype, {
            fromPoints: function (t) {
                return this.setFromPoints(t)
            }
        }), Object.create(ko.prototype), Object.create(ko.prototype), fc.prototype = Object.create(ko.prototype), Object.assign(fc.prototype, {
            initFromArray: function () {},
            getControlPointsArray: function () {},
            reparametrizeByArcLength: function () {}
        }), class extends Yr {
            constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
                n = new Vt(n), i = new Vt(i);
                const r = e / 2,
                    s = t / e,
                    o = t / 2,
                    a = [],
                    c = [];
                for (let t = 0, l = 0, h = -o; t <= e; t++, h += s) {
                    a.push(-o, 0, h, o, 0, h), a.push(h, 0, -o, h, 0, o);
                    const e = t === r ? n : i;
                    e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3
                }
                const l = new ge;
                l.setAttribute("position", new ie(a, 3)), l.setAttribute("color", new ie(c, 3));
                super(l, new Br({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "GridHelper"
            }
        }.prototype.setColors = function () {}, class extends Yr {
            constructor(t) {
                const e = function t(e) {
                        const n = [];
                        e && e.isBone && n.push(e);
                        for (let i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                        return n
                    }(t),
                    n = new ge,
                    i = [],
                    r = [],
                    s = new Vt(0, 0, 1),
                    o = new Vt(0, 1, 0);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
                }
                n.setAttribute("position", new ie(i, 3)), n.setAttribute("color", new ie(r, 3));
                super(n, new Br({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(t) {
                const e = this.bones,
                    n = this.geometry,
                    i = n.getAttribute("position");
                oc.copy(this.root.matrixWorld).invert();
                for (let t = 0, n = 0; t < e.length; t++) {
                    const r = e[t];
                    r.parent && r.parent.isBone && (sc.multiplyMatrices(oc, r.matrixWorld), rc.setFromMatrixPosition(sc), i.setXYZ(n, rc.x, rc.y, rc.z), sc.multiplyMatrices(oc, r.parent.matrixWorld), rc.setFromMatrixPosition(sc), i.setXYZ(n + 1, rc.x, rc.y, rc.z), n += 2)
                }
                n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
            }
        }.prototype.update = function () {}, Object.assign(wo.prototype, {
            extractUrlBase: function (t) {
                return ga(t)
            }
        }), wo.Handlers = {
            add: function () {},
            get: function () {}
        }, Object.assign(class {
            constructor(t, e) {
                Object.defineProperty(this, "isBox2", {
                    value: !0
                }), this.min = void 0 !== t ? t : new l(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new l(-1 / 0, -1 / 0)
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = tc.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(t) {
                return void 0 === t && (t = new l), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (t = new l), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }
            getParameter(t, e) {
                return void 0 === e && (e = new l), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }
            clampPoint(t, e) {
                return void 0 === e && (e = new l), e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return tc.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }.prototype, {
            center: function (t) {
                return this.getCenter(t)
            },
            empty: function () {
                return this.isEmpty()
            },
            isIntersectionBox: function (t) {
                return this.intersectsBox(t)
            },
            size: function (t) {
                return this.getSize(t)
            }
        }), Object.assign(w.prototype, {
            center: function (t) {
                return this.getCenter(t)
            },
            empty: function () {
                return this.isEmpty()
            },
            isIntersectionBox: function (t) {
                return this.intersectsBox(t)
            },
            isIntersectionSphere: function (t) {
                return this.intersectsSphere(t)
            },
            size: function (t) {
                return this.getSize(t)
            }
        }), Object.assign(B.prototype, {
            empty: function () {
                return this.isEmpty()
            }
        }), Je.prototype.setFromMatrix = function (t) {
            return this.setFromProjectionMatrix(t)
        }, class {
            constructor(t, e) {
                this.start = void 0 !== t ? t : new x, this.end = void 0 !== e ? e : new x
            }
            set(t, e) {
                return this.start.copy(t), this.end.copy(e), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            }
            getCenter(t) {
                return void 0 === t && (t = new x), t.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(t) {
                return void 0 === t && (t = new x), t.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(t, e) {
                return void 0 === e && (e = new x), this.delta(e).multiplyScalar(t).add(this.start)
            }
            closestPointToPointParameter(t, e) {
                ec.subVectors(t, this.start), nc.subVectors(this.end, this.start);
                const n = nc.dot(nc);
                let i = nc.dot(ec) / n;
                return e && (i = c.clamp(i, 0, 1)), i
            }
            closestPointToPoint(t, e, n) {
                const i = this.closestPointToPointParameter(t, e);
                return void 0 === n && (n = new x), this.delta(n).multiplyScalar(i).add(this.start)
            }
            applyMatrix4(t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            }
            equals(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }.prototype.center = function (t) {
            return this.getCenter(t)
        }, Object.assign(c, {
            random16: function () {
                return Math.random()
            },
            nearestPowerOfTwo: function (t) {
                return c.floorPowerOfTwo(t)
            },
            nextPowerOfTwo: function (t) {
                return c.ceilPowerOfTwo(t)
            }
        }), Object.assign(h.prototype, {
            flattenToArrayOffset: function (t, e) {
                return this.toArray(t, e)
            },
            multiplyVector3: function (t) {
                return t.applyMatrix3(this)
            },
            multiplyVector3Array: function () {},
            applyToBufferAttribute: function (t) {
                return t.applyMatrix3(this)
            },
            applyToVector3Array: function () {},
            getInverse: function (t) {
                return this.copy(t).invert()
            }
        }), Object.assign(Y.prototype, {
            extractPosition: function (t) {
                return this.copyPosition(t)
            },
            flattenToArrayOffset: function (t, e) {
                return this.toArray(t, e)
            },
            getPosition: function () {
                return (new x).setFromMatrixColumn(this, 3)
            },
            setRotationFromQuaternion: function (t) {
                return this.makeRotationFromQuaternion(t)
            },
            multiplyToArray: function () {},
            multiplyVector3: function (t) {
                return t.applyMatrix4(this)
            },
            multiplyVector4: function (t) {
                return t.applyMatrix4(this)
            },
            multiplyVector3Array: function () {},
            rotateAxis: function (t) {
                t.transformDirection(this)
            },
            crossVector: function (t) {
                return t.applyMatrix4(this)
            },
            translate: function () {},
            rotateX: function () {},
            rotateY: function () {},
            rotateZ: function () {},
            rotateByAxis: function () {},
            applyToBufferAttribute: function (t) {
                return t.applyMatrix4(this)
            },
            applyToVector3Array: function () {},
            makeFrustum: function (t, e, n, i, r, s) {
                return this.makePerspective(t, e, i, n, r, s)
            },
            getInverse: function (t) {
                return this.copy(t).invert()
            }
        }), wt.prototype.isIntersectionLine = function (t) {
            return this.intersectsLine(t)
        }, Object.assign(_.prototype, {
            multiplyVector3: function (t) {
                return t.applyQuaternion(this)
            },
            inverse: function () {
                return this.invert()
            }
        }), Object.assign(X.prototype, {
            isIntersectionBox: function (t) {
                return this.intersectsBox(t)
            },
            isIntersectionPlane: function (t) {
                return this.intersectsPlane(t)
            },
            isIntersectionSphere: function (t) {
                return this.intersectsSphere(t)
            }
        }), Object.assign(It.prototype, {
            area: function () {
                return this.getArea()
            },
            barycoordFromPoint: function (t, e) {
                return this.getBarycoord(t, e)
            },
            midpoint: function (t) {
                return this.getMidpoint(t)
            },
            normal: function (t) {
                return this.getNormal(t)
            },
            plane: function (t) {
                return this.getPlane(t)
            }
        }), Object.assign(It, {
            barycoordFromPoint: function (t, e, n, i, r) {
                return It.getBarycoord(t, e, n, i, r)
            },
            normal: function (t, e, n, i) {
                return It.getNormal(t, e, n, i)
            }
        }), Object.assign(ta.prototype, {
            extractAllPoints: function (t) {
                return this.extractPoints(t)
            },
            extrude: function (t) {
                return new js(this, t)
            },
            makeGeometry: function (t) {
                return new qs(this, t)
            }
        }), Object.assign(l.prototype, {
            fromAttribute: function (t, e, n) {
                return this.fromBufferAttribute(t, e, n)
            },
            distanceToManhattan: function (t) {
                return this.manhattanDistanceTo(t)
            },
            lengthManhattan: function () {
                return this.manhattanLength()
            }
        }), Object.assign(x.prototype, {
            setEulerFromRotationMatrix: function () {},
            setEulerFromQuaternion: function () {},
            getPositionFromMatrix: function (t) {
                return this.setFromMatrixPosition(t)
            },
            getScaleFromMatrix: function (t) {
                return this.setFromMatrixScale(t)
            },
            getColumnFromMatrix: function (t, e) {
                return this.setFromMatrixColumn(e, t)
            },
            applyProjection: function (t) {
                return this.applyMatrix4(t)
            },
            fromAttribute: function (t, e, n) {
                return this.fromBufferAttribute(t, e, n)
            },
            distanceToManhattan: function (t) {
                return this.manhattanDistanceTo(t)
            },
            lengthManhattan: function () {
                return this.manhattanLength()
            }
        }), Object.assign(g.prototype, {
            fromAttribute: function (t, e, n) {
                return this.fromBufferAttribute(t, e, n)
            },
            lengthManhattan: function () {
                return this.manhattanLength()
            }
        }), Object.assign(us.prototype, {
            computeTangents: function () {},
            computeLineDistances: function () {},
            applyMatrix: function (t) {
                return this.applyMatrix4(t)
            }
        }), Object.assign(_t.prototype, {
            getChildByName: function (t) {
                return this.getObjectByName(t)
            },
            renderDepth: function () {},
            translate: function (t, e) {
                return this.translateOnAxis(e, t)
            },
            getWorldRotation: function () {},
            applyMatrix: function (t) {
                return this.applyMatrix4(t)
            }
        }), Object.defineProperties(_t.prototype, {
            eulerOrder: {
                get: function () {
                    return this.rotation.order
                },
                set: function (t) {
                    this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function () {},
                set: function () {}
            }
        }), Object.assign(Ie.prototype, {
            setDrawMode: function () {}
        }), Object.defineProperties(Ie.prototype, {
            drawMode: {
                get: function () {
                    return 0
                },
                set: function () {}
            }
        }), Object.defineProperties(Cr.prototype, {
            objects: {
                get: function () {
                    return this.levels
                }
            }
        }), Object.defineProperty(Dr.prototype, "useVertexTexture", {
            get: function () {},
            set: function () {}
        }), Pr.prototype.initBones = function () {}, Object.defineProperty(Oo.prototype, "__arcLengthDivisions", {
            get: function () {
                return this.arcLengthDivisions
            },
            set: function (t) {
                this.arcLengthDivisions = t
            }
        }), Ge.prototype.setLens = function (t, e) {
            void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(ea.prototype, {
            onlyShadow: {
                set: function () {}
            },
            shadowCameraFov: {
                set: function (t) {
                    this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function (t) {
                    this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function (t) {
                    this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function (t) {
                    this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function (t) {
                    this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function (t) {
                    this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function (t) {
                    this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function () {}
            },
            shadowBias: {
                set: function (t) {
                    this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function () {}
            },
            shadowMapWidth: {
                set: function (t) {
                    this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function (t) {
                    this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(Yt.prototype, {
            length: {
                get: function () {
                    return this.array.length
                }
            },
            dynamic: {
                get: function () {
                    return 35048 === this.usage
                },
                set: function () {
                    this.setUsage(35048)
                }
            }
        }), Object.assign(Yt.prototype, {
            setDynamic: function (t) {
                return this.setUsage(!0 === t ? 35048 : 35044), this
            },
            copyIndicesArray: function () {},
            setArray: function () {}
        }), Object.assign(ge.prototype, {
            addIndex: function (t) {
                this.setIndex(t)
            },
            addAttribute: function (t, e) {
                return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (this.setIndex(e), this) : this.setAttribute(t, e) : this.setAttribute(t, new Yt(arguments[1], arguments[2]))
            },
            addDrawCall: function (t, e, n) {
                this.addGroup(t, e)
            },
            clearDrawCalls: function () {
                this.clearGroups()
            },
            computeTangents: function () {},
            computeOffsets: function () {},
            removeAttribute: function (t) {
                return this.deleteAttribute(t)
            },
            applyMatrix: function (t) {
                return this.applyMatrix4(t)
            }
        }), Object.defineProperties(ge.prototype, {
            drawcalls: {
                get: function () {
                    return this.groups
                }
            },
            offsets: {
                get: function () {
                    return this.groups
                }
            }
        }), Object.defineProperties(va.prototype, {
            maxInstancedCount: {
                get: function () {
                    return this.instanceCount
                },
                set: function (t) {
                    this.instanceCount = t
                }
            }
        }), Object.defineProperties(Qa.prototype, {
            linePrecision: {
                get: function () {
                    return this.params.Line.threshold
                },
                set: function (t) {
                    this.params.Line.threshold = t
                }
            }
        }), Object.defineProperties(ar.prototype, {
            dynamic: {
                get: function () {
                    return 35048 === this.usage
                },
                set: function (t) {
                    this.setUsage(t)
                }
            }
        }), Object.assign(ar.prototype, {
            setDynamic: function (t) {
                return this.setUsage(!0 === t ? 35048 : 35044), this
            },
            setArray: function () {}
        }), Object.assign(ks.prototype, {
            getArrays: function () {},
            addShapeList: function () {},
            addShape: function () {}
        }), Object.assign(or.prototype, {
            dispose: function () {}
        }), Object.defineProperties(Ya.prototype, {
            dynamic: {
                set: function () {}
            },
            onUpdate: {
                value: function () {
                    return this
                }
            }
        }), Object.defineProperties(Wt.prototype, {
            wrapAround: {
                get: function () {},
                set: function () {}
            },
            overdraw: {
                get: function () {},
                set: function () {}
            },
            wrapRGB: {
                get: function () {
                    return new Vt
                }
            },
            shading: {
                get: function () {},
                set: function (t) {
                    this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function () {
                    return this.stencilFuncMask
                },
                set: function (t) {
                    this.stencilFuncMask = t
                }
            }
        }), Object.defineProperties(Qs.prototype, {
            metal: {
                get: function () {
                    return !1
                },
                set: function () {}
            }
        }), Object.defineProperties(Js.prototype, {
            transparency: {
                get: function () {
                    return this.transmission
                },
                set: function (t) {
                    this.transmission = t
                }
            }
        }), Object.defineProperties(Ve.prototype, {
            derivatives: {
                get: function () {
                    return this.extensions.derivatives
                },
                set: function (t) {
                    this.extensions.derivatives = t
                }
            }
        }), Object.assign(rr.prototype, {
            clearTarget: function (t, e, n, i) {
                this.setRenderTarget(t), this.clear(e, n, i)
            },
            animate: function (t) {
                this.setAnimationLoop(t)
            },
            getCurrentRenderTarget: function () {
                return this.getRenderTarget()
            },
            getMaxAnisotropy: function () {
                return this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function () {
                return this.capabilities.precision
            },
            resetGLState: function () {
                return this.state.reset()
            },
            supportsFloatTextures: function () {
                return this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function () {
                return this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function () {
                return this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function () {
                return this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function () {
                return this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function () {
                return this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function () {
                return this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function () {
                return this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function (t) {
                this.setScissorTest(t)
            },
            initMaterial: function () {},
            addPrePlugin: function () {},
            addPostPlugin: function () {},
            updateShadowMap: function () {},
            setFaceCulling: function () {},
            allocTextureUnit: function () {},
            setTexture: function () {},
            setTexture2D: function () {},
            setTextureCube: function () {},
            getActiveMipMapLevel: function () {
                return this.getActiveMipmapLevel()
            }
        }), Object.defineProperties(rr.prototype, {
            shadowMapEnabled: {
                get: function () {
                    return this.shadowMap.enabled
                },
                set: function (t) {
                    this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function () {
                    return this.shadowMap.type
                },
                set: function (t) {
                    this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function () {},
                set: function () {}
            },
            context: {
                get: function () {
                    return this.getContext()
                }
            },
            vr: {
                get: function () {
                    return this.xr
                }
            },
            gammaInput: {
                get: function () {
                    return !1
                },
                set: function () {}
            },
            gammaOutput: {
                get: function () {
                    return !1
                },
                set: function (t) {
                    this.outputEncoding = !0 === t ? 3001 : 3e3
                }
            },
            toneMappingWhitePoint: {
                get: function () {
                    return 1
                },
                set: function () {}
            }
        }), Object.defineProperties(Zi.prototype, {
            cullFace: {
                get: function () {},
                set: function () {}
            },
            renderReverseSided: {
                get: function () {},
                set: function () {}
            },
            renderSingleSided: {
                get: function () {},
                set: function () {}
            }
        }), Object.defineProperties(v.prototype, {
            wrapS: {
                get: function () {
                    return this.texture.wrapS
                },
                set: function (t) {
                    this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function () {
                    return this.texture.wrapT
                },
                set: function (t) {
                    this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function () {
                    return this.texture.magFilter
                },
                set: function (t) {
                    this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function () {
                    return this.texture.minFilter
                },
                set: function (t) {
                    this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function () {
                    return this.texture.anisotropy
                },
                set: function (t) {
                    this.texture.anisotropy = t
                }
            },
            offset: {
                get: function () {
                    return this.texture.offset
                },
                set: function (t) {
                    this.texture.offset = t
                }
            },
            repeat: {
                get: function () {
                    return this.texture.repeat
                },
                set: function (t) {
                    this.texture.repeat = t
                }
            },
            format: {
                get: function () {
                    return this.texture.format
                },
                set: function (t) {
                    this.texture.format = t
                }
            },
            type: {
                get: function () {
                    return this.texture.type
                },
                set: function (t) {
                    this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function () {
                    return this.texture.generateMipmaps
                },
                set: function (t) {
                    this.texture.generateMipmaps = t
                }
            }
        }), Object.defineProperties(Ia.prototype, {
            load: {
                value: function (t) {
                    const e = this;
                    return (new La).load(t, (function (t) {
                        e.setBuffer(t)
                    })), this
                }
            },
            startTime: {
                set: function () {}
            }
        }), class {
            constructor(t, e = 2048) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            }
            getAverageFrequency() {
                let t = 0;
                const e = this.getFrequencyData();
                for (let n = 0; n < e.length; n++) t += e[n];
                return t / e.length
            }
        }.prototype.getData = function () {
            return this.getFrequencyData()
        }, We.prototype.updateCubeMap = function (t, e) {
            return this.update(t, e)
        }, We.prototype.clear = function (t, e, n, i) {
            return this.renderTarget.clear(t, e, n, i)
        };
        p.crossOrigin = void 0, p.loadTexture = function (t, e, n, i) {
            const r = new No;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e), s
        }, p.loadTextureCube = function (t, e, n, i) {
            const r = new Po;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e), s
        }, p.loadCompressedTexture = function () {}, p.loadCompressedTextureCube = function () {};
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: "123"
            }
        }))
    },
    avP6: function (t, e, n) {
        "use strict";
        var i = function () {
                return (i = Object.assign || function (t) {
                    for (var e, n = 1, i = arguments.length; n < i; n++)
                        for (var r in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                    return t
                }).apply(this, arguments)
            },
            r = function () {
                return "undefined" != typeof window && !!window.document && !!window.document.createElement
            },
            s = function () {
                function t() {
                    var t = this;
                    this.handleWheel = function (t) {
                        t.preventDefault()
                    }, this.handleScroll = function () {
                        window.scrollTo.apply(window, t.lockToScrollPos)
                    }, this.handleKeydown = function (e) {
                        var n = t.options.keyboardKeys;
                        ["INPUT", "TEXTAREA"].includes(e.target.tagName) && (n = n.filter((function (e) {
                            return !t.options.authorizedInInputs.includes(e)
                        }))), n.includes(e.keyCode) && e.preventDefault()
                    }, this.element = null, this.lockToScrollPos = [0, 0], this.options = {
                        authorizedInInputs: [32, 37, 38, 39, 40],
                        disableKeys: !0,
                        disableScroll: !0,
                        disableWheel: !0,
                        keyboardKeys: [32, 33, 34, 35, 36, 37, 38, 39, 40]
                    }, r() && (this.element = document.scrollingElement)
                }
                return t.prototype.on = function (t, e) {
                    var n, s, o, a;
                    if (r()) {
                        this.element = t || this.element, this.options = i(i({}, this.options), e);
                        var c = this.options,
                            l = c.disableKeys,
                            h = c.disableScroll;
                        c.disableWheel && (document.addEventListener("wheel", this.handleWheel, {
                            passive: !1
                        }), document.addEventListener("touchmove", this.handleWheel, {
                            passive: !1
                        })), h && (this.lockToScrollPos = [null !== (s = null === (n = this.element) || void 0 === n ? void 0 : n.scrollLeft) && void 0 !== s ? s : 0, null !== (a = null === (o = this.element) || void 0 === o ? void 0 : o.scrollTop) && void 0 !== a ? a : 0], document.addEventListener("scroll", this.handleScroll, {
                            passive: !1
                        })), l && document.addEventListener("keydown", this.handleKeydown, {
                            passive: !1
                        })
                    }
                }, t.prototype.off = function () {
                    r() && (document.removeEventListener("wheel", this.handleWheel), document.removeEventListener("touchmove", this.handleWheel), document.removeEventListener("scroll", this.handleScroll), document.removeEventListener("keydown", this.handleKeydown))
                }, t
            }();
        e.a = new s
    },
    "k+my": function (t, e, n) {
        "use strict";
        n.d(e, "a", (function () {
            return r
        }));
        var i = n("G1Ma"),
            r = function (t, e, n, r, s) {
                i.a.call(this), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== s ? s : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1
            };
        r.prototype = Object.assign(Object.create(i.a.prototype), {
            constructor: r,
            render: function (t, e, n) {
                var i, r, s, o = t.autoClear;
                t.autoClear = !1, void 0 !== this.overrideMaterial && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (i = t.getClearColor().getHex(), r = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(i, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s), t.autoClear = o
            }
        })
    },
    ls82: function (t, e, n) {
        var i = function (t) {
            "use strict";
            var e = Object.prototype,
                n = e.hasOwnProperty,
                i = "function" == typeof Symbol ? Symbol : {},
                r = i.iterator || "@@iterator",
                s = i.asyncIterator || "@@asyncIterator",
                o = i.toStringTag || "@@toStringTag";

            function a(t, e, n) {
                return Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                a({}, "")
            } catch (t) {
                a = function (t, e, n) {
                    return t[e] = n
                }
            }

            function c(t, e, n, i) {
                var r = e && e.prototype instanceof u ? e : u,
                    s = Object.create(r.prototype),
                    o = new w(i || []);
                return s._invoke = function (t, e, n) {
                    var i = "suspendedStart";
                    return function (r, s) {
                        if ("executing" === i) throw new Error("Generator is already running");
                        if ("completed" === i) {
                            if ("throw" === r) throw s;
                            return T()
                        }
                        for (n.method = r, n.arg = s;;) {
                            var o = n.delegate;
                            if (o) {
                                var a = x(o, n);
                                if (a) {
                                    if (a === h) continue;
                                    return a
                                }
                            }
                            if ("next" === n.method) n.sent = n._sent = n.arg;
                            else if ("throw" === n.method) {
                                if ("suspendedStart" === i) throw i = "completed", n.arg;
                                n.dispatchException(n.arg)
                            } else "return" === n.method && n.abrupt("return", n.arg);
                            i = "executing";
                            var c = l(t, e, n);
                            if ("normal" === c.type) {
                                if (i = n.done ? "completed" : "suspendedYield", c.arg === h) continue;
                                return {
                                    value: c.arg,
                                    done: n.done
                                }
                            }
                            "throw" === c.type && (i = "completed", n.method = "throw", n.arg = c.arg)
                        }
                    }
                }(t, n, o), s
            }

            function l(t, e, n) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, n)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            t.wrap = c;
            var h = {};

            function u() {}

            function p() {}

            function d() {}
            var f = {};
            f[r] = function () {
                return this
            };
            var m = Object.getPrototypeOf,
                g = m && m(m(S([])));
            g && g !== e && n.call(g, r) && (f = g);
            var v = d.prototype = u.prototype = Object.create(f);

            function y(t) {
                ["next", "throw", "return"].forEach((function (e) {
                    a(t, e, (function (t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function _(t, e) {
                var i;
                this._invoke = function (r, s) {
                    function o() {
                        return new e((function (i, o) {
                            ! function i(r, s, o, a) {
                                var c = l(t[r], t, s);
                                if ("throw" !== c.type) {
                                    var h = c.arg,
                                        u = h.value;
                                    return u && "object" == typeof u && n.call(u, "__await") ? e.resolve(u.__await).then((function (t) {
                                        i("next", t, o, a)
                                    }), (function (t) {
                                        i("throw", t, o, a)
                                    })) : e.resolve(u).then((function (t) {
                                        h.value = t, o(h)
                                    }), (function (t) {
                                        return i("throw", t, o, a)
                                    }))
                                }
                                a(c.arg)
                            }(r, s, i, o)
                        }))
                    }
                    return i = i ? i.then(o, o) : o()
                }
            }

            function x(t, e) {
                var n = t.iterator[e.method];
                if (void 0 === n) {
                    if (e.delegate = null, "throw" === e.method) {
                        if (t.iterator.return && (e.method = "return", e.arg = void 0, x(t, e), "throw" === e.method)) return h;
                        e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return h
                }
                var i = l(n, t.iterator, e.arg);
                if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, h;
                var r = i.arg;
                return r ? r.done ? (e[t.resultName] = r.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = void 0), e.delegate = null, h) : r : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, h)
            }

            function b(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function M(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function w(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(b, this), this.reset(!0)
            }

            function S(t) {
                if (t) {
                    var e = t[r];
                    if (e) return e.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var i = -1,
                            s = function e() {
                                for (; ++i < t.length;)
                                    if (n.call(t, i)) return e.value = t[i], e.done = !1, e;
                                return e.value = void 0, e.done = !0, e
                            };
                        return s.next = s
                    }
                }
                return {
                    next: T
                }
            }

            function T() {
                return {
                    value: void 0,
                    done: !0
                }
            }
            return p.prototype = v.constructor = d, d.constructor = p, p.displayName = a(d, o, "GeneratorFunction"), t.isGeneratorFunction = function (t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === p || "GeneratorFunction" === (e.displayName || e.name))
            }, t.mark = function (t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, d) : (t.__proto__ = d, a(t, o, "GeneratorFunction")), t.prototype = Object.create(v), t
            }, t.awrap = function (t) {
                return {
                    __await: t
                }
            }, y(_.prototype), _.prototype[s] = function () {
                return this
            }, t.AsyncIterator = _, t.async = function (e, n, i, r, s) {
                void 0 === s && (s = Promise);
                var o = new _(c(e, n, i, r), s);
                return t.isGeneratorFunction(n) ? o : o.next().then((function (t) {
                    return t.done ? t.value : o.next()
                }))
            }, y(v), a(v, o, "Generator"), v[r] = function () {
                return this
            }, v.toString = function () {
                return "[object Generator]"
            }, t.keys = function (t) {
                var e = [];
                for (var n in t) e.push(n);
                return e.reverse(),
                    function n() {
                        for (; e.length;) {
                            var i = e.pop();
                            if (i in t) return n.value = i, n.done = !1, n
                        }
                        return n.done = !0, n
                    }
            }, t.values = S, w.prototype = {
                constructor: w,
                reset: function (t) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(M), !t)
                        for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0)
                },
                stop: function () {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function (t) {
                    if (this.done) throw t;
                    var e = this;

                    function i(n, i) {
                        return o.type = "throw", o.arg = t, e.next = n, i && (e.method = "next", e.arg = void 0), !!i
                    }
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var s = this.tryEntries[r],
                            o = s.completion;
                        if ("root" === s.tryLoc) return i("end");
                        if (s.tryLoc <= this.prev) {
                            var a = n.call(s, "catchLoc"),
                                c = n.call(s, "finallyLoc");
                            if (a && c) {
                                if (this.prev < s.catchLoc) return i(s.catchLoc, !0);
                                if (this.prev < s.finallyLoc) return i(s.finallyLoc)
                            } else if (a) {
                                if (this.prev < s.catchLoc) return i(s.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < s.finallyLoc) return i(s.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (t, e) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var r = this.tryEntries[i];
                        if (r.tryLoc <= this.prev && n.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                            var s = r;
                            break
                        }
                    }
                    s && ("break" === t || "continue" === t) && s.tryLoc <= e && e <= s.finallyLoc && (s = null);
                    var o = s ? s.completion : {};
                    return o.type = t, o.arg = e, s ? (this.method = "next", this.next = s.finallyLoc, h) : this.complete(o)
                },
                complete: function (t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), h
                },
                finish: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), M(n), h
                    }
                },
                catch: function (t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var i = n.completion;
                            if ("throw" === i.type) {
                                var r = i.arg;
                                M(n)
                            }
                            return r
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (t, e, n) {
                    return this.delegate = {
                        iterator: S(t),
                        resultName: e,
                        nextLoc: n
                    }, "next" === this.method && (this.arg = void 0), h
                }
            }, t
        }(t.exports);
        try {
            regeneratorRuntime = i
        } catch (t) {
            Function("r", "regeneratorRuntime = r")(i)
        }
    },
    o0o1: function (t, e, n) {
        t.exports = n("ls82")
    },
    "s+lh": function (t, e, n) {
        ! function (e, n) {
            var i = function (t, e, n) {
                "use strict";
                var i, r;
                if (function () {
                        var e, n = {
                            lazyClass: "lazyload",
                            loadedClass: "lazyloaded",
                            loadingClass: "lazyloading",
                            preloadClass: "lazypreload",
                            errorClass: "lazyerror",
                            autosizesClass: "lazyautosizes",
                            srcAttr: "data-src",
                            srcsetAttr: "data-srcset",
                            sizesAttr: "data-sizes",
                            minSize: 40,
                            customMedia: {},
                            init: !0,
                            expFactor: 1.5,
                            hFac: .8,
                            loadMode: 2,
                            loadHidden: !0,
                            ricTimeout: 0,
                            throttleDelay: 125
                        };
                        for (e in r = t.lazySizesConfig || t.lazysizesConfig || {}, n) e in r || (r[e] = n[e])
                    }(), !e || !e.getElementsByClassName) return {
                    init: function () {},
                    cfg: r,
                    noSupport: !0
                };
                var s = e.documentElement,
                    o = t.HTMLPictureElement,
                    a = t.addEventListener.bind(t),
                    c = t.setTimeout,
                    l = t.requestAnimationFrame || c,
                    h = t.requestIdleCallback,
                    u = /^picture$/i,
                    p = ["load", "error", "lazyincluded", "_lazyloaded"],
                    d = {},
                    f = Array.prototype.forEach,
                    m = function (t, e) {
                        return d[e] || (d[e] = new RegExp("(\\s|^)" + e + "(\\s|$)")), d[e].test(t.getAttribute("class") || "") && d[e]
                    },
                    g = function (t, e) {
                        m(t, e) || t.setAttribute("class", (t.getAttribute("class") || "").trim() + " " + e)
                    },
                    v = function (t, e) {
                        var n;
                        (n = m(t, e)) && t.setAttribute("class", (t.getAttribute("class") || "").replace(n, " "))
                    },
                    y = function (t, e, n) {
                        var i = n ? "addEventListener" : "removeEventListener";
                        n && y(t, e), p.forEach((function (n) {
                            t[i](n, e)
                        }))
                    },
                    _ = function (t, n, r, s, o) {
                        var a = e.createEvent("Event");
                        return r || (r = {}), r.instance = i, a.initEvent(n, !s, !o), a.detail = r, t.dispatchEvent(a), a
                    },
                    x = function (e, n) {
                        var i;
                        !o && (i = t.picturefill || r.pf) ? (n && n.src && !e.getAttribute("srcset") && e.setAttribute("srcset", n.src), i({
                            reevaluate: !0,
                            elements: [e]
                        })) : n && n.src && (e.src = n.src)
                    },
                    b = function (t, e) {
                        return (getComputedStyle(t, null) || {})[e]
                    },
                    M = function (t, e, n) {
                        for (n = n || t.offsetWidth; n < r.minSize && e && !t._lazysizesWidth;) n = e.offsetWidth, e = e.parentNode;
                        return n
                    },
                    w = (dt = [], ft = [], mt = dt, gt = function () {
                        var t = mt;
                        for (mt = dt.length ? ft : dt, ut = !0, pt = !1; t.length;) t.shift()();
                        ut = !1
                    }, vt = function (t, n) {
                        ut && !n ? t.apply(this, arguments) : (mt.push(t), pt || (pt = !0, (e.hidden ? c : l)(gt)))
                    }, vt._lsFlush = gt, vt),
                    S = function (t, e) {
                        return e ? function () {
                            w(t)
                        } : function () {
                            var e = this,
                                n = arguments;
                            w((function () {
                                t.apply(e, n)
                            }))
                        }
                    },
                    T = function (t) {
                        var e, i, r = function () {
                                e = null, t()
                            },
                            s = function () {
                                var t = n.now() - i;
                                t < 99 ? c(s, 99 - t) : (h || r)(r)
                            };
                        return function () {
                            i = n.now(), e || (e = c(s, 99))
                        }
                    },
                    A = (H = /^img$/i, q = /^iframe$/i, X = "onscroll" in t && !/(gle|ing)bot/.test(navigator.userAgent), Y = 0, Z = 0, J = -1, Q = function (t) {
                        Z--, (!t || Z < 0 || !t.target) && (Z = 0)
                    }, K = function (t) {
                        return null == W && (W = "hidden" == b(e.body, "visibility")), W || !("hidden" == b(t.parentNode, "visibility") && "hidden" == b(t, "visibility"))
                    }, $ = function (t, n) {
                        var i, r = t,
                            o = K(t);
                        for (k -= n, G += n, V -= n, j += n; o && (r = r.offsetParent) && r != e.body && r != s;)(o = (b(r, "opacity") || 1) > 0) && "visible" != b(r, "overflow") && (i = r.getBoundingClientRect(), o = j > i.left && V < i.right && G > i.top - 1 && k < i.bottom + 1);
                        return o
                    }, tt = function () {
                        var t, n, o, a, c, l, h, u, p, d, f, m, g = i.elements;
                        if ((R = r.loadMode) && Z < 8 && (t = g.length)) {
                            for (n = 0, J++; n < t; n++)
                                if (g[n] && !g[n]._lazyRace)
                                    if (!X || i.prematureUnveil && i.prematureUnveil(g[n])) at(g[n]);
                                    else if ((u = g[n].getAttribute("data-expand")) && (l = 1 * u) || (l = Y), d || (d = !r.expand || r.expand < 1 ? s.clientHeight > 500 && s.clientWidth > 500 ? 500 : 370 : r.expand, i._defEx = d, f = d * r.expFactor, m = r.hFac, W = null, Y < f && Z < 1 && J > 2 && R > 2 && !e.hidden ? (Y = f, J = 0) : Y = R > 1 && J > 1 && Z < 6 ? d : 0), p !== l && (U = innerWidth + l * m, B = innerHeight + l, h = -1 * l, p = l), o = g[n].getBoundingClientRect(), (G = o.bottom) >= h && (k = o.top) <= B && (j = o.right) >= h * m && (V = o.left) <= U && (G || j || V || k) && (r.loadHidden || K(g[n])) && (I && Z < 3 && !u && (R < 3 || J < 4) || $(g[n], l))) {
                                if (at(g[n]), c = !0, Z > 9) break
                            } else !c && I && !a && Z < 4 && J < 4 && R > 2 && (D[0] || r.preloadAfterLoad) && (D[0] || !u && (G || j || V || k || "auto" != g[n].getAttribute(r.sizesAttr))) && (a = D[0] || g[n]);
                            a && !c && at(a)
                        }
                    }, et = function (t) {
                        var e, i = 0,
                            s = r.throttleDelay,
                            o = r.ricTimeout,
                            a = function () {
                                e = !1, i = n.now(), t()
                            },
                            l = h && o > 49 ? function () {
                                h(a, {
                                    timeout: o
                                }), o !== r.ricTimeout && (o = r.ricTimeout)
                            } : S((function () {
                                c(a)
                            }), !0);
                        return function (t) {
                            var r;
                            (t = !0 === t) && (o = 33), e || (e = !0, (r = s - (n.now() - i)) < 0 && (r = 0), t || r < 9 ? l() : c(l, r))
                        }
                    }(tt), nt = function (t) {
                        var e = t.target;
                        e._lazyCache ? delete e._lazyCache : (Q(t), g(e, r.loadedClass), v(e, r.loadingClass), y(e, rt), _(e, "lazyloaded"))
                    }, it = S(nt), rt = function (t) {
                        it({
                            target: t.target
                        })
                    }, st = function (t) {
                        var e, n = t.getAttribute(r.srcsetAttr);
                        (e = r.customMedia[t.getAttribute("data-media") || t.getAttribute("media")]) && t.setAttribute("media", e), n && t.setAttribute("srcset", n)
                    }, ot = S((function (t, e, n, i, s) {
                        var o, a, l, h, p, d;
                        (p = _(t, "lazybeforeunveil", e)).defaultPrevented || (i && (n ? g(t, r.autosizesClass) : t.setAttribute("sizes", i)), a = t.getAttribute(r.srcsetAttr), o = t.getAttribute(r.srcAttr), s && (h = (l = t.parentNode) && u.test(l.nodeName || "")), d = e.firesLoad || "src" in t && (a || o || h), p = {
                            target: t
                        }, g(t, r.loadingClass), d && (clearTimeout(z), z = c(Q, 2500), y(t, rt, !0)), h && f.call(l.getElementsByTagName("source"), st), a ? t.setAttribute("srcset", a) : o && !h && (q.test(t.nodeName) ? function (t, e) {
                            try {
                                t.contentWindow.location.replace(e)
                            } catch (n) {
                                t.src = e
                            }
                        }(t, o) : t.src = o), s && (a || h) && x(t, {
                            src: o
                        })), t._lazyRace && delete t._lazyRace, v(t, r.lazyClass), w((function () {
                            var e = t.complete && t.naturalWidth > 1;
                            d && !e || (e && g(t, "ls-is-cached"), nt(p), t._lazyCache = !0, c((function () {
                                "_lazyCache" in t && delete t._lazyCache
                            }), 9)), "lazy" == t.loading && Z--
                        }), !0)
                    })), at = function (t) {
                        if (!t._lazyRace) {
                            var e, n = H.test(t.nodeName),
                                i = n && (t.getAttribute(r.sizesAttr) || t.getAttribute("sizes")),
                                s = "auto" == i;
                            (!s && I || !n || !t.getAttribute("src") && !t.srcset || t.complete || m(t, r.errorClass) || !m(t, r.lazyClass)) && (e = _(t, "lazyunveilread").detail, s && L.updateElem(t, !0, t.offsetWidth), t._lazyRace = !0, Z++, ot(t, e, s, i, n))
                        }
                    }, ct = T((function () {
                        r.loadMode = 3, et()
                    })), lt = function () {
                        3 == r.loadMode && (r.loadMode = 2), ct()
                    }, ht = function () {
                        I || (n.now() - F < 999 ? c(ht, 999) : (I = !0, r.loadMode = 3, et(), a("scroll", lt, !0)))
                    }, {
                        _: function () {
                            F = n.now(), i.elements = e.getElementsByClassName(r.lazyClass), D = e.getElementsByClassName(r.lazyClass + " " + r.preloadClass), a("scroll", et, !0), a("resize", et, !0), a("pageshow", (function (t) {
                                if (t.persisted) {
                                    var n = e.querySelectorAll("." + r.loadingClass);
                                    n.length && n.forEach && l((function () {
                                        n.forEach((function (t) {
                                            t.complete && at(t)
                                        }))
                                    }))
                                }
                            })), t.MutationObserver ? new MutationObserver(et).observe(s, {
                                childList: !0,
                                subtree: !0,
                                attributes: !0
                            }) : (s.addEventListener("DOMNodeInserted", et, !0), s.addEventListener("DOMAttrModified", et, !0), setInterval(et, 999)), a("hashchange", et, !0), ["focus", "mouseover", "click", "load", "transitionend", "animationend"].forEach((function (t) {
                                e.addEventListener(t, et, !0)
                            })), /d$|^c/.test(e.readyState) ? ht() : (a("load", ht), e.addEventListener("DOMContentLoaded", et), c(ht, 2e4)), i.elements.length ? (tt(), w._lsFlush()) : et()
                        },
                        checkElems: et,
                        unveil: at,
                        _aLSL: lt
                    }),
                    L = (E = S((function (t, e, n, i) {
                        var r, s, o;
                        if (t._lazysizesWidth = i, i += "px", t.setAttribute("sizes", i), u.test(e.nodeName || ""))
                            for (s = 0, o = (r = e.getElementsByTagName("source")).length; s < o; s++) r[s].setAttribute("sizes", i);
                        n.detail.dataAttr || x(t, n.detail)
                    })), N = function (t, e, n) {
                        var i, r = t.parentNode;
                        r && (n = M(t, r, n), (i = _(t, "lazybeforesizes", {
                            width: n,
                            dataAttr: !!e
                        })).defaultPrevented || (n = i.detail.width) && n !== t._lazysizesWidth && E(t, r, i, n))
                    }, O = T((function () {
                        var t, e = P.length;
                        if (e)
                            for (t = 0; t < e; t++) N(P[t])
                    })), {
                        _: function () {
                            P = e.getElementsByClassName(r.autosizesClass), a("resize", O)
                        },
                        checkElems: O,
                        updateElem: N
                    }),
                    C = function () {
                        !C.i && e.getElementsByClassName && (C.i = !0, L._(), A._())
                    };
                var P, E, N, O;
                var D, I, z, R, F, U, B, k, V, j, G, W, H, q, X, Y, Z, J, Q, K, $, tt, et, nt, it, rt, st, ot, at, ct, lt, ht;
                var ut, pt, dt, ft, mt, gt, vt;
                return c((function () {
                    r.init && C()
                })), i = {
                    cfg: r,
                    autoSizer: L,
                    loader: A,
                    init: C,
                    uP: x,
                    aC: g,
                    rC: v,
                    hC: m,
                    fire: _,
                    gW: M,
                    rAF: w
                }
            }(e, e.document, Date);
            e.lazySizes = i, t.exports && (t.exports = i)
        }("undefined" != typeof window ? window : {})
    },
    skH9: function (t, e, n) {
        "use strict";

        function i(t) {
            return new Promise((function (e, n, i) {
                (i = new XMLHttpRequest).open("GET", t, i.withCredentials = !0), i.onload = function () {
                    200 === i.status ? e() : n()
                }, i.send()
            }))
        }
        n.d(e, "a", (function () {
            return a
        }));
        var r, s = (r = document.createElement("link")).relList && r.relList.supports && r.relList.supports("prefetch") ? function (t) {
                return new Promise((function (e, n, i) {
                    (i = document.createElement("link")).rel = "prefetch", i.href = t, i.onload = e, i.onerror = n, document.head.appendChild(i)
                }))
            } : i,
            o = (window.requestIdleCallback, new Set);

        function a(t, e, n) {
            if (!(n = navigator.connection) || !n.saveData && !/2g/.test(n.effectiveType)) return Promise.all([].concat(t).map((function (t) {
                if (!o.has(t)) return o.add(t), (e ? function (t) {
                    return window.fetch ? fetch(t, {
                        credentials: "include"
                    }) : i(t)
                } : s)(new URL(t, location.href).toString())
            })))
        }
    },
    wOJ8: function (t, e) {
        function n() {}
        n.prototype = {
            on: function (t, e, n) {
                var i = this.e || (this.e = {});
                return (i[t] || (i[t] = [])).push({
                    fn: e,
                    ctx: n
                }), this
            },
            once: function (t, e, n) {
                var i = this;

                function r() {
                    i.off(t, r), e.apply(n, arguments)
                }
                return r._ = e, this.on(t, r, n)
            },
            emit: function (t) {
                for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
                return this
            },
            off: function (t, e) {
                var n = this.e || (this.e = {}),
                    i = n[t],
                    r = [];
                if (i && e)
                    for (var s = 0, o = i.length; s < o; s++) i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]);
                return r.length ? n[t] = r : delete n[t], this
            }
        }, t.exports = n, t.exports.TinyEmitter = n
    },
    "z/o8": function (t, e, n) {
        "use strict";

        function i(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function r(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        n.d(e, "a", (function () {
            return Ti
        }));
        var s, o, a, c, l, h, u, p, d, f, m, g, v, y, _, x, b, M, w, S, T, A, L, C, P, E, N, O = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            D = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            I = 1e8,
            z = 2 * Math.PI,
            R = z / 4,
            F = 0,
            U = Math.sqrt,
            B = Math.cos,
            k = Math.sin,
            V = function (t) {
                return "string" == typeof t
            },
            j = function (t) {
                return "function" == typeof t
            },
            G = function (t) {
                return "number" == typeof t
            },
            W = function (t) {
                return void 0 === t
            },
            H = function (t) {
                return "object" == typeof t
            },
            q = function (t) {
                return !1 !== t
            },
            X = function () {
                return "undefined" != typeof window
            },
            Y = function (t) {
                return j(t) || V(t)
            },
            Z = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {},
            J = Array.isArray,
            Q = /(?:-?\.?\d|\.)+/gi,
            K = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
            $ = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            tt = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
            et = /[+-]=-?[\.\d]+/,
            nt = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
            it = {},
            rt = {},
            st = function (t) {
                return (rt = Et(t, it)) && dn
            },
            ot = function (t, e) {
                return !e && void 0
            },
            at = function (t, e) {
                return t && (it[t] = e) && rt && (rt[t] = e) || it
            },
            ct = function () {
                return 0
            },
            lt = {},
            ht = [],
            ut = {},
            pt = {},
            dt = {},
            ft = 30,
            mt = [],
            gt = "",
            vt = function (t) {
                var e, n, i = t[0];
                if (H(i) || j(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                    for (n = mt.length; n-- && !mt[n].targetTest(i););
                    e = mt[n]
                }
                for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Fe(t[n], e))) || t.splice(n, 1);
                return t
            },
            yt = function (t) {
                return t._gsap || vt(ie(t))[0]._gsap
            },
            _t = function (t, e, n) {
                return (n = t[e]) && j(n) ? t[e]() : W(n) && t.getAttribute && t.getAttribute(e) || n
            },
            xt = function (t, e) {
                return (t = t.split(",")).forEach(e) || t
            },
            bt = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            Mt = function (t, e) {
                for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                return i < n
            },
            wt = function (t, e, n) {
                var i, r = G(t[1]),
                    s = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                    o = t[s];
                if (r && (o.duration = t[1]), o.parent = n, e) {
                    for (i = o; n && !("immediateRender" in i);) i = n.vars.defaults || {}, n = q(n.vars.inherit) && n.parent;
                    o.immediateRender = q(i.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
                }
                return o
            },
            St = function () {
                var t, e, n = ht.length,
                    i = ht.slice(0);
                for (ut = {}, ht.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            },
            Tt = function (t, e, n, i) {
                ht.length && St(), t.render(e, n, i), ht.length && St()
            },
            At = function (t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(nt).length < 2 ? e : V(t) ? t.trim() : t
            },
            Lt = function (t) {
                return t
            },
            Ct = function (t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            Pt = function (t, e) {
                for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
            },
            Et = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            Nt = function t(e, n) {
                for (var i in n) e[i] = H(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
                return e
            },
            Ot = function (t, e) {
                var n, i = {};
                for (n in t) n in e || (i[n] = t[n]);
                return i
            },
            Dt = function (t) {
                var e = t.parent || s,
                    n = t.keyframes ? Pt : Ct;
                if (q(t.inherit))
                    for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
                return t
            },
            It = function (t, e, n, i) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var r = e._prev,
                    s = e._next;
                r ? r._next = s : t[n] === e && (t[n] = s), s ? s._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
            },
            zt = function (t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
            },
            Rt = function (t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var n = t; n;) n._dirty = 1, n = n.parent;
                return t
            },
            Ft = function (t) {
                for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                return t
            },
            Ut = function (t) {
                return t._repeat ? Bt(t._tTime, t = t.duration() + t._rDelay) * t : 0
            },
            Bt = function (t, e) {
                return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
            },
            kt = function (t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            },
            Vt = function (t) {
                return t._end = bt(t._start + (t._tDur / Math.abs(t._ts || t._rts || 1e-8) || 0))
            },
            jt = function (t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = bt(t._dp._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Vt(t), n._dirty || Rt(n, t)), t
            },
            Gt = function (t, e) {
                var n;
                if ((e._time || e._initted && !e._dur) && (n = kt(t.rawTime(), e), (!e._dur || Kt(0, e.totalDuration(), n) - e._tTime > 1e-8) && e.render(n, !0)), Rt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            },
            Wt = function (t, e, n, i) {
                return e.parent && zt(e), e._start = bt(n + e._delay), e._end = bt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                    function (t, e, n, i, r) {
                        void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                        var s, o = t[i];
                        if (r)
                            for (s = e[r]; o && o[r] > s;) o = o._prev;
                        o ? (e._next = o._next, o._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = o, e.parent = e._dp = t
                    }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, i || Gt(t, e), t
            },
            Ht = function (t, e) {
                return it.ScrollTrigger ? it.ScrollTrigger.create(e, t) : void 0
            },
            qt = function (t, e, n, i) {
                return We(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && h !== Se.frame ? (ht.push(t), t._lazy = [e, i], 1) : void 0 : 1
            },
            Xt = function (t, e, n, i) {
                var r = t._repeat,
                    s = bt(e) || 0,
                    o = t._tTime / t._tDur;
                return o && !i && (t._time *= s / t._dur), t._dur = s, t._tDur = r ? r < 0 ? 1e10 : bt(s * (r + 1) + t._rDelay * r) : s, o && !i ? jt(t, t._tTime = t._tDur * o) : t.parent && Vt(t), n || Rt(t.parent, t), t
            },
            Yt = function (t) {
                return t instanceof Be ? Rt(t) : Xt(t, t._dur)
            },
            Zt = {
                _start: 0,
                endTime: ct
            },
            Jt = function t(e, n) {
                var i, r, s = e.labels,
                    o = e._recent || Zt,
                    a = e.duration() >= I ? o.endTime(!1) : e._dur;
                return V(n) && (isNaN(n) || n in s) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? o._start : o.endTime(o._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in s || (s[n] = a), s[n]) : (r = +(n.charAt(i - 1) + n.substr(i + 1)), i > 1 ? t(e, n.substr(0, i - 1)) + r : a + r) : null == n ? a : +n
            },
            Qt = function (t, e) {
                return t || 0 === t ? e(t) : e
            },
            Kt = function (t, e, n) {
                return n < t ? t : n > e ? e : n
            },
            $t = function (t) {
                return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : ""
            },
            te = [].slice,
            ee = function (t, e) {
                return t && H(t) && "length" in t && (!e && !t.length || t.length - 1 in t && H(t[0])) && !t.nodeType && t !== o
            },
            ne = function (t, e, n) {
                return void 0 === n && (n = []), t.forEach((function (t) {
                    var i;
                    return V(t) && !e || ee(t, 1) ? (i = n).push.apply(i, ie(t)) : n.push(t)
                })) || n
            },
            ie = function (t, e) {
                return !V(t) || e || !a && Te() ? J(t) ? ne(t, e) : ee(t) ? te.call(t, 0) : t ? [t] : [] : te.call(c.querySelectorAll(t), 0)
            },
            re = function (t) {
                return t.sort((function () {
                    return .5 - Math.random()
                }))
            },
            se = function (t) {
                if (j(t)) return t;
                var e = H(t) ? t : {
                        each: t
                    },
                    n = Oe(e.ease),
                    i = e.from || 0,
                    r = parseFloat(e.base) || 0,
                    s = {},
                    o = i > 0 && i < 1,
                    a = isNaN(i) || o,
                    c = e.axis,
                    l = i,
                    h = i;
                return V(i) ? l = h = {
                        center: .5,
                        edges: .5,
                        end: 1
                    } [i] || 0 : !o && a && (l = i[0], h = i[1]),
                    function (t, o, u) {
                        var p, d, f, m, g, v, y, _, x, b = (u || e).length,
                            M = s[b];
                        if (!M) {
                            if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, I])[1])) {
                                for (y = -I; y < (y = u[x++].getBoundingClientRect().left) && x < b;);
                                x--
                            }
                            for (M = s[b] = [], p = a ? Math.min(x, b) * l - .5 : i % x, d = a ? b * h / x - .5 : i / x | 0, y = 0, _ = I, v = 0; v < b; v++) f = v % x - p, m = d - (v / x | 0), M[v] = g = c ? Math.abs("y" === c ? m : f) : U(f * f + m * m), g > y && (y = g), g < _ && (_ = g);
                            "random" === i && re(M), M.max = y - _, M.min = _, M.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : c ? "y" === c ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1), M.b = b < 0 ? r - b : r, M.u = $t(e.amount || e.each) || 0, n = n && b < 0 ? Ee(n) : n
                        }
                        return b = (M[t] - M.min) / M.max || 0, bt(M.b + (n ? n(b) : b) * M.v) + M.u
                    }
            },
            oe = function (t) {
                var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                return function (n) {
                    return Math.floor(Math.round(parseFloat(n) / t) * t * e) / e + (G(n) ? 0 : $t(n))
                }
            },
            ae = function (t, e) {
                var n, i, r = J(t);
                return !r && H(t) && (n = r = t.radius || I, t.values ? (t = ie(t.values), (i = !G(t[0])) && (n *= n)) : t = oe(t.increment)), Qt(e, r ? j(t) ? function (e) {
                    return i = t(e), Math.abs(i - e) <= n ? i : e
                } : function (e) {
                    for (var r, s, o = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), c = I, l = 0, h = t.length; h--;)(r = i ? (r = t[h].x - o) * r + (s = t[h].y - a) * s : Math.abs(t[h] - o)) < c && (c = r, l = h);
                    return l = !n || c <= n ? t[l] : e, i || l === e || G(e) ? l : l + $t(e)
                } : oe(t))
            },
            ce = function (t, e, n, i) {
                return Qt(J(t) ? !e : !0 === n ? !!(n = 0) : !i, (function () {
                    return J(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / n) * n * i) / i
                }))
            },
            le = function (t, e, n) {
                return Qt(n, (function (n) {
                    return t[~~e(n)]
                }))
            },
            he = function (t) {
                for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? nt : Q), o += t.substr(s, e - s) + ce(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1;
                return o + t.substr(s, t.length - s)
            },
            ue = function (t, e, n, i, r) {
                var s = e - t,
                    o = i - n;
                return Qt(r, (function (e) {
                    return n + ((e - t) / s * o || 0)
                }))
            },
            pe = function (t, e, n) {
                var i, r, s, o = t.labels,
                    a = I;
                for (i in o)(r = o[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i, a = r);
                return s
            },
            de = function (t, e, n) {
                var i, r, s = t.vars,
                    o = s[e];
                if (o) return i = s[e + "Params"], r = s.callbackScope || t, n && ht.length && St(), i ? o.apply(r, i) : o.call(r)
            },
            fe = function (t) {
                return zt(t), t.progress() < 1 && de(t, "onInterrupt"), t
            },
            me = function (t) {
                var e = (t = !t.name && t.default || t).name,
                    n = j(t),
                    i = e && !n && t.init ? function () {
                        this._props = []
                    } : t,
                    r = {
                        init: ct,
                        render: rn,
                        add: je,
                        kill: on,
                        modifier: sn,
                        rawVars: 0
                    },
                    s = {
                        targetTest: 0,
                        get: 0,
                        getSetter: $e,
                        aliases: {},
                        register: 0
                    };
                if (Te(), t !== i) {
                    if (pt[e]) return;
                    Ct(i, Ct(Ot(t, r), s)), Et(i.prototype, Et(r, Ot(t, s))), pt[i.prop = e] = i, t.targetTest && (mt.push(i), lt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                }
                at(e, i), t.register && t.register(dn, i, ln)
            },
            ge = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            },
            ve = function (t, e, n) {
                return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            },
            ye = function (t, e, n) {
                var i, r, s, o, a, c, l, h, u, p, d = t ? G(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : ge.black;
                if (!d) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), ge[t]) d = ge[t];
                    else if ("#" === t.charAt(0)) 4 === t.length && (i = t.charAt(1), r = t.charAt(2), s = t.charAt(3), t = "#" + i + i + r + r + s + s), d = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                    else if ("hsl" === t.substr(0, 3))
                        if (d = p = t.match(Q), e) {
                            if (~t.indexOf("=")) return d = t.match(K), n && d.length < 4 && (d[3] = 1), d
                        } else o = +d[0] % 360 / 360, a = +d[1] / 100, i = 2 * (c = +d[2] / 100) - (r = c <= .5 ? c * (a + 1) : c + a - c * a), d.length > 3 && (d[3] *= 1), d[0] = ve(o + 1 / 3, i, r), d[1] = ve(o, i, r), d[2] = ve(o - 1 / 3, i, r);
                    else d = t.match(Q) || ge.transparent;
                    d = d.map(Number)
                }
                return e && !p && (i = d[0] / 255, r = d[1] / 255, s = d[2] / 255, c = ((l = Math.max(i, r, s)) + (h = Math.min(i, r, s))) / 2, l === h ? o = a = 0 : (u = l - h, a = c > .5 ? u / (2 - l - h) : u / (l + h), o = l === i ? (r - s) / u + (r < s ? 6 : 0) : l === r ? (s - i) / u + 2 : (i - r) / u + 4, o *= 60), d[0] = ~~(o + .5), d[1] = ~~(100 * a + .5), d[2] = ~~(100 * c + .5)), n && d.length < 4 && (d[3] = 1), d
            },
            _e = function (t) {
                var e = [],
                    n = [],
                    i = -1;
                return t.split(be).forEach((function (t) {
                    var r = t.match($) || [];
                    e.push.apply(e, r), n.push(i += r.length + 1)
                })), e.c = n, e
            },
            xe = function (t, e, n) {
                var i, r, s, o, a = "",
                    c = (t + a).match(be),
                    l = e ? "hsla(" : "rgba(",
                    h = 0;
                if (!c) return t;
                if (c = c.map((function (t) {
                        return (t = ye(t, e, 1)) && l + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                    })), n && (s = _e(t), (i = n.c).join(a) !== s.c.join(a)))
                    for (o = (r = t.replace(be, "1").split($)).length - 1; h < o; h++) a += r[h] + (~i.indexOf(h) ? c.shift() || l + "0,0,0,0)" : (s.length ? s : c.length ? c : n).shift());
                if (!r)
                    for (o = (r = t.split(be)).length - 1; h < o; h++) a += r[h] + c[h];
                return a + r[o]
            },
            be = function () {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                for (t in ge) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(),
            Me = /hsl[a]?\(/,
            we = function (t) {
                var e, n = t.join(" ");
                if (be.lastIndex = 0, be.test(n)) return e = Me.test(n), t[1] = xe(t[1], e), t[0] = xe(t[0], e, _e(t[1])), !0
            },
            Se = (_ = Date.now, x = 500, b = 33, M = _(), w = M, T = S = 1e3 / 240, L = function t(e) {
                var n, i, r, s, o = _() - w,
                    a = !0 === e;
                if (o > x && (M += o - b), ((n = (r = (w += o) - M) - T) > 0 || a) && (s = ++g.frame, v = r - 1e3 * g.time, g.time = r /= 1e3, T += n + (n >= S ? 4 : S - n), i = 1), a || (d = f(t)), i)
                    for (y = 0; y < A.length; y++) A[y](r, v, s, e)
            }, g = {
                time: 0,
                frame: 0,
                tick: function () {
                    L(!0)
                },
                deltaRatio: function (t) {
                    return v / (1e3 / (t || 60))
                },
                wake: function () {
                    l && (!a && X() && (o = a = window, c = o.document || {}, it.gsap = dn, (o.gsapVersions || (o.gsapVersions = [])).push(dn.version), st(rt || o.GreenSockGlobals || !o.gsap && o || {}), m = o.requestAnimationFrame), d && g.sleep(), f = m || function (t) {
                        return setTimeout(t, T - 1e3 * g.time + 1 | 0)
                    }, p = 1, L(2))
                },
                sleep: function () {
                    (m ? o.cancelAnimationFrame : clearTimeout)(d), p = 0, f = ct
                },
                lagSmoothing: function (t, e) {
                    x = t || 1 / 1e-8, b = Math.min(e, x, 0)
                },
                fps: function (t) {
                    S = 1e3 / (t || 240), T = 1e3 * g.time + S
                },
                add: function (t) {
                    A.indexOf(t) < 0 && A.push(t), Te()
                },
                remove: function (t) {
                    var e;
                    ~(e = A.indexOf(t)) && A.splice(e, 1) && y >= e && y--
                },
                _listeners: A = []
            }),
            Te = function () {
                return !p && Se.wake()
            },
            Ae = {},
            Le = /^[\d.\-M][\d.\-,\s]/,
            Ce = /["']/g,
            Pe = function (t) {
                for (var e, n, i, r = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, c = s.length; a < c; a++) n = s[a], e = a !== c - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[o] = isNaN(i) ? i.replace(Ce, "").trim() : +i, o = n.substr(e + 1).trim();
                return r
            },
            Ee = function (t) {
                return function (e) {
                    return 1 - t(1 - e)
                }
            },
            Ne = function t(e, n) {
                for (var i, r = e._first; r;) r instanceof Be ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
            },
            Oe = function (t, e) {
                return t && (j(t) ? t : Ae[t] || function (t) {
                    var e, n, i, r, s = (t + "").split("("),
                        o = Ae[s[0]];
                    return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [Pe(s[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(At)) : Ae._CE && Le.test(t) ? Ae._CE("", t) : o
                }(t)) || e
            },
            De = function (t, e, n, i) {
                void 0 === n && (n = function (t) {
                    return 1 - e(1 - t)
                }), void 0 === i && (i = function (t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, s = {
                    easeIn: e,
                    easeOut: n,
                    easeInOut: i
                };
                return xt(t, (function (t) {
                    for (var e in Ae[t] = it[t] = s, Ae[r = t.toLowerCase()] = n, s) Ae[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Ae[t + "." + e] = s[e]
                })), s
            },
            Ie = function (t) {
                return function (e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            },
            ze = function t(e, n, i) {
                var r = n >= 1 ? n : 1,
                    s = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                    o = s / z * (Math.asin(1 / r) || 0),
                    a = function (t) {
                        return 1 === t ? 1 : r * Math.pow(2, -10 * t) * k((t - o) * s) + 1
                    },
                    c = "out" === e ? a : "in" === e ? function (t) {
                        return 1 - a(1 - t)
                    } : Ie(a);
                return s = z / s, c.config = function (n, i) {
                    return t(e, n, i)
                }, c
            },
            Re = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var i = function (t) {
                        return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                    },
                    r = "out" === e ? i : "in" === e ? function (t) {
                        return 1 - i(1 - t)
                    } : Ie(i);
                return r.config = function (n) {
                    return t(e, n)
                }, r
            };
        xt("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
            var n = e < 5 ? e + 1 : e;
            De(t + ",Power" + (n - 1), e ? function (t) {
                return Math.pow(t, n)
            } : function (t) {
                return t
            }, (function (t) {
                return 1 - Math.pow(1 - t, n)
            }), (function (t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }))
        })), Ae.Linear.easeNone = Ae.none = Ae.Linear.easeIn, De("Elastic", ze("in"), ze("out"), ze()), C = 7.5625, E = 1 / (P = 2.75), De("Bounce", (function (t) {
            return 1 - N(1 - t)
        }), N = function (t) {
            return t < E ? C * t * t : t < .7272727272727273 ? C * Math.pow(t - 1.5 / P, 2) + .75 : t < .9090909090909092 ? C * (t -= 2.25 / P) * t + .9375 : C * Math.pow(t - 2.625 / P, 2) + .984375
        }), De("Expo", (function (t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        })), De("Circ", (function (t) {
            return -(U(1 - t * t) - 1)
        })), De("Sine", (function (t) {
            return 1 === t ? 1 : 1 - B(t * R)
        })), De("Back", Re("in"), Re("out"), Re()), Ae.SteppedEase = Ae.steps = it.SteppedEase = {
            config: function (t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t,
                    i = t + (e ? 0 : 1),
                    r = e ? 1 : 0;
                return function (t) {
                    return ((i * Kt(0, 1 - 1e-8, t) | 0) + r) * n
                }
            }
        }, D.ease = Ae["quad.out"], xt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
            return gt += t + "," + t + "Params,"
        }));
        var Fe = function (t, e) {
                this.id = F++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : _t, this.set = e ? e.getSetter : $e
            },
            Ue = function () {
                function t(t, e) {
                    var n = t.parent || s;
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Xt(this, +t.duration, 1, 1), this.data = t.data, p || Se.wake(), n && Wt(n, this, e || 0 === e ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
                }
                var e = t.prototype;
                return e.delay = function (t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, e.duration = function (t) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, e.totalDuration = function (t) {
                    return arguments.length ? (this._dirty = 0, Xt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function (t, e) {
                    if (Te(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (jt(this, t); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Wt(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && 1e-8 === Math.abs(this._zTime) || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), Tt(this, t, e)), this
                }, e.time = function (t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Ut(this)) % this._dur || (t ? this._dur : 0), e) : this._time
                }, e.totalProgress = function (t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                }, e.progress = function (t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Ut(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                }, e.iteration = function (t, e) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Bt(this._tTime, n) + 1 : 1
                }, e.timeScale = function (t) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var e = this.parent && this._ts ? kt(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Ft(this.totalTime(Kt(-this._delay, this._tDur, e), !0))
                }, e.paused = function (t) {
                    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Te(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= 1e-8) && 1e-8 !== Math.abs(this._zTime)))), this) : this._ps
                }, e.startTime = function (t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return e && (e._sort || !this.parent) && Wt(e, this, t - this._delay), this
                    }
                    return this._start
                }, e.endTime = function (t) {
                    return this._start + (q(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                }, e.rawTime = function (t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? kt(e.rawTime(t), this) : this._tTime : this._tTime
                }, e.globalTime = function (t) {
                    for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
                    return n
                }, e.repeat = function (t) {
                    return arguments.length ? (this._repeat = t, Yt(this)) : this._repeat
                }, e.repeatDelay = function (t) {
                    return arguments.length ? (this._rDelay = t, Yt(this)) : this._rDelay
                }, e.yoyo = function (t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, e.seek = function (t, e) {
                    return this.totalTime(Jt(this, t), q(e))
                }, e.restart = function (t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, q(e))
                }, e.play = function (t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, e.reverse = function (t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, e.pause = function (t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, e.resume = function () {
                    return this.paused(!1)
                }, e.reversed = function (t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                }, e.invalidate = function () {
                    return this._initted = 0, this._zTime = -1e-8, this
                }, e.isActive = function () {
                    var t, e = this.parent || this._dp,
                        n = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - 1e-8))
                }, e.eventCallback = function (t, e, n) {
                    var i = this.vars;
                    return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
                }, e.then = function (t) {
                    var e = this;
                    return new Promise((function (n) {
                        var i = j(t) ? t : Lt,
                            r = function () {
                                var t = e.then;
                                e.then = null, j(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                            };
                        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                    }))
                }, e.kill = function () {
                    fe(this)
                }, t
            }();
        Ct(Ue.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Be = function (t) {
            function e(e, n) {
                var r;
                return void 0 === e && (e = {}), (r = t.call(this, e, n) || this).labels = {}, r.smoothChildTiming = !!e.smoothChildTiming, r.autoRemoveChildren = !!e.autoRemoveChildren, r._sort = q(e.sortChildren), r.parent && Gt(r.parent, i(r)), e.scrollTrigger && Ht(i(r), e.scrollTrigger), r
            }
            r(e, t);
            var n = e.prototype;
            return n.to = function (t, e, n) {
                return new Ye(t, wt(arguments, 0, this), Jt(this, G(e) ? arguments[3] : n)), this
            }, n.from = function (t, e, n) {
                return new Ye(t, wt(arguments, 1, this), Jt(this, G(e) ? arguments[3] : n)), this
            }, n.fromTo = function (t, e, n, i) {
                return new Ye(t, wt(arguments, 2, this), Jt(this, G(e) ? arguments[4] : i)), this
            }, n.set = function (t, e, n) {
                return e.duration = 0, e.parent = this, Dt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Ye(t, e, Jt(this, n), 1), this
            }, n.call = function (t, e, n) {
                return Wt(this, Ye.delayedCall(0, t, e), Jt(this, n))
            }, n.staggerTo = function (t, e, n, i, r, s, o) {
                return n.duration = e, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = o, n.parent = this, new Ye(t, n, Jt(this, r)), this
            }, n.staggerFrom = function (t, e, n, i, r, s, o) {
                return n.runBackwards = 1, Dt(n).immediateRender = q(n.immediateRender), this.staggerTo(t, e, n, i, r, s, o)
            }, n.staggerFromTo = function (t, e, n, i, r, s, o, a) {
                return i.startAt = n, Dt(i).immediateRender = q(i.immediateRender), this.staggerTo(t, e, i, r, s, o, a)
            }, n.render = function (t, e, n) {
                var i, r, o, a, c, l, h, u, p, d, f, m, g = this._time,
                    v = this._dirty ? this.totalDuration() : this._tDur,
                    y = this._dur,
                    _ = this !== s && t > v - 1e-8 && t >= 0 ? v : t < 1e-8 ? 0 : t,
                    x = this._zTime < 0 != t < 0 && (this._initted || !y);
                if (_ !== this._tTime || n || x) {
                    if (g !== this._time && y && (_ += this._time - g, t += this._time - g), i = _, p = this._start, l = !(u = this._ts), x && (y || (g = this._zTime), (t || !e) && (this._zTime = t)), this._repeat && (f = this._yoyo, c = y + this._rDelay, i = bt(_ % c), _ === v ? (a = this._repeat, i = y) : ((a = ~~(_ / c)) && a === _ / c && (i = y, a--), i > y && (i = y)), d = Bt(this._tTime, c), !g && this._tTime && d !== a && (d = a), f && 1 & a && (i = y - i, m = 1), a !== d && !this._lock)) {
                        var b = f && 1 & d,
                            M = b === (f && 1 & a);
                        if (a < d && (b = !b), g = b ? 0 : y, this._lock = 1, this.render(g || (m ? 0 : bt(a * c)), e, !y)._lock = 0, !e && this.parent && de(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), g !== this._time || l !== !this._ts) return this;
                        if (y = this._dur, v = this._tDur, M && (this._lock = 2, g = b ? y : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                        Ne(this, m)
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (t, e, n) {
                            var i;
                            if (n > e)
                                for (i = t._first; i && i._start <= n;) {
                                    if (!i._dur && "isPause" === i.data && i._start > e) return i;
                                    i = i._next
                                } else
                                    for (i = t._last; i && i._start >= n;) {
                                        if (!i._dur && "isPause" === i.data && i._start < e) return i;
                                        i = i._prev
                                    }
                        }(this, bt(g), bt(i))) && (_ -= i - (i = h._start)), this._tTime = _, this._time = i, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), !g && i && !e && de(this, "onStart"), i >= g && t >= 0)
                        for (r = this._first; r;) {
                            if (o = r._next, (r._act || i >= r._start) && r._ts && h !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                    h = 0, o && (_ += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = o
                        } else {
                            r = this._last;
                            for (var w = t < 0 ? t : i; r;) {
                                if (o = r._prev, (r._act || w <= r._end) && r._ts && h !== r) {
                                    if (r.parent !== this) return this.render(t, e, n);
                                    if (r.render(r._ts > 0 ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                        h = 0, o && (_ += this._zTime = w ? -1e-8 : 1e-8);
                                        break
                                    }
                                }
                                r = o
                            }
                        }
                    if (h && !e && (this.pause(), h.render(i >= g ? 0 : -1e-8)._zTime = i >= g ? 1 : -1, this._ts)) return this._start = p, Vt(this), this.render(t, e, n);
                    this._onUpdate && !e && de(this, "onUpdate", !0), (_ === v && v >= this.totalDuration() || !_ && g) && (p !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !y) && (_ === v && this._ts > 0 || !_ && this._ts < 0) && zt(this, 1), e || t < 0 && !g || !_ && !g || (de(this, _ === v ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < v && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function (t, e) {
                var n = this;
                if (G(e) || (e = Jt(this, e)), !(t instanceof Ue)) {
                    if (J(t)) return t.forEach((function (t) {
                        return n.add(t, e)
                    })), this;
                    if (V(t)) return this.addLabel(t, e);
                    if (!j(t)) return this;
                    t = Ye.delayedCall(0, t)
                }
                return this !== t ? Wt(this, t, e) : this
            }, n.getChildren = function (t, e, n, i) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -I);
                for (var r = [], s = this._first; s;) s._start >= i && (s instanceof Ye ? e && r.push(s) : (n && r.push(s), t && r.push.apply(r, s.getChildren(!0, e, n)))), s = s._next;
                return r
            }, n.getById = function (t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                    if (e[n].vars.id === t) return e[n]
            }, n.remove = function (t) {
                return V(t) ? this.removeLabel(t) : j(t) ? this.killTweensOf(t) : (It(this, t), t === this._recent && (this._recent = this._last), Rt(this))
            }, n.totalTime = function (e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = bt(Se.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function (t, e) {
                return this.labels[t] = Jt(this, e), this
            }, n.removeLabel = function (t) {
                return delete this.labels[t], this
            }, n.addPause = function (t, e, n) {
                var i = Ye.delayedCall(0, e || ct, n);
                return i.data = "isPause", this._hasPause = 1, Wt(this, i, Jt(this, t))
            }, n.removePause = function (t) {
                var e = this._first;
                for (t = Jt(this, t); e;) e._start === t && "isPause" === e.data && zt(e), e = e._next
            }, n.killTweensOf = function (t, e, n) {
                for (var i = this.getTweensOf(t, n), r = i.length; r--;) ke !== i[r] && i[r].kill(t, e);
                return this
            }, n.getTweensOf = function (t, e) {
                for (var n, i = [], r = ie(t), s = this._first, o = G(e); s;) s instanceof Ye ? Mt(s._targets, r) && (o ? (!ke || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n), s = s._next;
                return i
            }, n.tweenTo = function (t, e) {
                e = e || {};
                var n = this,
                    i = Jt(n, t),
                    r = e,
                    s = r.startAt,
                    o = r.onStart,
                    a = r.onStartParams,
                    c = Ye.to(n, Ct(e, {
                        ease: "none",
                        lazy: !1,
                        time: i,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((i - (s && "time" in s ? s.time : n._time)) / n.timeScale()) || 1e-8,
                        onStart: function () {
                            n.pause();
                            var t = e.duration || Math.abs((i - n._time) / n.timeScale());
                            c._dur !== t && Xt(c, t, 0, 1).render(c._time, !0, !0), o && o.apply(c, a || [])
                        }
                    }));
                return c
            }, n.tweenFromTo = function (t, e, n) {
                return this.tweenTo(e, Ct({
                    startAt: {
                        time: Jt(this, t)
                    }
                }, n))
            }, n.recent = function () {
                return this._recent
            }, n.nextLabel = function (t) {
                return void 0 === t && (t = this._time), pe(this, Jt(this, t))
            }, n.previousLabel = function (t) {
                return void 0 === t && (t = this._time), pe(this, Jt(this, t), 1)
            }, n.currentLabel = function (t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + 1e-8)
            }, n.shiftChildren = function (t, e, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, s = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                if (e)
                    for (i in s) s[i] >= n && (s[i] += t);
                return Rt(this)
            }, n.invalidate = function () {
                var e = this._first;
                for (this._lock = 0; e;) e.invalidate(), e = e._next;
                return t.prototype.invalidate.call(this)
            }, n.clear = function (t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), Rt(this)
            }, n.totalDuration = function (t) {
                var e, n, i, r = 0,
                    o = this,
                    a = o._last,
                    c = I;
                if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
                if (o._dirty) {
                    for (i = o.parent; a;) e = a._prev, a._dirty && a.totalDuration(), (n = a._start) > c && o._sort && a._ts && !o._lock ? (o._lock = 1, Wt(o, a, n - a._delay, 1)._lock = 0) : c = n, n < 0 && a._ts && (r -= n, (!i && !o._dp || i && i.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -Infinity), c = 0), a._end > r && a._ts && (r = a._end), a = e;
                    Xt(o, o === s && o._time > r ? o._time : r, 1, 1), o._dirty = 0
                }
                return o._tDur
            }, e.updateRoot = function (t) {
                if (s._ts && (Tt(s, kt(t, s)), h = Se.frame), Se.frame >= ft) {
                    ft += O.autoSleep || 120;
                    var e = s._first;
                    if ((!e || !e._ts) && O.autoSleep && Se._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || Se.sleep()
                    }
                }
            }, e
        }(Ue);
        Ct(Be.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var ke, Ve = function (t, e, n, i, r, s, o) {
                var a, c, l, h, u, p, d, f, m = new ln(this._pt, t, e, 0, 1, nn, null, r),
                    g = 0,
                    v = 0;
                for (m.b = n, m.e = i, n += "", (d = ~(i += "").indexOf("random(")) && (i = he(i)), s && (s(f = [n, i], t, e), n = f[0], i = f[1]), c = n.match(tt) || []; a = tt.exec(i);) h = a[0], u = i.substring(g, a.index), l ? l = (l + 1) % 5 : "rgba(" === u.substr(-5) && (l = 1), h !== c[v++] && (p = parseFloat(c[v - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: u || 1 === v ? u : ",",
                    s: p,
                    c: "=" === h.charAt(1) ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1) : parseFloat(h) - p,
                    m: l && l < 4 ? Math.round : 0
                }, g = tt.lastIndex);
                return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = o, (et.test(i) || d) && (m.e = 0), this._pt = m, m
            },
            je = function (t, e, n, i, r, s, o, a, c) {
                j(i) && (i = i(r || 0, t, s));
                var l, h = t[e],
                    u = "get" !== n ? n : j(h) ? c ? t[e.indexOf("set") || !j(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](c) : t[e]() : h,
                    p = j(h) ? c ? Qe : Je : Ze;
                if (V(i) && (~i.indexOf("random(") && (i = he(i)), "=" === i.charAt(1) && (i = parseFloat(u) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + ($t(u) || 0))), u !== i) return isNaN(u * i) ? Ve.call(this, t, e, u, i, p, a || O.stringFilter, c) : (l = new ln(this._pt, t, e, +u || 0, i - (u || 0), "boolean" == typeof h ? en : tn, 0, p), c && (l.fp = c), o && l.modifier(o, this, t), this._pt = l)
            },
            Ge = function (t, e, n, i, r, s) {
                var o, a, c, l;
                if (pt[t] && !1 !== (o = new pt[t]).init(r, o.rawVars ? e[t] : function (t, e, n, i, r) {
                        if (j(t) && (t = He(t, r, e, n, i)), !H(t) || t.style && t.nodeType || J(t) || Z(t)) return V(t) ? He(t, r, e, n, i) : t;
                        var s, o = {};
                        for (s in t) o[s] = He(t[s], r, e, n, i);
                        return o
                    }(e[t], i, r, s, n), n, i, s) && (n._pt = a = new ln(n._pt, r, t, 0, 1, o.render, o, 0, o.priority), n !== u))
                    for (c = n._ptLookup[n._targets.indexOf(r)], l = o._props.length; l--;) c[o._props[l]] = a;
                return o
            },
            We = function t(e, n) {
                var i, r, o, a, c, l, h, u, p, d, f, m, g, v = e.vars,
                    y = v.ease,
                    _ = v.startAt,
                    x = v.immediateRender,
                    b = v.lazy,
                    M = v.onUpdate,
                    w = v.onUpdateParams,
                    S = v.callbackScope,
                    T = v.runBackwards,
                    A = v.yoyoEase,
                    L = v.keyframes,
                    C = v.autoRevert,
                    P = e._dur,
                    E = e._startAt,
                    N = e._targets,
                    O = e.parent,
                    I = O && "nested" === O.data ? O.parent._targets : N,
                    z = "auto" === e._overwrite,
                    R = e.timeline;
                if (R && (!L || !y) && (y = "none"), e._ease = Oe(y, D.ease), e._yEase = A ? Ee(Oe(!0 === A ? y : A, D.ease)) : 0, A && e._yoyo && !e._repeat && (A = e._yEase, e._yEase = e._ease, e._ease = A), !R) {
                    if (m = (u = N[0] ? yt(N[0]).harness : 0) && v[u.prop], i = Ot(v, lt), E && E.render(-1, !0).kill(), _) {
                        if (zt(e._startAt = Ye.set(N, Ct({
                                data: "isStart",
                                overwrite: !1,
                                parent: O,
                                immediateRender: !0,
                                lazy: q(b),
                                startAt: null,
                                delay: 0,
                                onUpdate: M,
                                onUpdateParams: w,
                                callbackScope: S,
                                stagger: 0
                            }, _))), x)
                            if (n > 0) C || (e._startAt = 0);
                            else if (P && !(n < 0 && E)) return void(n && (e._zTime = n))
                    } else if (T && P)
                        if (E) !C && (e._startAt = 0);
                        else if (n && (x = !1), o = Ct({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: x && q(b),
                            immediateRender: x,
                            stagger: 0,
                            parent: O
                        }, i), m && (o[u.prop] = m), zt(e._startAt = Ye.set(N, o)), x) {
                        if (!n) return
                    } else t(e._startAt, 1e-8);
                    for (e._pt = 0, b = P && q(b) || b && !P, r = 0; r < N.length; r++) {
                        if (h = (c = N[r])._gsap || vt(N)[r]._gsap, e._ptLookup[r] = d = {}, ut[h.id] && ht.length && St(), f = I === N ? r : I.indexOf(c), u && !1 !== (p = new u).init(c, m || i, e, f, I) && (e._pt = a = new ln(e._pt, c, p.name, 0, 1, p.render, p, 0, p.priority), p._props.forEach((function (t) {
                                d[t] = a
                            })), p.priority && (l = 1)), !u || m)
                            for (o in i) pt[o] && (p = Ge(o, i, e, f, c, I)) ? p.priority && (l = 1) : d[o] = a = je.call(e, c, o, "get", i[o], f, I, 0, v.stringFilter);
                        e._op && e._op[r] && e.kill(c, e._op[r]), z && e._pt && (ke = e, s.killTweensOf(c, d, e.globalTime(0)), g = !e.parent, ke = 0), e._pt && b && (ut[h.id] = 1)
                    }
                    l && cn(e), e._onInit && e._onInit(e)
                }
                e._from = !R && !!v.runBackwards, e._onUpdate = M, e._initted = (!e._op || e._pt) && !g
            },
            He = function (t, e, n, i, r) {
                return j(t) ? t.call(e, n, i, r) : V(t) && ~t.indexOf("random(") ? he(t) : t
            },
            qe = gt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            Xe = (qe + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
            Ye = function (t) {
                function e(e, n, r, o) {
                    var a;
                    "number" == typeof n && (r.duration = n, n = r, r = null);
                    var c, l, h, u, p, d, f, m, g = (a = t.call(this, o ? n : Dt(n), r) || this).vars,
                        v = g.duration,
                        y = g.delay,
                        _ = g.immediateRender,
                        x = g.stagger,
                        b = g.overwrite,
                        M = g.keyframes,
                        w = g.defaults,
                        S = g.scrollTrigger,
                        T = g.yoyoEase,
                        A = a.parent,
                        L = (J(e) || Z(e) ? G(e[0]) : "length" in n) ? [e] : ie(e);
                    if (a._targets = L.length ? vt(L) : ot(0, !O.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = b, M || x || Y(v) || Y(y)) {
                        if (n = a.vars, (c = a.timeline = new Be({
                                data: "nested",
                                defaults: w || {}
                            })).kill(), c.parent = i(a), M) Ct(c.vars.defaults, {
                            ease: "none"
                        }), M.forEach((function (t) {
                            return c.to(L, t, ">")
                        }));
                        else {
                            if (u = L.length, f = x ? se(x) : ct, H(x))
                                for (p in x) ~qe.indexOf(p) && (m || (m = {}), m[p] = x[p]);
                            for (l = 0; l < u; l++) {
                                for (p in h = {}, n) Xe.indexOf(p) < 0 && (h[p] = n[p]);
                                h.stagger = 0, T && (h.yoyoEase = T), m && Et(h, m), d = L[l], h.duration = +He(v, i(a), l, d, L), h.delay = (+He(y, i(a), l, d, L) || 0) - a._delay, !x && 1 === u && h.delay && (a._delay = y = h.delay, a._start += y, h.delay = 0), c.to(d, h, f(l, d, L))
                            }
                            c.duration() ? v = y = 0 : a.timeline = 0
                        }
                        v || a.duration(v = c.duration())
                    } else a.timeline = 0;
                    return !0 === b && (ke = i(a), s.killTweensOf(L), ke = 0), A && Gt(A, i(a)), (_ || !v && !M && a._start === bt(A._time) && q(_) && function t(e) {
                        return !e || e._ts && t(e.parent)
                    }(i(a)) && "nested" !== A.data) && (a._tTime = -1e-8, a.render(Math.max(0, -y))), S && Ht(i(a), S), a
                }
                r(e, t);
                var n = e.prototype;
                return n.render = function (t, e, n) {
                    var i, r, s, o, a, c, l, h, u, p = this._time,
                        d = this._tDur,
                        f = this._dur,
                        m = t > d - 1e-8 && t >= 0 ? d : t < 1e-8 ? 0 : t;
                    if (f) {
                        if (m !== this._tTime || !t || n || this._startAt && this._zTime < 0 != t < 0) {
                            if (i = m, h = this.timeline, this._repeat) {
                                if (o = f + this._rDelay, i = bt(m % o), m === d ? (s = this._repeat, i = f) : ((s = ~~(m / o)) && s === m / o && (i = f, s--), i > f && (i = f)), (c = this._yoyo && 1 & s) && (u = this._yEase, i = f - i), a = Bt(this._tTime, o), i === p && !n && this._initted) return this;
                                s !== a && (h && this._yEase && Ne(h, c), !this.vars.repeatRefresh || c || this._lock || (this._lock = n = 1, this.render(bt(o * s), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (qt(this, t < 0 ? t : i, n, e)) return this._tTime = 0, this;
                                if (f !== this._dur) return this.render(t, e, n)
                            }
                            for (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = l = (u || this._ease)(i / f), this._from && (this.ratio = l = 1 - l), i && !p && !e && de(this, "onStart"), r = this._pt; r;) r.r(l, r.d), r = r._next;
                            h && h.render(t < 0 ? t : !i && c ? -1e-8 : h._dur * l, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), de(this, "onUpdate")), this._repeat && s !== a && this.vars.onRepeat && !e && this.parent && de(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && zt(this, 1), e || t < 0 && !p || !m && !p || (de(this, m === d ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < d && this.timeScale() > 0) && this._prom()))
                        }
                    } else ! function (t, e, n, i) {
                        var r, s, o = t.ratio,
                            a = e < 0 || !e && o && !t._start && t._zTime > 1e-8 && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1,
                            c = t._rDelay,
                            l = 0;
                        if (c && t._repeat && (l = Kt(0, t._tDur, e), Bt(l, c) !== (s = Bt(t._tTime, c)) && (o = 1 - a, t.vars.repeatRefresh && t._initted && t.invalidate())), a !== o || i || 1e-8 === t._zTime || !e && t._zTime) {
                            if (!t._initted && qt(t, e, i, n)) return;
                            for (s = t._zTime, t._zTime = e || (n ? 1e-8 : 0), n || (n = e && !s), t.ratio = a, t._from && (a = 1 - a), t._time = 0, t._tTime = l, n || de(t, "onStart"), r = t._pt; r;) r.r(a, r.d), r = r._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && de(t, "onUpdate"), l && t._repeat && !n && t.parent && de(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === a && (a && zt(t, 1), n || (de(t, a ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                        } else t._zTime || (t._zTime = e)
                    }(this, t, e, n);
                    return this
                }, n.targets = function () {
                    return this._targets
                }, n.invalidate = function () {
                    return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
                }, n.kill = function (t, e) {
                    if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return fe(this);
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(t, e, ke && !0 !== ke.vars.overwrite)._first || fe(this), this.parent && n !== this.timeline.totalDuration() && Xt(this, this._dur * this.timeline._tDur / n, 0, 1), this
                    }
                    var i, r, s, o, a, c, l, h = this._targets,
                        u = t ? ie(t) : h,
                        p = this._ptLookup,
                        d = this._pt;
                    if ((!e || "all" === e) && function (t, e) {
                            for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                            return n < 0
                        }(h, u)) return "all" === e && (this._pt = 0), fe(this);
                    for (i = this._op = this._op || [], "all" !== e && (V(e) && (a = {}, xt(e, (function (t) {
                            return a[t] = 1
                        })), e = a), e = function (t, e) {
                            var n, i, r, s, o = t[0] ? yt(t[0]).harness : 0,
                                a = o && o.aliases;
                            if (!a) return e;
                            for (i in n = Et({}, e), a)
                                if (i in n)
                                    for (r = (s = a[i].split(",")).length; r--;) n[s[r]] = n[i];
                            return n
                        }(h, e)), l = h.length; l--;)
                        if (~u.indexOf(h[l]))
                            for (a in r = p[l], "all" === e ? (i[l] = e, o = r, s = {}) : (s = i[l] = i[l] || {}, o = e), o)(c = r && r[a]) && ("kill" in c.d && !0 !== c.d.kill(a) || It(this, c, "_pt"), delete r[a]), "all" !== s && (s[a] = 1);
                    return this._initted && !this._pt && d && fe(this), this
                }, e.to = function (t, n) {
                    return new e(t, n, arguments[2])
                }, e.from = function (t, n) {
                    return new e(t, wt(arguments, 1))
                }, e.delayedCall = function (t, n, i, r) {
                    return new e(n, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: t,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: i,
                        onReverseCompleteParams: i,
                        callbackScope: r
                    })
                }, e.fromTo = function (t, n, i) {
                    return new e(t, wt(arguments, 2))
                }, e.set = function (t, n) {
                    return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
                }, e.killTweensOf = function (t, e, n) {
                    return s.killTweensOf(t, e, n)
                }, e
            }(Ue);
        Ct(Ye.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), xt("staggerTo,staggerFrom,staggerFromTo", (function (t) {
            Ye[t] = function () {
                var e = new Be,
                    n = te.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var Ze = function (t, e, n) {
                return t[e] = n
            },
            Je = function (t, e, n) {
                return t[e](n)
            },
            Qe = function (t, e, n, i) {
                return t[e](i.fp, n)
            },
            Ke = function (t, e, n) {
                return t.setAttribute(e, n)
            },
            $e = function (t, e) {
                return j(t[e]) ? Je : W(t[e]) && t.setAttribute ? Ke : Ze
            },
            tn = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
            },
            en = function (t, e) {
                return e.set(e.t, e.p, !!(e.s + e.c * t), e)
            },
            nn = function (t, e) {
                var n = e._pt,
                    i = "";
                if (!t && e.b) i = e.b;
                else if (1 === t && e.e) i = e.e;
                else {
                    for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                    i += e.c
                }
                e.set(e.t, e.p, i, e)
            },
            rn = function (t, e) {
                for (var n = e._pt; n;) n.r(t, n.d), n = n._next
            },
            sn = function (t, e, n, i) {
                for (var r, s = this._pt; s;) r = s._next, s.p === i && s.modifier(t, e, n), s = r
            },
            on = function (t) {
                for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? It(this, i, "_pt") : i.dep || (e = 1), i = n;
                return !e
            },
            an = function (t, e, n, i) {
                i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
            },
            cn = function (t) {
                for (var e, n, i, r, s = t._pt; s;) {
                    for (e = s._next, n = i; n && n.pr > s.pr;) n = n._next;
                    (s._prev = n ? n._prev : r) ? s._prev._next = s: i = s, (s._next = n) ? n._prev = s : r = s, s = e
                }
                t._pt = i
            },
            ln = function () {
                function t(t, e, n, i, r, s, o, a, c) {
                    this.t = e, this.s = i, this.c = r, this.p = n, this.r = s || tn, this.d = o || this, this.set = a || Ze, this.pr = c || 0, this._next = t, t && (t._prev = this)
                }
                return t.prototype.modifier = function (t, e, n) {
                    this.mSet = this.mSet || this.set, this.set = an, this.m = t, this.mt = n, this.tween = e
                }, t
            }();
        xt(gt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
            return lt[t] = 1
        })), it.TweenMax = it.TweenLite = Ye, it.TimelineLite = it.TimelineMax = Be, s = new Be({
            sortChildren: !1,
            defaults: D,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), O.stringFilter = we;
        var hn = {
            registerPlugin: function () {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                e.forEach((function (t) {
                    return me(t)
                }))
            },
            timeline: function (t) {
                return new Be(t)
            },
            getTweensOf: function (t, e) {
                return s.getTweensOf(t, e)
            },
            getProperty: function (t, e, n, i) {
                V(t) && (t = ie(t)[0]);
                var r = yt(t || {}).get,
                    s = n ? Lt : At;
                return "native" === n && (n = ""), t ? e ? s((pt[e] && pt[e].get || r)(t, e, n, i)) : function (e, n, i) {
                    return s((pt[e] && pt[e].get || r)(t, e, n, i))
                } : t
            },
            quickSetter: function (t, e, n) {
                if ((t = ie(t)).length > 1) {
                    var i = t.map((function (t) {
                            return dn.quickSetter(t, e, n)
                        })),
                        r = i.length;
                    return function (t) {
                        for (var e = r; e--;) i[e](t)
                    }
                }
                t = t[0] || {};
                var s = pt[e],
                    o = yt(t),
                    a = o.harness && (o.harness.aliases || {})[e] || e,
                    c = s ? function (e) {
                        var i = new s;
                        u._pt = 0, i.init(t, n ? e + n : e, u, 0, [t]), i.render(1, i), u._pt && rn(1, u)
                    } : o.set(t, a);
                return s ? c : function (e) {
                    return c(t, a, n ? e + n : e, o, 1)
                }
            },
            isTweening: function (t) {
                return s.getTweensOf(t, !0).length > 0
            },
            defaults: function (t) {
                return t && t.ease && (t.ease = Oe(t.ease, D.ease)), Nt(D, t || {})
            },
            config: function (t) {
                return Nt(O, t || {})
            },
            registerEffect: function (t) {
                var e = t.name,
                    n = t.effect,
                    i = t.plugins,
                    r = t.defaults,
                    s = t.extendTimeline;
                (i || "").split(",").forEach((function (t) {
                    return t && !pt[t] && !it[t] && ot()
                })), dt[e] = function (t, e, i) {
                    return n(ie(t), Ct(e || {}, r), i)
                }, s && (Be.prototype[e] = function (t, n, i) {
                    return this.add(dt[e](t, H(n) ? n : (i = n) && {}, this), i)
                })
            },
            registerEase: function (t, e) {
                Ae[t] = Oe(e)
            },
            parseEase: function (t, e) {
                return arguments.length ? Oe(t, e) : Ae
            },
            getById: function (t) {
                return s.getById(t)
            },
            exportRoot: function (t, e) {
                void 0 === t && (t = {});
                var n, i, r = new Be(t);
                for (r.smoothChildTiming = q(t.smoothChildTiming), s.remove(r), r._dp = 0, r._time = r._tTime = s._time, n = s._first; n;) i = n._next, !e && !n._dur && n instanceof Ye && n.vars.onComplete === n._targets[0] || Wt(r, n, n._start - n._delay), n = i;
                return Wt(s, r, 0), r
            },
            utils: {
                wrap: function t(e, n, i) {
                    var r = n - e;
                    return J(e) ? le(e, t(0, e.length), n) : Qt(i, (function (t) {
                        return (r + (t - e) % r) % r + e
                    }))
                },
                wrapYoyo: function t(e, n, i) {
                    var r = n - e,
                        s = 2 * r;
                    return J(e) ? le(e, t(0, e.length - 1), n) : Qt(i, (function (t) {
                        return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                    }))
                },
                distribute: se,
                random: ce,
                snap: ae,
                normalize: function (t, e, n) {
                    return ue(t, e, 0, 1, n)
                },
                getUnit: $t,
                clamp: function (t, e, n) {
                    return Qt(n, (function (n) {
                        return Kt(t, e, n)
                    }))
                },
                splitColor: ye,
                toArray: ie,
                mapRange: ue,
                pipe: function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return function (t) {
                        return e.reduce((function (t, e) {
                            return e(t)
                        }), t)
                    }
                },
                unitize: function (t, e) {
                    return function (n) {
                        return t(parseFloat(n)) + (e || $t(n))
                    }
                },
                interpolate: function t(e, n, i, r) {
                    var s = isNaN(e + n) ? 0 : function (t) {
                        return (1 - t) * e + t * n
                    };
                    if (!s) {
                        var o, a, c, l, h, u = V(e),
                            p = {};
                        if (!0 === i && (r = 1) && (i = null), u) e = {
                            p: e
                        }, n = {
                            p: n
                        };
                        else if (J(e) && !J(n)) {
                            for (c = [], l = e.length, h = l - 2, a = 1; a < l; a++) c.push(t(e[a - 1], e[a]));
                            l--, s = function (t) {
                                t *= l;
                                var e = Math.min(h, ~~t);
                                return c[e](t - e)
                            }, i = n
                        } else r || (e = Et(J(e) ? [] : {}, e));
                        if (!c) {
                            for (o in n) je.call(p, e, o, "get", n[o]);
                            s = function (t) {
                                return rn(t, p) || (u ? e.p : e)
                            }
                        }
                    }
                    return Qt(i, s)
                },
                shuffle: re
            },
            install: st,
            effects: dt,
            ticker: Se,
            updateRoot: Be.updateRoot,
            plugins: pt,
            globalTimeline: s,
            core: {
                PropTween: ln,
                globals: at,
                Tween: Ye,
                Timeline: Be,
                Animation: Ue,
                getCache: yt,
                _removeLinkedListItem: It
            }
        };
        xt("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
            return hn[t] = Ye[t]
        })), Se.add(Be.updateRoot), u = hn.to({}, {
            duration: 0
        });
        var un = function (t, e) {
                for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                return n
            },
            pn = function (t, e) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function (t, n, i) {
                        i._onInit = function (t) {
                            var i, r;
                            if (V(n) && (i = {}, xt(n, (function (t) {
                                    return i[t] = 1
                                })), n = i), e) {
                                for (r in i = {}, n) i[r] = e(n[r]);
                                n = i
                            }! function (t, e) {
                                var n, i, r, s = t._targets;
                                for (n in e)
                                    for (i = s.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = un(r, n)), r && r.modifier && r.modifier(e[n], t, s[i], n))
                            }(t, n)
                        }
                    }
                }
            },
            dn = hn.registerPlugin({
                name: "attr",
                init: function (t, e, n, i, r) {
                    var s, o;
                    for (s in e)(o = this.add(t, "setAttribute", (t.getAttribute(s) || 0) + "", e[s], i, r, 0, 0, s)) && (o.op = s), this._props.push(s)
                }
            }, {
                name: "endArray",
                init: function (t, e) {
                    for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
                }
            }, pn("roundProps", oe), pn("modifiers"), pn("snap", ae)) || hn;
        Ye.version = Be.version = dn.version = "3.5.1", l = 1, X() && Te();
        Ae.Power0, Ae.Power1, Ae.Power2, Ae.Power3, Ae.Power4, Ae.Linear, Ae.Quad, Ae.Cubic, Ae.Quart, Ae.Quint, Ae.Strong, Ae.Elastic, Ae.Back, Ae.SteppedEase, Ae.Bounce, Ae.Sine, Ae.Expo, Ae.Circ;
        var fn, mn, gn, vn, yn, _n, xn, bn, Mn = {},
            wn = 180 / Math.PI,
            Sn = Math.PI / 180,
            Tn = Math.atan2,
            An = /([A-Z])/g,
            Ln = /(?:left|right|width|margin|padding|x)/i,
            Cn = /[\s,\(]\S/,
            Pn = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            En = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            Nn = function (t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            On = function (t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            },
            Dn = function (t, e) {
                var n = e.s + e.c * t;
                e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
            },
            In = function (t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            },
            zn = function (t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            },
            Rn = function (t, e, n) {
                return t.style[e] = n
            },
            Fn = function (t, e, n) {
                return t.style.setProperty(e, n)
            },
            Un = function (t, e, n) {
                return t._gsap[e] = n
            },
            Bn = function (t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            },
            kn = function (t, e, n, i, r) {
                var s = t._gsap;
                s.scaleX = s.scaleY = n, s.renderTransform(r, s)
            },
            Vn = function (t, e, n, i, r) {
                var s = t._gsap;
                s[e] = n, s.renderTransform(r, s)
            },
            jn = "transform",
            Gn = jn + "Origin",
            Wn = function (t, e) {
                var n = mn.createElementNS ? mn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : mn.createElement(t);
                return n.style ? n : mn.createElement(t)
            },
            Hn = function t(e, n, i) {
                var r = getComputedStyle(e);
                return r[n] || r.getPropertyValue(n.replace(An, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, Xn(n) || n, 1) || ""
            },
            qn = "O,Moz,ms,Ms,Webkit".split(","),
            Xn = function (t, e, n) {
                var i = (e || yn).style,
                    r = 5;
                if (t in i && !n) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(qn[r] + t in i););
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? qn[r] : "") + t
            },
            Yn = function () {
                "undefined" != typeof window && window.document && (fn = window, mn = fn.document, gn = mn.documentElement, yn = Wn("div") || {
                    style: {}
                }, _n = Wn("div"), jn = Xn(jn), Gn = jn + "Origin", yn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", bn = !!Xn("perspective"), vn = 1)
            },
            Zn = function t(e) {
                var n, i = Wn("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode,
                    s = this.nextSibling,
                    o = this.style.cssText;
                if (gn.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), gn.removeChild(i), this.style.cssText = o, n
            },
            Jn = function (t, e) {
                for (var n = e.length; n--;)
                    if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            },
            Qn = function (t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = Zn.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === Zn || (e = Zn.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +Jn(t, ["x", "cx", "x1"]) || 0,
                    y: +Jn(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            Kn = function (t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Qn(t))
            },
            $n = function (t, e) {
                if (e) {
                    var n = t.style;
                    e in Mn && e !== Gn && (e = jn), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(An, "-$1").toLowerCase())) : n.removeAttribute(e)
                }
            },
            ti = function (t, e, n, i, r, s) {
                var o = new ln(t._pt, e, n, 0, 1, s ? zn : In);
                return t._pt = o, o.b = i, o.e = r, t._props.push(n), o
            },
            ei = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            ni = function t(e, n, i, r) {
                var s, o, a, c, l = parseFloat(i) || 0,
                    h = (i + "").trim().substr((l + "").length) || "px",
                    u = yn.style,
                    p = Ln.test(n),
                    d = "svg" === e.tagName.toLowerCase(),
                    f = (d ? "client" : "offset") + (p ? "Width" : "Height"),
                    m = "px" === r,
                    g = "%" === r;
                return r === h || !l || ei[r] || ei[h] ? l : ("px" !== h && !m && (l = t(e, n, i, "px")), c = e.getCTM && Kn(e), g && (Mn[n] || ~n.indexOf("adius")) ? bt(l / (c ? e.getBBox()[p ? "width" : "height"] : e[f]) * 100) : (u[p ? "width" : "height"] = 100 + (m ? h : r), o = ~n.indexOf("adius") || "em" === r && e.appendChild && !d ? e : e.parentNode, c && (o = (e.ownerSVGElement || {}).parentNode), o && o !== mn && o.appendChild || (o = mn.body), (a = o._gsap) && g && a.width && p && a.time === Se.time ? bt(l / a.width * 100) : ((g || "%" === h) && (u.position = Hn(e, "position")), o === e && (u.position = "static"), o.appendChild(yn), s = yn[f], o.removeChild(yn), u.position = "absolute", p && g && ((a = yt(o)).time = Se.time, a.width = o[f]), bt(m ? s * l / 100 : s && l ? 100 / s * l : 0))))
            },
            ii = function (t, e, n, i) {
                var r;
                return vn || Yn(), e in Pn && "transform" !== e && ~(e = Pn[e]).indexOf(",") && (e = e.split(",")[0]), Mn[e] && "transform" !== e ? (r = fi(t, i), r = "transformOrigin" !== e ? r[e] : mi(Hn(t, Gn)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = ai[e] && ai[e](t, e, n) || Hn(t, e) || _t(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").indexOf(" ") ? ni(t, e, r, n) + n : r
            },
            ri = function (t, e, n, i) {
                if (!n || "none" === n) {
                    var r = Xn(e, t, 1),
                        s = r && Hn(t, r, 1);
                    s && s !== n ? (e = r, n = s) : "borderColor" === e && (n = Hn(t, "borderTopColor"))
                }
                var o, a, c, l, h, u, p, d, f, m, g, v, y = new ln(this._pt, t.style, e, 0, 1, nn),
                    _ = 0,
                    x = 0;
                if (y.b = n, y.e = i, n += "", "auto" === (i += "") && (t.style[e] = i, i = Hn(t, e) || i, t.style[e] = n), we(o = [n, i]), i = o[1], c = (n = o[0]).match($) || [], (i.match($) || []).length) {
                    for (; a = $.exec(i);) p = a[0], f = i.substring(_, a.index), h ? h = (h + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (h = 1), p !== (u = c[x++] || "") && (l = parseFloat(u) || 0, g = u.substr((l + "").length), (v = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) && (p = p.substr(2)), d = parseFloat(p), m = p.substr((d + "").length), _ = $.lastIndex - m.length, m || (m = m || O.units[e] || g, _ === i.length && (i += m, y.e += m)), g !== m && (l = ni(t, e, u, m) || 0), y._pt = {
                        _next: y._pt,
                        p: f || 1 === x ? f : ",",
                        s: l,
                        c: v ? v * d : d - l,
                        m: h && h < 4 ? Math.round : 0
                    });
                    y.c = _ < i.length ? i.substring(_, i.length) : ""
                } else y.r = "display" === e && "none" === i ? zn : In;
                return et.test(i) && (y.e = 0), this._pt = y, y
            },
            si = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            oi = function (t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var n, i, r, s = e.t,
                        o = s.style,
                        a = e.u,
                        c = s._gsap;
                    if ("all" === a || !0 === a) o.cssText = "", i = 1;
                    else
                        for (r = (a = a.split(",")).length; --r > -1;) n = a[r], Mn[n] && (i = 1, n = "transformOrigin" === n ? Gn : jn), $n(s, n);
                    i && ($n(s, jn), c && (c.svg && s.removeAttribute("transform"), fi(s, 1), c.uncache = 1))
                }
            },
            ai = {
                clearProps: function (t, e, n, i, r) {
                    if ("isFromStart" !== r.data) {
                        var s = t._pt = new ln(t._pt, e, n, 0, 0, oi);
                        return s.u = i, s.pr = -10, s.tween = r, t._props.push(n), 1
                    }
                }
            },
            ci = [1, 0, 0, 1, 0, 0],
            li = {},
            hi = function (t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            },
            ui = function (t) {
                var e = Hn(t, jn);
                return hi(e) ? ci : e.substr(7).match(K).map(bt)
            },
            pi = function (t, e) {
                var n, i, r, s, o = t._gsap || yt(t),
                    a = t.style,
                    c = ui(t);
                return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (c = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? ci : c : (c !== ci || t.offsetParent || t === gn || o.svg || (r = a.display, a.display = "block", (n = t.parentNode) && t.offsetParent || (s = 1, i = t.nextSibling, gn.appendChild(t)), c = ui(t), r ? a.display = r : $n(t, "display"), s && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : gn.removeChild(t))), e && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c)
            },
            di = function (t, e, n, i, r, s) {
                var o, a, c, l = t._gsap,
                    h = r || pi(t, !0),
                    u = l.xOrigin || 0,
                    p = l.yOrigin || 0,
                    d = l.xOffset || 0,
                    f = l.yOffset || 0,
                    m = h[0],
                    g = h[1],
                    v = h[2],
                    y = h[3],
                    _ = h[4],
                    x = h[5],
                    b = e.split(" "),
                    M = parseFloat(b[0]) || 0,
                    w = parseFloat(b[1]) || 0;
                n ? h !== ci && (a = m * y - g * v) && (c = M * (-g / a) + w * (m / a) - (m * x - g * _) / a, M = M * (y / a) + w * (-v / a) + (v * x - y * _) / a, w = c) : (M = (o = Qn(t)).x + (~b[0].indexOf("%") ? M / 100 * o.width : M), w = o.y + (~(b[1] || b[0]).indexOf("%") ? w / 100 * o.height : w)), i || !1 !== i && l.smooth ? (_ = M - u, x = w - p, l.xOffset = d + (_ * m + x * v) - _, l.yOffset = f + (_ * g + x * y) - x) : l.xOffset = l.yOffset = 0, l.xOrigin = M, l.yOrigin = w, l.smooth = !!i, l.origin = e, l.originIsAbsolute = !!n, t.style[Gn] = "0px 0px", s && (ti(s, l, "xOrigin", u, M), ti(s, l, "yOrigin", p, w), ti(s, l, "xOffset", d, l.xOffset), ti(s, l, "yOffset", f, l.yOffset)), t.setAttribute("data-svg-origin", M + " " + w)
            },
            fi = function (t, e) {
                var n = t._gsap || new Fe(t);
                if ("x" in n && !e && !n.uncache) return n;
                var i, r, s, o, a, c, l, h, u, p, d, f, m, g, v, y, _, x, b, M, w, S, T, A, L, C, P, E, N, D, I, z, R = t.style,
                    F = n.scaleX < 0,
                    U = Hn(t, Gn) || "0";
                return i = r = s = c = l = h = u = p = d = 0, o = a = 1, n.svg = !(!t.getCTM || !Kn(t)), g = pi(t, n.svg), n.svg && (A = !n.uncache && t.getAttribute("data-svg-origin"), di(t, A || U, !!A || n.originIsAbsolute, !1 !== n.smooth, g)), f = n.xOrigin || 0, m = n.yOrigin || 0, g !== ci && (x = g[0], b = g[1], M = g[2], w = g[3], i = S = g[4], r = T = g[5], 6 === g.length ? (o = Math.sqrt(x * x + b * b), a = Math.sqrt(w * w + M * M), c = x || b ? Tn(b, x) * wn : 0, (u = M || w ? Tn(M, w) * wn + c : 0) && (a *= Math.cos(u * Sn)), n.svg && (i -= f - (f * x + m * M), r -= m - (f * b + m * w))) : (z = g[6], D = g[7], P = g[8], E = g[9], N = g[10], I = g[11], i = g[12], r = g[13], s = g[14], l = (v = Tn(z, N)) * wn, v && (A = S * (y = Math.cos(-v)) + P * (_ = Math.sin(-v)), L = T * y + E * _, C = z * y + N * _, P = S * -_ + P * y, E = T * -_ + E * y, N = z * -_ + N * y, I = D * -_ + I * y, S = A, T = L, z = C), h = (v = Tn(-M, N)) * wn, v && (y = Math.cos(-v), I = w * (_ = Math.sin(-v)) + I * y, x = A = x * y - P * _, b = L = b * y - E * _, M = C = M * y - N * _), c = (v = Tn(b, x)) * wn, v && (A = x * (y = Math.cos(v)) + b * (_ = Math.sin(v)), L = S * y + T * _, b = b * y - x * _, T = T * y - S * _, x = A, S = L), l && Math.abs(l) + Math.abs(c) > 359.9 && (l = c = 0, h = 180 - h), o = bt(Math.sqrt(x * x + b * b + M * M)), a = bt(Math.sqrt(T * T + z * z)), v = Tn(S, T), u = Math.abs(v) > 2e-4 ? v * wn : 0, d = I ? 1 / (I < 0 ? -I : I) : 0), n.svg && (A = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !hi(Hn(t, jn)), A && t.setAttribute("transform", A))), Math.abs(u) > 90 && Math.abs(u) < 270 && (F ? (o *= -1, u += c <= 0 ? 180 : -180, c += c <= 0 ? 180 : -180) : (a *= -1, u += u <= 0 ? 180 : -180)), n.x = ((n.xPercent = i && Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", n.y = ((n.yPercent = r && Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + "px", n.z = s + "px", n.scaleX = bt(o), n.scaleY = bt(a), n.rotation = bt(c) + "deg", n.rotationX = bt(l) + "deg", n.rotationY = bt(h) + "deg", n.skewX = u + "deg", n.skewY = p + "deg", n.transformPerspective = d + "px", (n.zOrigin = parseFloat(U.split(" ")[2]) || 0) && (R[Gn] = mi(U)), n.xOffset = n.yOffset = 0, n.force3D = O.force3D, n.renderTransform = n.svg ? _i : bn ? yi : vi, n.uncache = 0, n
            },
            mi = function (t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            gi = function (t, e, n) {
                var i = $t(e);
                return bt(parseFloat(e) + parseFloat(ni(t, "x", n + "px", i))) + i
            },
            vi = function (t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, yi(t, e)
            },
            yi = function (t, e) {
                var n = e || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    s = n.x,
                    o = n.y,
                    a = n.z,
                    c = n.rotation,
                    l = n.rotationY,
                    h = n.rotationX,
                    u = n.skewX,
                    p = n.skewY,
                    d = n.scaleX,
                    f = n.scaleY,
                    m = n.transformPerspective,
                    g = n.force3D,
                    v = n.target,
                    y = n.zOrigin,
                    _ = "",
                    x = "auto" === g && t && 1 !== t || !0 === g;
                if (y && ("0deg" !== h || "0deg" !== l)) {
                    var b, M = parseFloat(l) * Sn,
                        w = Math.sin(M),
                        S = Math.cos(M);
                    M = parseFloat(h) * Sn, b = Math.cos(M), s = gi(v, s, w * b * -y), o = gi(v, o, -Math.sin(M) * -y), a = gi(v, a, S * b * -y + y)
                }
                "0px" !== m && (_ += "perspective(" + m + ") "), (i || r) && (_ += "translate(" + i + "%, " + r + "%) "), (x || "0px" !== s || "0px" !== o || "0px" !== a) && (_ += "0px" !== a || x ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + ") "), "0deg" !== c && (_ += "rotate(" + c + ") "), "0deg" !== l && (_ += "rotateY(" + l + ") "), "0deg" !== h && (_ += "rotateX(" + h + ") "), "0deg" === u && "0deg" === p || (_ += "skew(" + u + ", " + p + ") "), 1 === d && 1 === f || (_ += "scale(" + d + ", " + f + ") "), v.style[jn] = _ || "translate(0, 0)"
            },
            _i = function (t, e) {
                var n, i, r, s, o, a = e || this,
                    c = a.xPercent,
                    l = a.yPercent,
                    h = a.x,
                    u = a.y,
                    p = a.rotation,
                    d = a.skewX,
                    f = a.skewY,
                    m = a.scaleX,
                    g = a.scaleY,
                    v = a.target,
                    y = a.xOrigin,
                    _ = a.yOrigin,
                    x = a.xOffset,
                    b = a.yOffset,
                    M = a.forceCSS,
                    w = parseFloat(h),
                    S = parseFloat(u);
                p = parseFloat(p), d = parseFloat(d), (f = parseFloat(f)) && (d += f = parseFloat(f), p += f), p || d ? (p *= Sn, d *= Sn, n = Math.cos(p) * m, i = Math.sin(p) * m, r = Math.sin(p - d) * -g, s = Math.cos(p - d) * g, d && (f *= Sn, o = Math.tan(d - f), r *= o = Math.sqrt(1 + o * o), s *= o, f && (o = Math.tan(f), n *= o = Math.sqrt(1 + o * o), i *= o)), n = bt(n), i = bt(i), r = bt(r), s = bt(s)) : (n = m, s = g, i = r = 0), (w && !~(h + "").indexOf("px") || S && !~(u + "").indexOf("px")) && (w = ni(v, "x", h, "px"), S = ni(v, "y", u, "px")), (y || _ || x || b) && (w = bt(w + y - (y * n + _ * r) + x), S = bt(S + _ - (y * i + _ * s) + b)), (c || l) && (o = v.getBBox(), w = bt(w + c / 100 * o.width), S = bt(S + l / 100 * o.height)), o = "matrix(" + n + "," + i + "," + r + "," + s + "," + w + "," + S + ")", v.setAttribute("transform", o), M && (v.style[jn] = o)
            },
            xi = function (t, e, n, i, r, s) {
                var o, a, c = V(r),
                    l = parseFloat(r) * (c && ~r.indexOf("rad") ? wn : 1),
                    h = s ? l * s : l - i,
                    u = i + h + "deg";
                return c && ("short" === (o = r.split("_")[1]) && (h %= 360) !== h % 180 && (h += h < 0 ? 360 : -360), "cw" === o && h < 0 ? h = (h + 36e9) % 360 - 360 * ~~(h / 360) : "ccw" === o && h > 0 && (h = (h - 36e9) % 360 - 360 * ~~(h / 360))), t._pt = a = new ln(t._pt, e, n, i, h, Nn), a.e = u, a.u = "deg", t._props.push(n), a
            },
            bi = function (t, e, n) {
                var i, r, s, o, a, c, l, h = _n.style,
                    u = n._gsap;
                for (r in h.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", h[jn] = e, mn.body.appendChild(_n), i = fi(_n, 1), Mn)(s = u[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = $t(s) !== (l = $t(o)) ? ni(n, r, s, l) : parseFloat(s), c = parseFloat(o), t._pt = new ln(t._pt, u, r, a, c - a, En), t._pt.u = l || 0, t._props.push(r));
                mn.body.removeChild(_n)
            };
        xt("padding,margin,Width,Radius", (function (t, e) {
            var n = "Top",
                i = "Right",
                r = "Bottom",
                s = "Left",
                o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            ai[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
                var s, a;
                if (arguments.length < 4) return s = o.map((function (e) {
                    return ii(t, e, n)
                })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
                s = (i + "").split(" "), a = {}, o.forEach((function (t, e) {
                    return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                })), t.init(e, a, r)
            }
        }));
        var Mi, wi, Si = {
            name: "css",
            register: Yn,
            targetTest: function (t) {
                return t.style && t.nodeType
            },
            init: function (t, e, n, i, r) {
                var s, o, a, c, l, h, u, p, d, f, m, g, v, y, _, x, b, M, w, S = this._props,
                    T = t.style;
                for (u in vn || Yn(), e)
                    if ("autoRound" !== u && (o = e[u], !pt[u] || !Ge(u, e, n, i, t, r)))
                        if (l = typeof o, h = ai[u], "function" === l && (l = typeof (o = o.call(n, i, t, r))), "string" === l && ~o.indexOf("random(") && (o = he(o)), h) h(this, t, u, o, n) && (_ = 1);
                        else if ("--" === u.substr(0, 2)) this.add(T, "setProperty", getComputedStyle(t).getPropertyValue(u) + "", o + "", i, r, 0, 0, u);
                else if ("undefined" !== l) {
                    if (s = ii(t, u), c = parseFloat(s), (f = "string" === l && "=" === o.charAt(1) ? +(o.charAt(0) + "1") : 0) && (o = o.substr(2)), a = parseFloat(o), u in Pn && ("autoAlpha" === u && (1 === c && "hidden" === ii(t, "visibility") && a && (c = 0), ti(this, T, "visibility", c ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== u && "transform" !== u && ~(u = Pn[u]).indexOf(",") && (u = u.split(",")[0])), m = u in Mn)
                        if (g || ((v = t._gsap).renderTransform || fi(t), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new ln(this._pt, T, jn, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === u) this._pt = new ln(this._pt, v, "scaleY", v.scaleY, f ? f * a : a - v.scaleY), S.push("scaleY", u), u += "X";
                        else {
                            if ("transformOrigin" === u) {
                                b = void 0, M = void 0, w = void 0, b = (x = o).split(" "), M = b[0], w = b[1] || "50%", "top" !== M && "bottom" !== M && "left" !== w && "right" !== w || (x = M, M = w, w = x), b[0] = si[M] || M, b[1] = si[w] || w, o = b.join(" "), v.svg ? di(t, o, 0, y, 0, this) : ((d = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && ti(this, v, "zOrigin", v.zOrigin, d), ti(this, T, u, mi(s), mi(o)));
                                continue
                            }
                            if ("svgOrigin" === u) {
                                di(t, o, 1, y, 0, this);
                                continue
                            }
                            if (u in li) {
                                xi(this, v, u, c, o, f);
                                continue
                            }
                            if ("smoothOrigin" === u) {
                                ti(this, v, "smooth", v.smooth, o);
                                continue
                            }
                            if ("force3D" === u) {
                                v[u] = o;
                                continue
                            }
                            if ("transform" === u) {
                                bi(this, o, t);
                                continue
                            }
                        }
                    else u in T || (u = Xn(u) || u);
                    if (m || (a || 0 === a) && (c || 0 === c) && !Cn.test(o) && u in T) a || (a = 0), (p = (s + "").substr((c + "").length)) !== (d = $t(o) || (u in O.units ? O.units[u] : p)) && (c = ni(t, u, s, d)), this._pt = new ln(this._pt, m ? v : T, u, c, f ? f * a : a - c, "px" !== d || !1 === e.autoRound || m ? En : Dn), this._pt.u = d || 0, p !== d && (this._pt.b = s, this._pt.r = On);
                    else if (u in T) ri.call(this, t, u, s, o);
                    else {
                        if (!(u in t)) continue;
                        this.add(t, u, t[u], o, i, r)
                    }
                    S.push(u)
                }
                _ && cn(this)
            },
            get: ii,
            aliases: Pn,
            getSetter: function (t, e, n) {
                var i = Pn[e];
                return i && i.indexOf(",") < 0 && (e = i), e in Mn && e !== Gn && (t._gsap.x || ii(t, "x")) ? n && xn === n ? "scale" === e ? Bn : Un : (xn = n || {}) && ("scale" === e ? kn : Vn) : t.style && !W(t.style[e]) ? Rn : ~e.indexOf("-") ? Fn : $e(t, e)
            },
            core: {
                _removeProperty: $n,
                _getMatrix: pi
            }
        };
        dn.utils.checkPrefix = Xn, wi = xt("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (Mi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
            Mn[t] = 1
        })), xt(Mi, (function (t) {
            O.units[t] = "deg", li[t] = 1
        })), Pn[wi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Mi, xt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
            var e = t.split(":");
            Pn[e[1]] = wi[e[0]]
        })), xt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
            O.units[t] = "px"
        })), dn.registerPlugin(Si);
        var Ti = dn.registerPlugin(Si) || dn;
        Ti.core.Tween
    }
}]);
